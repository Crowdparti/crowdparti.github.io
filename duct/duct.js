var duct = function () { var fin = { macro_scope: function (t, e) { return t(), t }, macro: function (t, e, i) { return t }, modules: {} }; !function (t) { var e, i; t.$A = function () { for (var t = "", e = 0; e < arguments.length; e++)t += arguments[e]; return t }, t.guidi = (e = 0, function () { return Date.now() + e++ }), t.define = function (t, e) { e = e || Object; var i = {}; Object.assign(i, e.prototype); var r = t(i, e); return r.super_class = e, r.prototype = Object.create(e.prototype), Object.assign(r.prototype, i), r }, t.queue = t.define(function (t) { return t.size = function () { return this._newestIndex - this._oldestIndex }, t.enqueue = function (t) { return this._storage[this._newestIndex] = t, this._newestIndex++, t }, t.realign = function () { let t = this.size(), e = 0; for (e = 0; e < t; e++)this._storage[e + 1] = this._storage[this._oldestIndex + e]; for (e = this._oldestIndex; e < this._newestIndex; e++)this._storage[e] = void 0; this._oldestIndex = 1, this._newestIndex = this._oldestIndex + t }, t.dequeue = function () { if (this._oldestIndex !== this._newestIndex) { var t = this._storage[this._oldestIndex]; return this._storage[this._oldestIndex] = void 0, this._oldestIndex++, t } }, t.peek = function () { return this._storage[this._oldestIndex] }, function () { this._oldestIndex = 1, this._newestIndex = 1, this._storage = {} } }), t.merge_sort = function (t, e) { var i, r, n; function s(t, e, s, a, o, _) { for (i = s, r = a + 1, n = s; ;)if (_(t[i], t[r]) <= 0) { if (e[n++] = t[i++], i > a) { do { e[n++] = t[r++] } while (r <= o); break } } else if (e[n++] = t[r++], r > o) { do { e[n++] = t[i++] } while (i <= a); break } } function a(t, e, i, r, n) { if (!(r < i)) if (r != i) { var a = Math.floor(i + .5 * (r - i)); o(t, e, i, a, n), o(t, e, a + 1, r, n), s(t, e, i, a, r, n) } else e[i] = t[i] } function o(t, e, i, r, n) { if (!(r <= i)) { var o = Math.floor(i + .5 * (r - i)); a(t, e, i, o, n), a(t, e, o + 1, r, n), s(e, t, i, o, r, n) } } var _ = [], l = 0; return function (t, e, r) { for (l = 0, i = 0; i < e; i++)_[l++] = t[i]; return o(t, _, 0, e - 1, r), t } }(), t.url_loader = function () { var e = new t.queue, i = new XMLHttpRequest; return console.log("parking", e), function t(r, n, s, a) { i.isBusy ? e.enqueue([r, n, s, a]) : (i.onload = function () { n && n(this.response, a), this.abort(), this.isBusy = !1, e.size() > 0 && t.apply(this, e.dequeue()) }, i.responseType = s || "text", i.isBusy = !0, i.open("GET", r, !0), i.send()) } }(), t.urls_loader = function () { var e = new t.queue; return function i(r, n, s) { if (e.isBusy) e.enqueue([r, n, s]); else { var a = []; t.each_index(function (o, _) { e.isBusy = !0, t.url_loader(r[o][0], function (t) { a.push(t), o < r.length - 1 ? _(o + 1) : (n && n(a, s), e.size() > 0 && (e.isBusy = !1, i.apply(this, e.dequeue()))) }, r[o][1]) }) } } }(), t.array = t.define(function (t) { return t.push = function (t) { this.data[this.length++] = t }, t.peek = function () { return this.data[this.length - 1] }, t.pop = function () { return 0 === this.length ? null : this.data[--this.length] }, t.clear = function () { this.length = 0 }, t.for_each = function (t, e) { for (this.index = 0; this.index < this.length;)t(this.data[this.index], this.index++, e); this.index = 0 }, t.next = function () { return this.index < this.length ? this.data[this.index++] : null }, function () { this.data = [], this.length = 0, this.index = 0 } }), t.object_pooler = t.define(function (t) { return t.get = function (t) { return this.freed > 0 ? this.reuse ? this.reuse(this.free_objects[--this.freed], t) : this.free_objects[--this.freed] : this.allocated >= this.pool_size ? null : (this.allocated++, this.creator(t)) }, t.free = function (t) { this.free_objects[this.freed++] = t }, function (t, e, i) { this.creator = t, this.reuse = e, this.allocated = 0, this.freed = 0, this.pool_size = i || 1 / 0, this.free_objects = [] } }), t.object_pooler_ext = t.define(function (t, e) { return t.free = function (t) { this.free_objects[this.freed++] = t, null !== this.on_free && this.on_free(t) }, t.get = function (t) { return this.freed > 0 ? this.reuse ? this.reuse(this.free_objects[--this.freed], t) : this.free_objects[--this.freed] : this.allocated >= this.pool_size ? null : (this.allocated++, this.reuse(this.creator(), t)) }, function (t, i, r) { e.apply(this, arguments), this.on_free = null } }, t.object_pooler), t.event = t.define(function (t) { return t.add = function (t, e) { e = e || this.owner, this.handlers[this.handlers.length] = [t, e] }, t.trigger = function (t) { for (var e = 0; e < this.handlers.length; e++)if (!1 === this.handlers[e][0].apply(this.handlers[e][1], t)) return !1 }, t.trigger_params = function () { for (var t = 0; t < this.handlers.length; t++)if (!1 === this.handlers[t][0].apply(this.handlers[t][1], this.params)) return !1 }, function (t, e) { this.owner = t, this.handlers = [], this.params = e } }), t.each_index = function (t, e) { var i = function (e) { t(e, i) }; i(e || 0) }, t.rg = function (t, e) { null !== t && t.forEach(e) }, t.merge_object = i = function (t, e, r) { for (var n in t) "[object object]" === Object.prototype.toString.call(t[n]).toLocaleLowerCase() ? void 0 !== e[n] ? i(t[n], e[n], r) : r && (e[n] = {}, i(t[n], e[n], r)) : r ? void 0 === e[n] && (e[n] = t[n]) : e[n] = t[n]; return e }, t.create_float32 = function (t, e) { e = e || function (t) { return t }; var i = 0; return function () { var r = e(new Float32Array(t)); if (void 0 === arguments[0]) return r; if (1 === arguments.length && arguments[0].length > 0) for (i = 0; i < arguments[0].length; i++)i < t && (r[i] = arguments[0][i]); else for (i = 0; i < arguments.length; i++)i < t && (r[i] = arguments[i]); return r } }, t.is_function = function (t) { return !!(t && t.constructor && t.call && t.apply) }, t.traverse_object = function () { let e; return function i(r, n, s) { for (e in s = (s = s || "").length > 0 ? s + "." : s, r) "[object object]" === Object.prototype.toString.call(r[e]).toLocaleLowerCase() || t.is_function(r[e]) ? i(r[e], n, s + e) : n(s + e, r[e], r, e) } }(), t.parse_args_from_func = function (e) { var i; return t.rg(e.match(/function.*\(.*\)/), function (t) { (i = t.replace(/function.*\(/, "").replace(")", "").split(",")).forEach(function (t, e) { i[e] = t.trim() }) }), i || [] }, t.trace_brackets = function (t, e, i, r) { var n = 1; for (i = i || "{", r = r || "}"; 0 !== n && e < t.length;)t[e] === i ? n++ : t[e] === r && n--, e++; return e }, t.worker = function () { } }(fin); const _FM = fin.modules; var ge, ecs, math; return _FM.fin = fin, _FM.ecs = new Object, function (t) { var e = this; e.systems = {}, e.components = {}, e.app = t.define(function (i) { i.sort_systems = function () { this._systems = t.merge_sort(this._systems, this._systems.length, function (t, e) { return t.priority - e.priority }) }, i.iterate_entities = function () { var t = null; return function (e) { return void 0 === (t = this.components[e]) ? null : (-1 === t.ei && (t.ei = 0), t.ei < t.entities.length ? this.entities[t.entities[t.ei++]] : (t.ei = -1, null)) } }(), i.use_system = function (t, i) { var r = this.systems[t]; return r || ((r = new e.systems[t](i, this)).name_id = t, this.systems[t] = r, this._systems[this._systems.length] = r, r.validate(this), this.sort_systems(), this.required_validation = !0), r }, i.validate = function () { if (!0 === this.required_validation) { for (this.required_validation = !1, a = 0; a < this._systems.length; a++)this._systems[a].validate(this); this.sort_systems() } }; var r, n, s, a = 0; return i.use_component = function (i) { return this.components[i] || (n = e.components[i], this.components[i] = { priority: n.priority, name_id: i, set_instance: null, creator: n, app: this, entities: [], ei: 0 }, void 0 !== n.super_class.name_id && (this.components[i].parent = this.use_component(n.super_class.name_id)), n.validate && n.validate(this.components[i]), this._components.push(this.components[i]), this._components = t.merge_sort(this._components, this._components.length, function (t, e) { return t.priority - e.priority }), this.required_validation = !0), this.components[i] }, i.map_component_entity = function (t, e, i) { e.entities[e.entities.length] = t.uuid, t[e.name_id] = i, e.parent && this.map_component_entity(t, e.parent, i) }, i.attach_component = function (t, e, i) { if (t[(n = this.use_component(e)).name_id]) return t[n.name_id]; var r = new n.creator(i, t, this, n); return n = this.components[e], this.map_component_entity(t, this.components[e], r), t[n.name_id] }, i.create_entity = function (e) { var i = { uuid: (e = e || {}).uuid || t.guidi() }; if (this.entities[i.uuid] = i, e.components) { for (r in e.components) this.use_component(r); for (var s = 0; s < this._components.length; s++)n = this._components[s], e.components[n.name_id] && this.attach_component(i, n.name_id, e.components[n.name_id]) } return i }, i.step = function (t) { if (this.timer = .001 * performance.now(), this.current_time_delta = this.timer - this.last_timer, !(this.current_time_delta < this.req_time_delta)) { this.current_time_delta = Math.max(this.req_time_delta, this.current_time_delta), this.current_time_delta = Math.min(2 * this.req_time_delta, this.current_time_delta), this.last_timer = this.timer - this.current_time_delta % this.req_time_delta, this.validate(); var e = 0, i = 0, r = this._systems.length; for (this._app_cb.apply(this), e = 0; e < r; e++)!0 === (s = this._systems[e]).enabled && (s.time_delta = this.timer - s.last_step_time, s.time_delta > s.step_size && s.step_start()); for (e = 0; e < r; e++)!0 === (s = this._systems[e]).enabled && s.time_delta > s.step_size && (i = Date.now(), s.step(), s.on_frame.trigger(), s.frame_time = Date.now() - i); for (e = 0; e < r; e++)!0 === (s = this._systems[e]).enabled && s.time_delta > s.step_size && (s.step_end(), s.last_step_time = this.timer - s.time_delta % s.step_size) } }, i.start = function (t, e) { var i = this; function r() { i.step(), requestAnimationFrame(n) } function n() { i.step(), requestAnimationFrame(r) } i._app_cb = t || function () { }, i.req_time_delta = e || 1 / 60, this.timer = .001 * performance.now(), this.last_timer = this.timer, i.step(), requestAnimationFrame(r) }, function (t) { if (t = t || {}, this.systems = {}, this.components = {}, this._components = [], this._systems = [], this.entities = {}, t.systems) for (var e in t.systems) this.use_system(e) } }), e.component = t.define(function (t) { return function () { } }), e.system = t.define(function (e) { return e.validate = function (t) { }, e.step_start = function () { }, e.step = function () { }, e.step_end = function () { }, function (e, i) { e = e || {}, this.uuid = e.uuid || t.guidi(), this.state = 1, this.step_size = 1 / 60, this.last_step_time = 0, this.worked_items = 0, this.enabled = !0, this.time_delta = 0, this.app = i, this.on_frame = new t.event(this) } }), e.register_component = function (t, i) { i.name_id = t, this.components[i.name_id] = i, i.priority = e.register_component.priority, e.register_component.priority += 1e3 }, e.register_component.priority = 1e3, e.register_system = function (t, e) { e.name_id = t, this.systems[e.name_id] = e }, console.log("ecs", e) }.apply(_FM.ecs, [_FM.fin]), _FM.math = new Object, function (t) { var e = this; Object.assign(this, { DEGTORAD: .017453292519943295, RADTODEG: 57.29577951308232 }), this.module_export_code = function () { this.byte_code = this.byte_code.replace("/*STR_CONSTANTS*/", "Object.assign(this," + this.str_constants + ");") }, e.vec2 = t.create_float32(2), e.vec3 = t.create_float32(3), e.vec4 = t.create_float32(4), e.utils = {}, e.utils.get_bias = function (t, e) { return t / ((1 / e - 2) * (1 - t) + 1) }, e.utils.get_gain = function (t, e) { return t < .5 ? this.get_bias(2 * t, e) / 2 : this.get_bias(2 * t - 1, 1 - e) / 2 + .5 }, e.vec3.pool = new t.object_pooler(function () { return e.vec3() }), e.mat3 = t.create_float32(9, function (t) { return t[0] = 1, t[4] = 1, t[8] = 1, t }), e.mat4 = t.create_float32(16, function (t) { return t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t }), e.quat = t.create_float32(4, function (t) { return t[3] = 1, t }), e.dquat = t.create_float32(8, function (t) { return t[3] = 1, t }), e.aabb = t.create_float32(6), t.macro_scope(function (i, r, n, s, a, o, _, l, u, h, c, d, m, p, f, g, v, w, x) { e.vec3.set = t.macro(function (t, e, i, r) { t[0] = e, t[1] = i, t[2] = r }, e), e.vec3.zero = t.macro(function (t) { t[0] = 0, t[1] = 0, t[2] = 0 }, e), t.macro(function (t, e, i, r) { t[0], t[1], t[2] }, e), t.macro(function (t) { t[0], t[0], t[1], t[1], t[2], t[2] }, e), t.macro(function (t) { Math.abs(Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2])) }, e), e.vec3.length_sq = function (t) { return t[0] * t[0] + t[1] * t[1] + t[2] * t[2] }, e.vec3.get_length = function (t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]) }, e.vec3.negate = t.macro(function (t) { t[0] = -t[0], t[1] = -t[1], t[2] = -t[2] }, e), e.vec3.calc_distance = function (t, e, i, r, n, s) { return r -= t, n -= e, s -= i, Math.abs(Math.sqrt(r * r + n * n + s * s)) }, e.vec3.normalize = t.macro(function (t, e) { (s = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]) > 0 && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s }, e, i), e.vec3.transform_quat = t.macro(function (t, e, i) { s = e[0], a = e[1], o = e[2], l = i[0], u = i[1], h = i[2], c = i[3], g = u * (f = l * a - u * s) - h * (p = h * s - l * o), v = h * (m = u * o - h * a) - l * f, w = l * p - u * m, m *= d = 2 * c, p *= d, f *= d, g *= 2, v *= 2, w *= 2, t[0] = s + m + g, t[1] = a + p + v, t[2] = o + f + w }, e, i), e.vec3.copy = t.macro(function (t, e) { t[0] = e[0], t[1] = e[1], t[2] = e[2] }, e), e.vec3.scale = t.macro(function (t, e, i) { t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i }, e), e.vec3.scale_add = t.macro(function (t, e, i, r) { t[0] = e[0] + i[0] * r, t[1] = e[1] + i[1] * r, t[2] = e[2] + i[2] * r }, e), e.vec3.cross = t.macro(function (t, e, i) { t[0] = e[1] * i[2] - e[2] * i[1], t[1] = e[2] * i[0] - e[0] * i[2], t[2] = e[0] * i[1] - e[1] * i[0] }, e), e.vec3.transform_mat4 = t.macro(function (t, e, i) { s = e[0], a = e[1], o = e[2], _ = 1 / (i[3] * s + i[7] * a + i[11] * o + i[15]), x = i, t[0] = (x[0] * s + x[4] * a + x[8] * o + x[12]) * _, t[1] = (x[1] * s + x[5] * a + x[9] * o + x[13]) * _, t[2] = (x[2] * s + x[6] * a + x[10] * o + x[14]) * _ }, e, i), e.vec3.transform_mat3 = t.macro(function (t, e, i) { s = e[0], a = e[1], o = e[2], x = i, t[0] = s * x[0] + a * x[3] + o * x[6], t[1] = s * x[1] + a * x[4] + o * x[7], t[2] = s * x[2] + a * x[5] + o * x[8] }, e, i), e.vec3.transform_mat4x = t.macro(function (t, e, i, r, n) { s = e, a = i, o = r, _ = 1 / (n[3] * s + n[7] * a + n[11] * o + n[15]), t[0] = (n[0] * s + n[4] * a + n[8] * o + n[12]) * _, t[1] = (n[1] * s + n[5] * a + n[9] * o + n[13]) * _, t[2] = (n[2] * s + n[6] * a + n[10] * o + n[14]) * _ }, e, i), e.vec3.add = t.macro(function (t, e, i) { t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2] }, e), e.vec3.subtract = t.macro(function (t, e, i) { t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2] }, e), e.vec3.multiply = t.macro(function (t, e, i) { t[0] = e[0] * i[0], t[1] = e[1] * i[1], t[2] = e[2] * i[2] }, e), e.vec3.dot = function (t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] } }, "math.vec3"), t.macro_scope(function (i) { e.vec4.set = t.macro(function (t, e, i, r, n) { t[0] = e, t[1] = i, t[2] = r, t[3] = n }, e), e.vec4.copy = t.macro(function (t, e) { t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3] }, e) }, "math.vec4"), t.macro_scope(function (i, r, n, s, a, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y, b, E, A, z, T) { e.mat3.translate_rotate_scale = t.macro(function (t, e, i, s, a, o) { r = Math.sin(o), n = Math.cos(o), t[0] = (1 * n + 0 * r) * s, t[1] = (0 * n + 1 * r) * s, t[2] = (0 * n + 0 * r) * s, t[3] = (0 * n - 1 * r) * a, t[4] = (1 * n - 0 * r) * a, t[5] = (0 * n - 0 * r) * a, t[6] = e * t[0] + i * t[3], t[7] = e * t[1] + i * t[4], t[8] = e * t[2] + i * t[5] }, e, i), e.mat3.from_quat = t.macro(function (t, e) { _ = e[0], l = e[1], u = e[2], h = e[3], c = _ * (v = _ + _), d = l * v, m = l * (w = l + l), p = u * v, f = u * w, g = u * (x = u + u), y = h * v, b = h * w, b = h * x, t[0] = 1 - m - g, t[3] = d - b, t[6] = p + b, t[1] = d + b, t[4] = 1 - c - g, t[7] = f - y, t[2] = p - b, t[5] = f + y, t[8] = 1 - c - m }, e, i), e.mat3.copy = t.macro(function (t, e) { t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8] }, e, i), e.mat3.set_diagonal = t.macro(function (t, e, i, r) { t[0] = e, t[4] = i, t[8] = r }, e, i), e.mat3.mult = t.macro(function (t, e, i) { s = t, o = i, _ = (a = e)[0], l = a[1], u = a[2], c = a[3], d = a[4], m = a[5], p = a[6], f = a[7], g = a[8], v = o[0], w = o[1], x = o[2], y = o[3], b = o[4], E = o[5], A = o[6], z = o[7], T = o[8], s[0] = v * _ + w * c + x * p, s[1] = v * l + w * d + x * f, s[2] = v * u + w * m + x * g, s[3] = y * _ + b * c + E * p, s[4] = y * l + b * d + E * f, s[5] = y * u + b * m + E * g, s[6] = A * _ + z * c + T * p, s[7] = A * l + z * d + T * f, s[8] = A * u + z * m + T * g }, e, i) }, "math.mat3"), t.macro_scope(function (i, r, n, s, a, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y, b, E, A, z, T, M, L, I, S, R, F, k, G, N, C, P, q, j, D, O, U, B, H) { e.mat4.identity = t.macro(function (t) { t.fill(0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1 }, e, i), e.mat4.perspective = t.macro(function (t, e, i, n, s) { q = t, r = 1 / Math.tan(e / 2), q[0] = r / i, q[1] = 0, q[2] = 0, q[3] = 0, q[4] = 0, q[5] = r, q[6] = 0, q[7] = 0, q[8] = 0, q[9] = 0, q[11] = -1, q[12] = 0, q[13] = 0, q[15] = 0, null != s && s !== 1 / 0 ? (r = 1 / (n - s), q[10] = (s + n) * r, q[14] = 2 * s * n * r) : (q[10] = -1, q[14] = -2 * n) }, e, i), e.mat4.ortho = t.macro(function (t, e, i, a, o, _, l) { r = 1 / (e - i), n = 1 / (a - o), s = 1 / (_ - l), (q = t)[0] = -2 * r, q[1] = 0, q[2] = 0, q[3] = 0, q[4] = 0, q[6] = 0, q[7] = 0, q[8] = 0, q[9] = 0, q[5] = -2 * n, q[10] = 2 * s, q[11] = 0, q[12] = (e + i) * r, q[13] = (o + a) * n, q[14] = (l + _) * s, q[15] = 1 }, e, i), e.mat4.inverse = t.macro(function (t, e) { q = t, r = (j = e)[0], n = j[1], s = j[2], a = j[3], d = j[4], m = j[5], p = j[6], f = j[7], g = j[8], v = j[9], w = j[10], x = j[11], y = j[12], b = j[13], E = j[14], A = j[15], (z = (T = r * m - n * d) * (P = w * A - x * E) - (M = r * p - s * d) * (C = v * A - x * b) + (L = r * f - a * d) * (N = v * E - w * b) + (I = n * p - s * m) * (G = g * A - x * y) - (S = n * f - a * m) * (k = g * E - w * y) + (R = s * f - a * p) * (F = g * b - v * y)) && (z = 1 / z, q[0] = (m * P - p * C + f * N) * z, q[1] = (s * C - n * P - a * N) * z, q[2] = (b * R - E * S + A * I) * z, q[3] = (w * S - v * R - x * I) * z, q[4] = (p * G - d * P - f * k) * z, q[5] = (r * P - s * G + a * k) * z, q[6] = (E * L - y * R - A * M) * z, q[7] = (g * R - w * L + x * M) * z, q[8] = (d * C - m * G + f * F) * z, q[9] = (n * G - r * C - a * F) * z, q[10] = (y * S - b * L + A * T) * z, q[11] = (v * L - g * S - x * T) * z, q[12] = (m * k - d * N - p * F) * z, q[13] = (r * N - n * k + s * F) * z, q[14] = (b * M - y * I - E * T) * z, q[15] = (g * I - v * M + w * T) * z) }, e, i), e.mat4.transpose = t.macro(function (t, e) { t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11] }, e, i), e.mat4.from_quat = t.macro(function (t, e) { q = t, r = (O = e)[0], n = O[1], s = O[2], a = O[3], T = r * (_ = r + r), M = r * (l = n + n), L = r * (u = s + s), I = n * l, S = n * u, R = s * u, F = a * _, k = a * l, G = a * u, q[0] = 1 - (I + R), q[1] = M + G, q[2] = L - k, q[3] = 0, q[4] = M - G, q[5] = 1 - (T + R), q[6] = S + F, q[7] = 0, q[8] = L + k, q[9] = S - F, q[10] = 1 - (T + I), q[11] = 0 }, e, i), e.mat4.scale = t.macro(function (t, e) { O = e, (q = t)[0] *= O[0], q[1] *= O[0], q[2] *= O[0], q[3] *= O[0], q[4] *= O[1], q[5] *= O[1], q[6] *= O[1], q[7] *= O[1], q[8] *= O[2], q[9] *= O[2], q[10] *= O[2], q[11] *= O[2] }, e, i), e.mat4.multiply = t.macro(function (t, e, i) { q = t, D = i, r = (j = e)[0], n = j[1], s = j[2], a = j[3], d = j[4], m = j[5], p = j[6], f = j[7], g = j[8], v = j[9], w = j[10], x = j[11], y = j[12], b = j[13], E = j[14], A = j[15], T = D[0], M = D[1], L = D[2], I = D[3], q[0] = T * r + M * d + L * g + I * y, q[1] = T * n + M * m + L * v + I * b, q[2] = T * s + M * p + L * w + I * E, q[3] = T * a + M * f + L * x + I * A, T = D[4], M = D[5], L = D[6], I = D[7], q[4] = T * r + M * d + L * g + I * y, q[5] = T * n + M * m + L * v + I * b, q[6] = T * s + M * p + L * w + I * E, q[7] = T * a + M * f + L * x + I * A, T = D[8], M = D[9], L = D[10], I = D[11], q[8] = T * r + M * d + L * g + I * y, q[9] = T * n + M * m + L * v + I * b, q[10] = T * s + M * p + L * w + I * E, q[11] = T * a + M * f + L * x + I * A, T = D[12], M = D[13], L = D[14], I = D[15], q[12] = T * r + M * d + L * g + I * y, q[13] = T * n + M * m + L * v + I * b, q[14] = T * s + M * p + L * w + I * E, q[15] = T * a + M * f + L * x + I * A }, e, i), e.mat4.copy = t.macro(function (t, e) { j = e, (q = t)[0] = j[0], q[1] = j[1], q[2] = j[2], q[3] = j[3], q[4] = j[4], q[5] = j[5], q[6] = j[6], q[7] = j[7], q[8] = j[8], q[9] = j[9], q[10] = j[10], q[11] = j[11], q[12] = j[12], q[13] = j[13], q[14] = j[14], q[15] = j[15] }, e, i), e.mat4.sd_vector = function (t, e) { t[0] = e[0], t[1] = e[1], t[2] = e[2] }, e.mat4.up_vector = function (t, e) { t[0] = e[4], t[1] = e[5], t[2] = e[6] }, e.mat4.fw_vector = function (t, e) { t[0] = e[8], t[1] = e[9], t[2] = e[10] }, e.mat4.from_mat3 = t.macro(function (t, e) { j = e, (q = t)[0] = j[0], q[1] = j[1], q[2] = j[2], q[4] = j[3], q[5] = j[4], q[6] = j[5], q[8] = j[6], q[9] = j[7], q[10] = j[8] }, e, i), e.mat4.target_to = t.macro(function (t, e, i, a) { q = t, B = a, H = i, r = (U = e)[0] - H[0], n = U[1] - H[1], s = U[2] - H[2], (z = r * r + n * n + s * s) > 0 && (z = 1 / Math.sqrt(z), r *= z, n *= z, s *= z), T = B[1] * s - B[2] * n, M = B[2] * r - B[0] * s, L = B[0] * n - B[1] * r, (z = T * T + M * M + L * L) > 0 && (z = 1 / Math.sqrt(z), T *= z, M *= z, L *= z), q[0] = T, q[1] = M, q[2] = L, q[3] = 0, q[4] = n * L - s * M, q[5] = s * T - r * L, q[6] = r * M - n * T, q[7] = 0, q[8] = r, q[9] = n, q[10] = s, q[11] = 0, q[12] = U[0], q[13] = U[1], q[14] = U[2], q[15] = 1 }, e, i), e.mat4.get_scaling = function (t, e) { return t[0] = Math.hypot(e[0], e[1], e[2]), t[1] = Math.hypot(e[4], e[5], e[6]), t[2] = Math.hypot(e[8], e[9], e[10]), t }, e.mat4.get_translation = function (t, e) { return t[0] = e[12], t[1] = e[13], t[2] = e[14], t }; var X, K, Z, V, W, Q, Y, $, J, tt, et, it, rt, nt, st = e.vec3(); e.mat4.get_rotation = function (t, e) { return this.get_scaling(st, e), X = 1 / st[0], K = 1 / st[1], Z = 1 / st[2], V = e[0] * X, W = e[1] * K, Q = e[2] * Z, Y = e[4] * X, $ = e[5] * K, J = e[6] * Z, tt = e[8] * X, et = e[9] * K, it = e[10] * Z, nt = 0, (rt = V + $ + it) > 0 ? (nt = 2 * Math.sqrt(rt + 1), t[3] = .25 * nt, t[0] = (J - et) / nt, t[1] = (tt - Q) / nt, t[2] = (W - Y) / nt) : V > $ && V > it ? (nt = 2 * Math.sqrt(1 + V - $ - it), t[3] = (J - et) / nt, t[0] = .25 * nt, t[1] = (W + Y) / nt, t[2] = (tt + Q) / nt) : $ > it ? (nt = 2 * Math.sqrt(1 + $ - V - it), t[3] = (tt - Q) / nt, t[0] = (W + Y) / nt, t[1] = .25 * nt, t[2] = (J + et) / nt) : (nt = 2 * Math.sqrt(1 + it - V - $), t[3] = (W - Y) / nt, t[0] = (tt + Q) / nt, t[1] = (J + et) / nt, t[2] = .25 * nt), t } }, "math.mat4"), t.macro_scope(function (i, r, n, s, a, o) { e.aabb.set = t.macro(function (t, e, i, r, n, s, a) { t[0] = e, t[1] = i, t[2] = r, t[3] = n, t[4] = s, t[5] = a }, e, i), e.aabb.transform_mat4 = t.macro(function (t, e, i) { for (r = 0; r < 3; r++)for (t[r] = i[12 + r], t[r + 3] = i[12 + r], n = 0; n < 3; n++)o = i[3 * n + r + n], s = o * e[n], a = o * e[n + 3], s < a ? (t[r] += s, t[r + 3] += a) : (t[r] += a, t[r + 3] += s) }, e, i), e.aabb.decompose = t.macro(function (t, e, i) { e[0] = t[0], e[1] = t[1], e[2] = t[2], i[0] = t[3], i[1] = t[4], i[2] = t[5] }, e, i) }, "math.aabb"), t.macro_scope(function (i, r, n, a, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y) { e.quat.mult = t.macro(function (t, e, i) { m = t, f = i, r = (p = e)[0], n = p[1], a = p[2], o = p[3], _ = f[0], l = f[1], u = f[2], h = f[3], m[0] = r * h + o * _ + n * u - a * l, m[1] = n * h + o * l + a * _ - r * u, m[2] = a * h + o * u + r * l - n * _, m[3] = o * h - r * _ - n * l - a * u }, e, i), e.quat.copy = t.macro(function (t, e) { t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3] }, e, i), e.quat.normalize = t.macro(function (t, e) { m = t, r = (p = e)[0], n = p[1], a = p[2], o = p[3], (c = r * r + n * n + a * a + o * o) > 0 && (c = 1 / Math.sqrt(c)), m[0] = r * c, m[1] = n * c, m[2] = a * c, m[3] = o * c }, e, i), e.quat.rotate_eular = t.macro(function (t, e, i, s) { m = t, r = Math.sin(.5 * e), n = Math.sin(.5 * i), a = Math.sin(.5 * s), _ = Math.cos(.5 * e), l = Math.cos(.5 * i), u = Math.cos(.5 * s), m[0] = r * l * u - _ * n * a, m[1] = _ * n * u + r * l * a, m[2] = _ * l * a - r * n * u, m[3] = _ * l * u + r * n * a, r = m[0], n = m[1], a = m[2], o = m[3], (c = r * r + n * n + a * a + o * o) > 0 && (c = 1 / Math.sqrt(c)), m[0] = r * c, m[1] = n * c, m[2] = a * c, m[3] = o * c }, e, i), e.quat.invert = t.macro(function (t, e) { m = t, r = (p = e)[0], n = p[1], a = p[2], o = p[3], (c = r * r + n * n + a * a + o * o) > 0 && (c = 1 / Math.sqrt(c)), m[0] = -r * c, m[1] = -n * c, m[2] = -a * c, m[3] = o * c }, e, i), e.quat.slerp_flat = t.macro(function (t, e, i, r, n, s, a, o, _, l) { (g = e * s + i * a + r * o + n * _) < 0 && (g = -g, s = -s, a = -a, o = -o, _ = -_), 1 - g > 1e-6 && (v = Math.acos(g), Math.sin(v), Math.sin((1 - l) * v), Math.sin(l * v)), t[0] = scale0 * e + scale1 * s, t[1] = scale0 * i + scale1 * a, t[2] = scale0 * r + scale1 * o, t[3] = scale0 * n + scale1 * _ }, e, i), e.quat.from_vec3_float = t.macro(function (t, e, i) { t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = i }, e), e.quat.from_mat3 = t.macro(function (t, e) { m = t, _ = (d = e)[0], l = d[4], u = d[8], (h = _ + l + u) > 0 ? (h = Math.sqrt(h + 1), quat1$[3] = .5 * h, s = .5 / h, quat1$[0] = (d[7] - d[5]) * h, quat1$[1] = (d[2] - d[6]) * h, quat1$[2] = (d[3] - d[1]) * h) : _ > l ? _ > u ? (h = Math.sqrt(_ - l - u + 1), quat1$[0] = .5 * h, h = .5 / h, quat1$[1] = (d[1] + d[3]) * h, quat1$[2] = (d[2] + d[6]) * h, quat1$[3] = (d[7] - d[5]) * h) : (h = Math.sqrt(e22 - _ - l + 1), quat1$[2] = .5 * h, h = .5 / h, quat1$[0] = (d[2] + d[6]) * h, quat1$[1] = (d[5] + d[7]) * h, quat1$[3] = (d[3] - d[1]) * h) : l > u ? (h = Math.sqrt(l - u - _ + 1), quat1$[1] = .5 * h, h = .5 / h, quat1$[0] = (d[1] + d[3]) * h, quat1$[2] = (d[5] + d[7]) * h, quat1$[3] = (d[2] - d[6]) * h) : (h = Math.sqrt(u - _ - l + 1), quat1$[2] = .5 * h, h = .5 / h, quat1$[0] = (d[2] + d[6]) * h, quat1$[1] = (d[5] + d[7]) * h, quat1$[3] = (d[3] - d[1]) * h) }, e) }, "math.quat"), t.macro_scope(function (i, r, n, s, a, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y, b) { e.dquat.mult = t.macro(function (t, e, i) { r = t, s = i, a = (n = e)[0], o = n[1], _ = n[2], l = n[3], u = n[4], h = n[5], c = n[6], d = n[7], m = s[0], p = s[1], f = s[2], g = s[3], v = s[4], w = s[5], x = s[6], y = s[7], r[0] = a * g + l * m + o * f - _ * p, r[1] = o * g + l * p + _ * m - a * f, r[2] = _ * g + l * f + a * p - o * m, r[3] = l * g - a * m - o * p - _ * f, r[4] = a * y + l * v + o * x - _ * w + u * g + d * m + h * f - c * p, r[5] = o * y + l * w + _ * v - a * x + h * g + d * p + c * m - u * f, r[6] = _ * y + l * x + a * w - o * v + c * g + d * f + u * p - h * m, r[7] = l * y - a * v - o * w - _ * x + d * g - u * m - h * p - c * f }, e, i), e.dquat.from_quat_pos = t.macro(function (t, e, i) { (r = t)[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], a = .5 * i[0], o = .5 * i[1], _ = .5 * i[2], m = r[0], p = r[1], f = r[2], g = r[3], r[4] = a * g + o * f - _ * p, r[5] = o * g + _ * m - a * f, r[6] = _ * g + a * p - o * m, r[7] = -a * m - o * p - _ * f }, e, i), e.dquat.invert = t.macro(function (t, e) { r = t, a = (n = e)[0], o = n[1], _ = n[2], l = n[3], (b = a * a + o * o + _ * _ + l * l) > 0 && (b = 1 / Math.sqrt(b)), r[0] = -a * b, r[1] = -o * b, r[2] = -_ * b, r[3] = l * b }, e, i); var E = e.quat(), A = e.vec3(); e.dquat.from_mat4 = function (t, i) { return e.mat4.get_rotation(E, i), e.mat4.get_translation(A, i), e.dquat.from_quat_pos(t, E, A), t }, e.dquat.get_translation = function (t, e) { return a = e[4], o = e[5], _ = e[6], l = e[7], m = -e[0], p = -e[1], f = -e[2], g = e[3], t[0] = 2 * (a * g + l * m + o * f - _ * p), t[1] = 2 * (o * g + l * p + _ * m - a * f), t[2] = 2 * (_ * g + l * f + a * p - o * m), t } }, "math.dquat"), t.macro_scope(function (t) { e.utils.ray_plane_intersection = function (t, i, r, n, s) { var a = e.vec3.pool.get(); e.vec3.subtract(a, r, i); var o = e.vec3.dot(a, s); if (o <= 1e-6 && o >= -1e-6) return !1; var _ = e.vec3.pool.get(); return e.vec3.subtract(_, n, i), o = e.vec3.dot(_, s) / o, e.vec3.pool.free(a), e.vec3.pool.free(_), o >= 0 && (e.vec3.scale_add(t, i, a, o), !0) }, e.utils.mat4_into_up_fw_sd = function (t) { return { up: new Float32Array(t.buffer, 16, 3), fw: new Float32Array(t.buffer, 32, 3), sd: new Float32Array(t.buffer, 0, 3) } } }, "math.utils") }.apply(_FM.math, [_FM.fin]), _FM.ge = new Object, function (t, e) { Object.assign(this, { SHADING: { FLAT: 2, SHADED: 4, POST_SHADING: 8, CAST_SHADOW: 16, RECEIVE_SHADOW: 32, RECEIVE_REFLECTION: 64, TRANSPARENT: 128, OPUQUE: 256, DEPTH_TEST: 512, NO_DEPTH_TEST: 1024, DOUBLE_SIDES: 2048, SHADOW_DOUBLE_SIDES: 4096 }, DISPLAY_ALWAYS: 2, ITEM_TYPES: { MESH: 4, LIGHT: 8, CAMERA: 16, MANIPULATOR: 32, OTHER: 1024 }, PICKABLE_MESH: 2048, TRANS: { SCALABLE: 2, ANIMATED: 4, ANIMATED_POSITION: 8, ANIMATED_SCALE: 16, ANIMATED_ROTATION: 32, IK_ANIMATED: 64 }, GL_ACTIVE_ATTRIBUTES: 35721, GL_ACTIVE_TEXTURE: 34016, GL_ACTIVE_UNIFORMS: 35718, GL_ALIASED_LINE_WIDTH_RANGE: 33902, GL_ALIASED_POINT_SIZE_RANGE: 33901, GL_ALPHA: 6406, GL_ALPHA_BITS: 3413, GL_ALWAYS: 519, GL_ARRAY_BUFFER: 34962, GL_ARRAY_BUFFER_BINDING: 34964, GL_ATTACHED_SHADERS: 35717, GL_BACK: 1029, GL_BLEND: 3042, GL_BLEND_COLOR: 32773, GL_BLEND_DST_ALPHA: 32970, GL_BLEND_DST_RGB: 32968, GL_BLEND_EQUATION: 32777, GL_BLEND_EQUATION_ALPHA: 34877, GL_BLEND_EQUATION_RGB: 32777, GL_BLEND_SRC_ALPHA: 32971, GL_BLEND_SRC_RGB: 32969, GL_BLUE_BITS: 3412, GL_BOOL: 35670, GL_BOOL_VEC2: 35671, GL_BOOL_VEC3: 35672, GL_BOOL_VEC4: 35673, GL_BROWSER_DEFAULT_WEBGL: 37444, GL_BUFFER_SIZE: 34660, GL_BUFFER_USAGE: 34661, GL_BYTE: 5120, GL_CCW: 2305, GL_CLAMP_TO_EDGE: 33071, GL_COLOR_ATTACHMENT0: 36064, GL_COLOR_BUFFER_BIT: 16384, GL_COLOR_CLEAR_VALUE: 3106, GL_COLOR_WRITEMASK: 3107, GL_COMPILE_STATUS: 35713, GL_COMPRESSED_TEXTURE_FORMATS: 34467, GL_CONSTANT_ALPHA: 32771, GL_CONSTANT_COLOR: 32769, GL_CONTEXT_LOST_WEBGL: 37442, GL_CULL_FACE: 2884, GL_CULL_FACE_MODE: 2885, GL_CURRENT_PROGRAM: 35725, GL_CURRENT_VERTEX_ATTRIB: 34342, GL_CW: 2304, GL_DECR: 7683, GL_DECR_WRAP: 34056, GL_DELETE_STATUS: 35712, GL_DEPTH_ATTACHMENT: 36096, GL_DEPTH_BITS: 3414, GL_DEPTH_BUFFER_BIT: 256, GL_DEPTH_CLEAR_VALUE: 2931, GL_DEPTH_COMPONENT: 6402, GL_DEPTH_COMPONENT16: 33189, GL_DEPTH_FUNC: 2932, GL_DEPTH_RANGE: 2928, GL_DEPTH_STENCIL: 34041, GL_DEPTH_STENCIL_ATTACHMENT: 33306, GL_DEPTH_TEST: 2929, GL_DEPTH_WRITEMASK: 2930, GL_DITHER: 3024, GL_DONT_CARE: 4352, GL_DST_ALPHA: 772, GL_DST_COLOR: 774, GL_DYNAMIC_DRAW: 35048, GL_ELEMENT_ARRAY_BUFFER: 34963, GL_ELEMENT_ARRAY_BUFFER_BINDING: 34965, GL_EQUAL: 514, GL_FASTEST: 4353, GL_FLOAT: 5126, GL_FLOAT_MAT2: 35674, GL_FLOAT_MAT3: 35675, GL_FLOAT_MAT4: 35676, GL_FLOAT_VEC2: 35664, GL_FLOAT_VEC3: 35665, GL_FLOAT_VEC4: 35666, GL_FRAGMENT_SHADER: 35632, GL_FRAMEBUFFER: 36160, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048, GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051, GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050, GL_FRAMEBUFFER_BINDING: 36006, GL_FRAMEBUFFER_COMPLETE: 36053, GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054, GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057, GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055, GL_FRAMEBUFFER_UNSUPPORTED: 36061, GL_FRONT: 1028, GL_FRONT_AND_BACK: 1032, GL_FRONT_FACE: 2886, GL_FUNC_ADD: 32774, GL_FUNC_REVERSE_SUBTRACT: 32779, GL_FUNC_SUBTRACT: 32778, GL_GENERATE_MIPMAP_HINT: 33170, GL_GEQUAL: 518, GL_GREATER: 516, GL_GREEN_BITS: 3411, GL_HIGH_FLOAT: 36338, GL_HIGH_INT: 36341, GL_IMPLEMENTATION_COLOR_READ_FORMAT: 35739, GL_IMPLEMENTATION_COLOR_READ_TYPE: 35738, GL_INCR: 7682, GL_INCR_WRAP: 34055, GL_INT: 5124, GL_INT_VEC2: 35667, GL_INT_VEC3: 35668, GL_INT_VEC4: 35669, GL_INVALID_ENUM: 1280, GL_INVALID_FRAMEBUFFER_OPERATION: 1286, GL_INVALID_OPERATION: 1282, GL_INVALID_VALUE: 1281, GL_INVERT: 5386, GL_KEEP: 7680, GL_LEQUAL: 515, GL_LESS: 513, GL_LINEAR: 9729, GL_LINEAR_MIPMAP_LINEAR: 9987, GL_LINEAR_MIPMAP_NEAREST: 9985, GL_LINES: 1, GL_LINE_LOOP: 2, GL_LINE_STRIP: 3, GL_LINE_WIDTH: 2849, GL_LINK_STATUS: 35714, GL_LOW_FLOAT: 36336, GL_LOW_INT: 36339, GL_LUMINANCE: 6409, GL_LUMINANCE_ALPHA: 6410, GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661, GL_MAX_CUBE_MAP_TEXTURE_SIZE: 34076, GL_MAX_FRAGMENT_UNIFORM_VECTORS: 36349, GL_MAX_RENDERBUFFER_SIZE: 34024, GL_MAX_TEXTURE_IMAGE_UNITS: 34930, GL_MAX_TEXTURE_SIZE: 3379, GL_MAX_VARYING_VECTORS: 36348, GL_MAX_VERTEX_ATTRIBS: 34921, GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660, GL_MAX_VERTEX_UNIFORM_VECTORS: 36347, GL_MAX_VIEWPORT_DIMS: 3386, GL_MEDIUM_FLOAT: 36337, GL_MEDIUM_INT: 36340, GL_MIRRORED_REPEAT: 33648, GL_NEAREST: 9728, GL_NEAREST_MIPMAP_LINEAR: 9986, GL_NEAREST_MIPMAP_NEAREST: 9984, GL_NEVER: 512, GL_NICEST: 4354, GL_NONE: 0, GL_NOTEQUAL: 517, GL_NO_ERROR: 0, GL_ONE: 1, GL_ONE_MINUS_CONSTANT_ALPHA: 32772, GL_ONE_MINUS_CONSTANT_COLOR: 32770, GL_ONE_MINUS_DST_ALPHA: 773, GL_ONE_MINUS_DST_COLOR: 775, GL_ONE_MINUS_SRC_ALPHA: 771, GL_ONE_MINUS_SRC_COLOR: 769, GL_OUT_OF_MEMORY: 1285, GL_PACK_ALIGNMENT: 3333, GL_POINTS: 0, GL_POLYGON_OFFSET_FACTOR: 32824, GL_POLYGON_OFFSET_FILL: 32823, GL_POLYGON_OFFSET_UNITS: 10752, GL_RED_BITS: 3410, GL_RENDERBUFFER: 36161, GL_RENDERBUFFER_ALPHA_SIZE: 36179, GL_RENDERBUFFER_BINDING: 36007, GL_RENDERBUFFER_BLUE_SIZE: 36178, GL_RENDERBUFFER_DEPTH_SIZE: 36180, GL_RENDERBUFFER_GREEN_SIZE: 36177, GL_RENDERBUFFER_HEIGHT: 36163, GL_RENDERBUFFER_INTERNAL_FORMAT: 36164, GL_RENDERBUFFER_RED_SIZE: 36176, GL_RENDERBUFFER_STENCIL_SIZE: 36181, GL_RENDERBUFFER_WIDTH: 36162, GL_RENDERER: 7937, GL_REPEAT: 10497, GL_REPLACE: 7681, GL_RGB: 6407, GL_RGB5_A1: 32855, GL_RGB565: 36194, GL_RGBA: 6408, GL_RGBA4: 32854, GL_SAMPLER_2D: 35678, GL_SAMPLER_CUBE: 35680, GL_SAMPLES: 32937, GL_SAMPLE_ALPHA_TO_COVERAGE: 32926, GL_SAMPLE_BUFFERS: 32936, GL_SAMPLE_COVERAGE: 32928, GL_SAMPLE_COVERAGE_INVERT: 32939, GL_SAMPLE_COVERAGE_VALUE: 32938, GL_SCISSOR_BOX: 3088, GL_SCISSOR_TEST: 3089, GL_SHADER_TYPE: 35663, GL_SHADING_LANGUAGE_VERSION: 35724, GL_SHORT: 5122, GL_SRC_ALPHA: 770, GL_SRC_ALPHA_SATURATE: 776, GL_SRC_COLOR: 768, GL_STATIC_DRAW: 35044, GL_STENCIL_ATTACHMENT: 36128, GL_STENCIL_BACK_FAIL: 34817, GL_STENCIL_BACK_FUNC: 34816, GL_STENCIL_BACK_PASS_DEPTH_FAIL: 34818, GL_STENCIL_BACK_PASS_DEPTH_PASS: 34819, GL_STENCIL_BACK_REF: 36003, GL_STENCIL_BACK_VALUE_MASK: 36004, GL_STENCIL_BACK_WRITEMASK: 36005, GL_STENCIL_BITS: 3415, GL_STENCIL_BUFFER_BIT: 1024, GL_STENCIL_CLEAR_VALUE: 2961, GL_STENCIL_FAIL: 2964, GL_STENCIL_FUNC: 2962, GL_STENCIL_INDEX8: 36168, GL_STENCIL_PASS_DEPTH_FAIL: 2965, GL_STENCIL_PASS_DEPTH_PASS: 2966, GL_STENCIL_REF: 2967, GL_STENCIL_TEST: 2960, GL_STENCIL_VALUE_MASK: 2963, GL_STENCIL_WRITEMASK: 2968, GL_STREAM_DRAW: 35040, GL_SUBPIXEL_BITS: 3408, GL_TEXTURE: 5890, GL_TEXTURE0: 33984, GL_TEXTURE1: 33985, GL_TEXTURE2: 33986, GL_TEXTURE3: 33987, GL_TEXTURE4: 33988, GL_TEXTURE5: 33989, GL_TEXTURE6: 33990, GL_TEXTURE7: 33991, GL_TEXTURE8: 33992, GL_TEXTURE9: 33993, GL_TEXTURE10: 33994, GL_TEXTURE11: 33995, GL_TEXTURE12: 33996, GL_TEXTURE13: 33997, GL_TEXTURE14: 33998, GL_TEXTURE15: 33999, GL_TEXTURE16: 34e3, GL_TEXTURE17: 34001, GL_TEXTURE18: 34002, GL_TEXTURE19: 34003, GL_TEXTURE20: 34004, GL_TEXTURE21: 34005, GL_TEXTURE22: 34006, GL_TEXTURE23: 34007, GL_TEXTURE24: 34008, GL_TEXTURE25: 34009, GL_TEXTURE26: 34010, GL_TEXTURE27: 34011, GL_TEXTURE28: 34012, GL_TEXTURE29: 34013, GL_TEXTURE30: 34014, GL_TEXTURE31: 34015, GL_TEXTURE_2D: 3553, GL_TEXTURE_BINDING_2D: 32873, GL_TEXTURE_BINDING_CUBE_MAP: 34068, GL_TEXTURE_CUBE_MAP: 34067, GL_TEXTURE_CUBE_MAP_NEGATIVE_X: 34070, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074, GL_TEXTURE_CUBE_MAP_POSITIVE_X: 34069, GL_TEXTURE_CUBE_MAP_POSITIVE_Y: 34071, GL_TEXTURE_CUBE_MAP_POSITIVE_Z: 34073, GL_TEXTURE_MAG_FILTER: 10240, GL_TEXTURE_MIN_FILTER: 10241, GL_TEXTURE_WRAP_S: 10242, GL_TEXTURE_WRAP_T: 10243, GL_TRIANGLES: 4, GL_TRIANGLE_FAN: 6, GL_TRIANGLE_STRIP: 5, GL_UNPACK_ALIGNMENT: 3317, GL_UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443, GL_UNPACK_FLIP_Y_WEBGL: 37440, GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441, GL_UNSIGNED_BYTE: 5121, GL_UNSIGNED_INT: 5125, GL_UNSIGNED_SHORT: 5123, GL_UNSIGNED_SHORT_4_4_4_4: 32819, GL_UNSIGNED_SHORT_5_5_5_1: 32820, GL_UNSIGNED_SHORT_5_6_5: 33635, GL_VALIDATE_STATUS: 35715, GL_VENDOR: 7936, GL_VERSION: 7938, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975, GL_VERTEX_ATTRIB_ARRAY_ENABLED: 34338, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922, GL_VERTEX_ATTRIB_ARRAY_POINTER: 34373, GL_VERTEX_ATTRIB_ARRAY_SIZE: 34339, GL_VERTEX_ATTRIB_ARRAY_STRIDE: 34340, GL_VERTEX_ATTRIB_ARRAY_TYPE: 34341, GL_VERTEX_SHADER: 35633, GL_VIEWPORT: 2978, GL_ZERO: 0 }), this.module_export_code = function () { this.byte_code = this.byte_code.replace("/*STR_CONSTANTS*/", "Object.assign(this," + this.str_constants + ");") } }.apply(_FM.ge, [_FM.ecs, _FM.math]), function (t, e, i, r) { i.define = t.define, i.guidi = t.guidi, i.str = function (t, e, i, r, n, s) { return t = "var arr=[];arr.push('" + t.replace(/\n/g, "\\n").replace(/[\r\t]/g, " ").split("<?").join("\t").replace(/((^|\?>)[^\t]*)'/g, "$1\r").replace(/\t=(.*?)\?>/g, "',$1,'").split("\t").join("');").split("?>").join("arr.push('").split("\r").join("\\'") + "');return arr.join('');", new Function(e, i, r, n, s, t) }, i.create_canvas = function (t, e) { var i = document.createElement("canvas"); return i.ctx = i.getContext("2d"), i.width = t, i.height = e, i.set_size = function (t, e) { this.width = t, this.height = e }, i._get_image_data = function () { return this.imd = this.ctx.getImageData(0, 0, this.width, this.height), this.imd }, i._put_image_data = function () { this.ctx.putImageData(this.imd, 0, 0) }, i }, i.mouse_events = function (t, e) { t.addEventListener("mousedown", function (i) { t.bound_rect = t.bound_rect || t.getBoundingClientRect(), t.mouse_x = i.clientX - t.bound_rect.left, t.mouse_y = i.clientY - t.bound_rect.top, t.mouse_button = i.buttons, e(t, "mousedown", t.mouse_x, t.mouse_y, i) }), t.addEventListener("mouseup", function (i) { t.mouse_button = i.buttons, e(t, "mouseup", t.mouse_x, t.mouse_y, i) }), t.addEventListener("mousemove", function (i) { t.bound_rect = t.bound_rect || t.getBoundingClientRect(), t.mouse_x = i.clientX - t.bound_rect.left, t.mouse_y = i.clientY - t.bound_rect.top, t.mouse_button = i.buttons, e(t, "mousemove", t.mouse_x, t.mouse_y, i) }) }, i.event = i.define(function (t) { return t.add = function (t, e) { e = e || this.owner, this.handlers[this.handlers.length] = [t, e] }, t.trigger = function (t) { for (var e = 0; e < this.handlers.length; e++)if (!1 === this.handlers[e][0].apply(this.handlers[e][1], t)) return !1 }, t.trigger_params = function () { for (var t = 0; t < this.handlers.length; t++)if (!1 === this.handlers[t][0].apply(this.handlers[t][1], this.params)) return !1 }, function (t, e) { this.owner = t, this.handlers = [], this.params = e } }), i.flags_setting = i.define(function (t) { return i.set_flag = function (t, e) { return t & e || (t |= e), t }, i.unset_flag = function (t, e) { return 0 != (t & e) && (t &= ~e), t }, t.set_flag = function (t) { return this.flags & t || (this.flags |= t), this }, t.unset_flag = function (t) { return 0 != (this.flags & t) && (this.flags &= ~t), this }, function () { this.flags = 0 } }), i.bulk_image_loader = i.define(function (e) { return e.load = function (t, e) { var i = this.pool.get(); null !== i ? (i.params = e, i.manager = this, i.src = t) : this.park.enqueue([t, e]) }, e.check_park = function () { this.park.size() > 0 && this.load.apply(this, this.park.dequeue()) }, e.free = function (t) { this.pool.free(t), t.params = void 0, t.manager = void 0, t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=", this.check_park() }, function (e) { return this.park = new t.queue, this.pool = new t.object_pooler(function () { if (this.allocated <= this.max_size) { var t = new Image; return t.crossOrigin = "Anonymous", t.onload = function () { this.manager && (this.manager.onload(this, this.params), this.manager.auto_free && this.manager.free(this)) }, t } return this.allocated--, null }), this.pool.max_size = e, this.auto_free = !0, this } }), i.load_working_image = (l = new t.queue, u = new Image, u.crossOrigin = "Anonymous", u.is_busy = !1, function t(e, i) { u.is_busy ? l.enqueue([e, i]) : (u.onload = function () { i && i(this), this.is_busy = !1, l.size() > 0 && t.apply(this, l.dequeue()) }, u.is_busy = !0, u.src = e) }), i.load_working_image_data = function () { var e = new t.queue, r = new Image; r.crossOrigin = "Anonymous", r.is_busy = !1; var n = i.create_canvas(1, 1); return function t(i, s, a, o) { r.is_busy ? e.enqueue([i, s, a, o]) : (r.onload = function () { n.set_size(a || this.width, o || this.height), n.ctx.drawImage(this, 0, 0, n.width, n.height), s && s(n._get_image_data().data, n.width, n.height, this), n._put_image_data(), this.is_busy = !1, e.size() > 0 && t.apply(this, e.dequeue()) }, r.is_busy = !0, r.src = i) } }(), i.array = i.define(function (t) { t.push = function (t) { return this.data[this.length++] = t, this }; var e = 0; return t.push_args = function () { for (e = 0; e < arguments.length; e++)this.data[this.length++] = arguments[e] }, t.append_other = function (t) { for (e = 0; e < t.length; e++)this.data[this.length++] = t.data[e] }, t.peek = function () { return this.data[this.length - 1] }, t.pop = function () { return 0 === this.length ? null : this.data[--this.length] }, t.clear = function () { this.length = 0 }, t.for_each = function (t, e) { for (this.index = 0; this.index < this.length;)t(this.data[this.index], this.index++, e); this.index = 0 }, t.next = function () { return this.index < this.length ? this.data[this.index++] : null }, t.float32Array = function () { var t = new Float32Array(this.length); for (e = 0; e < this.length; e++)t[e] = this.data[e]; return t }, function () { this.data = [], this.length = 0, this.index = 0 } }), i.worker = function (t, e) { return new Worker(window.URL.createObjectURL(new Blob([(e || []).join(";") + ";self.main=" + t.toString() + ";self.main(self);"]))) }, i.worker_processor = i.define(function (e) { return e.add_job = function (e, i, r) { var n = this.job_id++, s = i.toString(), a = t.parse_args_from_func(s); if (r) { var o = r.toString(), _ = t.parse_args_from_func(o).join(","); s = function () { return function (t, e) { func_body() } }.toString().replace(/job_id/g, n).replace(/func_arguments/g, a.join(",")).replace(/respone_arguments/g, _).replace("func_body()", s.replace(/^function.*\(.*\)\s*\{|\}$/g, "")), this.jobs.push("self[" + n + "]=(" + s + ")()"), this.callbacks[n] = new Function("return " + function (t, e) { func_body() }.toString().replace(/respone_arguments/g, _).replace("func_body()", o.replace(/^function.*\(.*\)\s*\{|\}$/g, "")))() } else s = function (t, e) { func_body() }.toString().replace(/job_id/g, n).replace(/func_arguments/g, a.join(",")).replace("func_body()", s.replace(/^function.*\(.*\)\s*\{|\}$/g, "")), this.jobs.push("\nself[" + n + "]=" + s); this.jobs_func.push({ name: e, func: new Function("return " + function (t) { this.postMessage([job_id, t]) }.toString().replace(/job_id/g, n).replace(/func_arguments/g, a.join(",")))() }) }, e.data_processor = function (e, r, n) { var s = this.data_processor_id++, a = r.toString(), o = n.toString(), _ = t.parse_args_from_func(o).join(","), l = t.parse_args_from_func(a); a = function () { return function (t, e, i) { func_body() } }.toString().replace(/job_id/g, s).replace(/func_arguments/g, l.join(",")).replace(/respone_arguments/g, _).replace("func_body()", a.replace(/^function.*\(.*\)\s*\{|\}$/g, "")), this.jobs.push("self[" + s + "]=(" + a + ")()"); var u = this.DP; this.data_processors.push({ name: e, creator: i.define(function (i) { return i.params = new Array(l.length + 2), i.DP = u, i.parking = new t.queue, i.release = function (t, e) { this.DP.release(t, e), this.parking.size() > 0 && this.func.apply(this, this.parking.dequeue()) }, i.call = new Function("return " + function (t) { this._func_name.func(t) }.toString().replace(/func_arguments/g, l.join(",")).replace(/func_name/g, e))(), i.func = new Function("return " + function (t) { var e = this.DP.free_index(); e > -1 ? (data_buffer = this.DP.buffers[e], this.worker.postMessage([job_id, e, t], [data_buffer])) : this.parking.enqueue([t]) }.toString().replace(/func_arguments/g, l.join(",")).replace(/job_id/g, s))(), function (t) { this.worker = t } }) }), this.callbacks[s] = new Function("return " + function (t, e, i) { func_body(), this._func_name.release(e, data_buffer) }.toString().replace(/respone_arguments/g, _).replace(/func_name/g, e).replace("func_body()", o.replace(/^function.*\(.*\)\s*\{|\}$/g, "")))() }, e.build_worker = function (t) { var e = this.globals.join("\n") + this.jobs.join("\n"), i = new Worker(window.URL.createObjectURL(new Blob([e]))); for (var r in console.log(e), this.callbacks) i[r] = this.callbacks[r]; return i.host = t, this.data_processors.forEach(function (t) { i["_" + t.name] = new t.creator(i), i[t.name] = i["_" + t.name].call }), this.jobs_func.forEach(function (t) { i[t.name] = t.func }), i.onmessage = function (t) { this[t.data[0]].apply(this, t.data) }, i }, e.add_global = function (t) { this.globals.push(t.toString().replace(/^function.*\(.*\)\s*\{|\}$/g, "").trim()) }, function () { this.globals = [], this.data_processors = [], this.jobs = [], this.jobs_func = [], this.callbacks = {}, this.job_id = 100, this.data_processor_id = 1e4; var t = 0; this.DP = { buffers: [new ArrayBuffer(1), new ArrayBuffer(1), new ArrayBuffer(1)], free_index: function () { for (t = 0; t < this.buffers.length;) { if (this.buffers[t].byteLength > 0) return t; t++ } return -1 }, release: function (t, e) { this.buffers[t] = e } }, this.add_global(function () { self.onmessage = function (t) { this[t.data[0]].apply(this, t.data) } }) } }), i.renderable = i.define(function (t, e) { return t.expand_bounds = function (t, e, i) { this.bounds[0] = Math.min(this.bounds[0], t), this.bounds[1] = Math.min(this.bounds[1], e), this.bounds[2] = Math.min(this.bounds[2], i), this.bounds[3] = Math.max(this.bounds[3], t), this.bounds[4] = Math.max(this.bounds[4], e), this.bounds[5] = Math.max(this.bounds[5], i) }, t.initialize_item = function () { }, t.update_bounds = function (t) { }, t.update_world_transform = function (t, e, i) { r.mat4.from_quat(this.matrix_world, i), r.mat4.scale(this.matrix_world, e), this.matrix_world[12] = t[0], this.matrix_world[13] = t[1], this.matrix_world[14] = t[2] }, function (t) { this.matrix_world = r.mat4(), this.world_position = new Float32Array(this.matrix_world.buffer, 48, 3), this.view_position = r.vec3(), this.fw_vector = new Float32Array(this.matrix_world.buffer, 32, 3), this.bounds = r.aabb(), this.item_type = 1024, this.flags = 0, this.require_update = 0 } }), i.utils = {}, i.utils.timers = (n = [], s = 0, a = null, o = 0, _ = new t.object_pooler(function () { return n.push({}), n[n.length - 1] }), function t() { for (o = Date.now(), s = 0; s < n.length; s++)(a = n[s]).cb && o - a.last_time > a.interval && (a.last_time = o, a.cb(o - a.begin_time, o)); setTimeout(t, 100) }(), { create: function (t, e) { e = e || 1e3; var i = _.get(); return i.cb = t, i.interval = e, i.last_time = Date.now() - e, i.begin_time = i.last_time + e, i }, release: function (t) { t.cb = void 0, _.free(t) } }), i.utils.canvas_data_url = function () { var t = new i.create_canvas(1, 1); function e(e, i, r) { return t.set_size(e, i), r(t, t.ctx) } return e.box = function (e, i, r) { return t.set_size(e, i), t.ctx.fillStyle = r, t.ctx.fillRect(0, 0, e, i), t.toDataURL("image/png") }, e }(), i.app = i.define(function (e, r) { return e.create_renderable = function (t, e) { var i = this.create_entity({ components: { ge_transform: {}, ge_renderable: { items: [t] } } }); return t.entity_id = i.uuid, e(i.ge_renderable.items[0], i), i }, e.create_renderables = function (t, e) { var i = this.create_entity({ components: { ge_transform: {}, ge_renderable: { items: t } } }); return e && i.ge_renderable.items.forEach(function (t, r) { t.entity_id = i.uuid, e(t, i) }), i }, e.start = function (t) { return function (e, i) { var r = this; t.apply(this, [function () { this.on_frame.trigger(), e(), r.timer - r.last_debug_timer > .2 && (r.last_debug_timer = r.timer, r.display_debug(r.debug_ctx)) }, i]) } }(e.start), e.display_debug = function (t) { t.clearRect(0, 0, this.debug_canvas.width, this.debug_canvas.height), t.fillStyle = "#ffffff", t.fillText(this.render_system.fps + " FPS", 2, 10); for (var e = 0; e < this._systems.length; e++)t.fillText(this._systems[e].name_id + " " + this._systems[e].frame_time + " ms ", 1, 10 * e + 25) }, function (e) { e = e || {}, r.apply(this, arguments), e.host = e.host || (document.body.style.height = "100vh", document.body.style.width = "100%", document.body.style.padding = "0", document.body.style.margin = "0", document.body.style.overflow = "hidden", document.body), this.use_system("ge_render_system", { host: e.host, renderer: e.renderer }), this.root = this.create_entity({ components: { ge_transform: {}, ge_renderable: { items: [] } } }), this.on_frame = new i.event(this), this.last_debug_timer = 0, this.debug_canvas = i.create_canvas(1, 1), this.debug_canvas.setAttribute("style", "position:absolute;width:100%;height:100%;left:0;top:0;box-sizing: border-box;pointer-events: none;"), this.debug_ctx = this.debug_canvas.ctx, this.render_system = this.systems.ge_render_system, this.render_system.host.appendChild(this.debug_canvas); var n = this; this.all_timers = [], this.timers = new t.object_pooler(function () { var t = { cb: void 0, interval: 0, created: 0, lastClock: 0 }; return this.all_timers.push(t), t }), this.render_system.renderer.on_canvas_size = function (t, e) { n.debug_canvas.set_size(.5 * t, .5 * e) } } }, e.app); var n, s, a, o, _; var l, u }(_FM.fin, _FM.ecs, _FM.ge, _FM.math), function (t, e) { e.webgl = {}, e.webgl.texture = e.define(function (i) { function r(e, i, r, n, s, a, o) { this.uuid = t.guidi(), this.gl_texture = null, this.needs_update = !1, void 0 === n ? (this.source = new Uint8Array([255, 255, 255, 255]), this.needs_update = !0) : this.source = n, this.width = a || 1, this.height = o || 1, this.last_used_time = 0, this.format = i || 6408, this.format_type = r || 5121, this.target = e || 3553, this.parameters = {}, this.generate_mipmap = s || !1, this.parameters[10242] = 10497, this.parameters[10243] = 10497, this.generate_mipmap ? (this.parameters[10240] = 9729, this.parameters[10241] = 9987) : (this.parameters[10240] = 9728, this.parameters[10241] = 9728), this.source && null !== this.source && (this.needs_update = !0) } var n; return i.enable_linear_interpolation = function () { this.parameters[10240] = 9729, this.parameters[10241] = 9729 }, i.enable_nearest_interpolation = function () { this.parameters[10240] = 9728, this.parameters[10241] = 9728 }, i.enable_clamp_to_edge = function () { this.parameters[10242] = 33071, this.parameters[10243] = 33071 }, r.load_images = new e.bulk_image_loader(20), r.load_images.auto_free = !1, console.log(r.load_images), r.load_images.onload = (n = e.create_canvas(1, 1), function (t, e) { e.fit_size ? (n.set_size(e.fit_size, e.fit_size), n.ctx.drawImage(t, 0, 0, e.fit_size, e.fit_size), e.source = n._get_image_data().data, e.width = e.fit_size, e.height = e.fit_size, r.load_images.free(t)) : (e.source = t, e.width = t.width, e.height = t.height), e.needs_update = !0 }), i.free_source = function () { null !== this.source && (this.source.src && r.load_images.free(this.source), this.source = null) }, r.update_from_url = function (t, e) { return r.load_images.load(e, t), t }, r.from_url = function (t, i, n) { var s = new e.webgl.texture(void 0, void 0, void 0, null, i); return s.fit_size = n, r.load_images.load(t, s), s }, r.from_size = function (t, i) { return new e.webgl.texture(!1, !1, !1, null, !1, t, i) }, r.create_tiled_texture = function () { var i = e.create_canvas(1, 1); i.is_busy = !1; var n = e.create_canvas(1, 1), s = 0, a = 0, o = 0, _ = 0, l = null, u = []; function h(r, o, _, l, c) { if ((c = c || new e.webgl.texture(!1, !1, !1, null, !0, _, l)).tile_size = o, i.is_busy) return u.push([r, o, _, l, c]), c; i.is_busy = !0, i.set_size(_, l), n.set_size(o, o); var d = o / 2; return c.tile_offset = o / 4, c.tile_offsetf = c.tile_offset / _, c.tile_sizef = o / _, s = 0, a = 0, t.each_index(function (t, l) { e.load_working_image(r[t], function (m) { n.ctx.drawImage(m, 0, 0, d, d), n.ctx.drawImage(m, d, 0, d, d), n.ctx.drawImage(m, 0, d, d, d), n.ctx.drawImage(m, d, d, d, d), i.ctx.drawImage(n, s, a, o, o), s + o < _ ? s += o : (s = 0, a += o), t < r.length - 1 ? l(t + 1) : (c.source = i._get_image_data().data, c.needs_update = !0, i.is_busy = !1, u.length > 0 && h.apply(e.webgl.texture, u.shift())) }, o, o) }, 0), c } return n.ctx.imageSmoothingEnabled = !1, i.ctx.imageSmoothingEnabled = !1, r.create_texture_atlas = function (r, n) { return n = n || new e.webgl.texture(!1, !1, !1, null, !0, r.width, r.height), i.is_busy ? (u.push([r, n]), n) : (i.is_busy = !0, i.set_size(r.width, r.height), t.each_index(function (t, c) { l = r.inputs[t], e.load_working_image(l.src, function (d) { if (l.tiles_in_row && (l.tile_size = d.width / l.tiles_in_row, l.tile_width = l.tile_size, l.tile_height = l.tile_size), o = 0, _ = 0, l.rotation_sprites) { i.ctx.strokeStyle = "green"; for (var m = 6.283185 / l.rotation_sprites, p = 0; p <= 6.283185;)i.ctx.save(), i.ctx.translate(l.dest_x + o + .5 * l.dest_size, l.dest_y + _ + .5 * l.dest_size), i.ctx.rotate(p), i.ctx.drawImage(d, .5 * -l.dest_size, .5 * -l.dest_size, l.dest_size, l.dest_size), i.ctx.restore(), o += l.dest_size, p += m } else for (a = 0; a < d.height; a += l.tile_height)for (s = 0; s < d.width; s += l.tile_width)i.ctx.drawImage(d, s, a, l.tile_width, l.tile_height, l.dest_x + o, l.dest_y + _, l.dest_size, l.dest_size), o += l.dest_size, l.dest_per_row && o / l.dest_size >= l.dest_per_row && (o = 0, _ += l.dest_size); t < r.inputs.length - 1 ? c(t + 1) : (n.source = i._get_image_data().data, n.needs_update = !0, i.is_busy = !1, document.getElementById("test_texture_atlas") && (document.getElementById("test_texture_atlas").src = i.toDataURL("")), u.length > 0 && h.apply(e.webgl.texture, u.shift())) }) }, 0), n) }, h }(), r.pooler = t.define(function (i) { i.get = function (t) { return this.pool.get(t) }, i.free = function (t) { t.valid_id = -100, t.free_source(), this.pool.free(t) }, i.valid_texture = function (t, e) { return !(!t || !e) && t.valid_id === e }; var r, n = 0; return i.tick = function (t) { if (t - this.last_gc_time > this.gc_check_time) for (this.last_gc_time = t, n = 0; n < this.textures.length; n++)(r = this.textures[n]).valid_id > 0 && t - r.last_used_time > this.gc_time && this.free(r) }, i.create_texture = function (t) { return e.webgl.texture.from_url(t, !0) }, i.update_texture = function (t, i) { return e.webgl.texture.update_from_url(t, i) }, function (e) { e = e || {}, this.last_gc_time = 0, this.gc_check_time = e.gc_check_time || 5, this.gc_time = e.gc_time || 3; var i = this; this.textures = [], this.pool = new t.object_pooler(function (e) { var r = i.create_texture(e); return r.valid_id = t.guidi(), i.textures[i.textures.length] = r, r }, function (e, r) { return e.valid_id = t.guidi(), i.update_texture(e, r) }, e.pool_size) } }), r }), e.webgl.texture.dummy = new e.webgl.texture, e.webgl.canvas_texture = e.define(function (t, e) { return t.update = function () { this.source = this.canvas, this.needs_update = !0 }, function (t, i, r, n, s) { e.apply(this, [r, n, s, null, !1, t, i]), this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), this.parameters[10242] = 33071, this.parameters[10243] = 33071, this.source = this.canvas, this.canvas.width = this.width, this.canvas.height = this.height, this.ctx.transform(1, 0, 0, -1, 0, this.canvas.height), this.needs_update = !0 } }, e.webgl.texture), e.webgl.render_target = e.define(function (i) { return i.resize = function (t, e) { this.width = t, this.height = e, this.color_texture && (this.color_texture.width = t, this.color_texture.height = e, this.renderer.update_texture(this.color_texture)), this.depth_texture && (this.depth_texture.width = t, this.depth_texture.height = e, this.renderer.update_texture(this.depth_texture)), this.owned_depth_buffer && this.depth_buffer && (this.renderer.gl.bindRenderbuffer(36161, this.depth_buffer), this.renderer.gl.renderbufferStorage(36161, 33189, t, e)), this.vp_bottom = e, this.vp_right = t }, i.set_viewport_per = function (t, e, i, r) { return this.vp_left = this.width * t, this.vp_top = this.height * e, this.vp_right = this.width * i, this.vp_bottom = this.height * r, this }, i.set_viewport = function (t, e, i, r) { this.vp_left = t, this.vp_top = e, this.vp_right = i, this.vp_bottom = r }, i.set_default_viewport = function () { return this.set_viewport_per(0, 0, 1, 1), this }, i.bind = function (t) { return !(this.renderer.render_target_id === this.uuid && !t || (this.renderer.gl.bindFramebuffer(36160, this.frame_buffer), this.apply_viewport(), this.renderer.render_target_id = this.uuid, this.clear_buffer && this.renderer.gl.clear(16640), 0)) }, i.apply_viewport = function () { return this.renderer.gl.viewport(this.vp_left, this.vp_top, this.vp_right - this.vp_left, this.vp_bottom - this.vp_top), this }, i.bind_only = function () { return this.renderer.render_target_id === this.uuid ? this : (this.renderer.render_target_id = this.uuid, this.renderer.gl_bindFramebuffer(36160, this.frame_buffer), this.renderer.gl.viewport(this.vp_left, this.vp_top, this.vp_right - this.vp_left, this.vp_bottom - this.vp_top), this) }, i.unbind = function () { this.renderer.render_target_id = -1, this.renderer.gl_bindFramebuffer(36160, null) }, i.attach_color = function () { return this.color_texture = new e.webgl.texture(void 0, void 0, void 0, null, !1, this.width, this.height), this.bind_texture(this.color_texture, 36064), this.color_texture.parameters[10242] = 33071, this.color_texture.parameters[10243] = 33071, this.renderer.update_texture(this.color_texture), this }, i.attach_depth = function () { return this.depth_texture = this.bind_texture(new e.webgl.texture(void 0, 6402, 5123, null, !1, this.width, this.height), 36096), this.depth_texture.parameters[10242] = 33071, this.depth_texture.parameters[10243] = 33071, this }, i.check_status = function () { this.valid = !1; var t = this.renderer.gl.checkFramebufferStatus(36160); switch (t) { case 36053: this.valid = !0; break; case 36054: throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT"; case 36055: throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"; case 36057: throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS"; case 36061: throw "Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED"; default: throw "Incomplete framebuffer: " + t } }, i.attach_depth_buffer = function (t) { return t ? (this.depth_buffer = t, this.owned_depth_buffer = !1) : (this.owned_depth_buffer = !0, this.depth_buffer = this.renderer.gl.createRenderbuffer(), this.renderer.gl.bindRenderbuffer(36161, this.depth_buffer), this.renderer.gl.renderbufferStorage(36161, 33189, this.width, this.height)), this.renderer.gl.bindFramebuffer(36160, this.frame_buffer), this.renderer.gl.framebufferRenderbuffer(36160, 36096, 36161, this.depth_buffer), this.check_status(), this.renderer.gl.bindFramebuffer(36160, null), this.renderer.gl.bindRenderbuffer(36161, null), this }, i.bind_texture = function (t, e) { return this.renderer.gl.bindFramebuffer(36160, this.frame_buffer), null === t.gl_texture && this.renderer.update_texture(t), this.renderer.gl.bindTexture(t.target, t.gl_texture), t.generate_mipmap && this.renderer.gl.generateMipmap(t.target), this.renderer.gl.framebufferTexture2D(36160, e, t.target, t.gl_texture, 0), this.check_status(), this.renderer.gl.bindTexture(t.target, null), this.renderer.gl.bindFramebuffer(36160, null), t }, function (e, i, r) { return this.uuid = t.guidi(), this.renderer = e, this.frame_buffer = e.gl.createFramebuffer(), this.vp_left = 0, this.vp_top = 0, this.width = i, this.height = r, this.vp_bottom = r, this.vp_right = i, this.clear_buffer = !0, this.owned_depth_buffer = !1, this.set_default_viewport(), this.ratio = 1, this } }), e.webgl.shader = e.define(function (i) { function r(e, i) { return this.vs = e, this.fs = i, this.compiled = !1, this.uuid = t.guidi(), this.params = {}, this.parent = null, this.parts = null, this } return i.collect_parts = function (t, e) { null !== this.parent && this.parent.collect_parts(t, e), this.parts.vertex && t.push(this.parts.vertex), this.parts.fragment && e.push(this.parts.fragment) }, i.extend = function (t, i) { return e.webgl.shader.parse_shader(t, this, i) }, i.set_uniform = function (t, e) { var i = this.uniforms[t]; return !!i && (i.params[i.params_length] = e, i.func.apply(this.gl, i.params), !0) }, i.enter = function (t) { }, i.exit = function (t) { }, t.macro(function (t, e) { uni = r.uniforms[t], uni && (uni.params[uni.params_length] = e, uni.func.apply(r.gl, uni.params)) }, e), t.macro(function (t, e) { uni = r.uniforms[t], uni.params[uni.params_length] = e, uni.func.apply(r.gl, uni.params) }, e), r.chunks = {}, r.load_chunks = function (t) { t.split("/*chunk-").forEach(function (t) { if ((t = t.trim()).length > 0) { var e = t.substr(0, t.indexOf("*/") + 2); t = t.replace(e, ""), e = e.replace("*/", ""), r.chunks[e] = t } }) }, r.create_chunks_lib = function (t) { var e, i = {}; return t.split("/*chunk-").forEach(function (t) { (t = t.trim()).length > 0 && (e = t.substr(0, t.indexOf("*/") + 2), t = t.replace(e, ""), 0 === (e = e.replace("*/", "")).indexOf("global-") && (r.chunks[e] = t), i[e] = t) }), i }, r.load_chunks("/*chunk-precision*/ \n#extension GL_OES_standard_derivatives : enable\n#if GL_FRAGMENT_PRECISION_HIGH == 1\n    precision highp float;\n#else\nprecision mediump float;\n#endif\n\nconst float DEGTORAD=0.017453292519943295;\nconst float RADTODEG=57.295779513082323;\n\n\n\n\n\n\n/*chunk-shadow-sampling*/\n\nfloat sample_shadow_map(sampler2D shadowMap, vec2 coords, float compare)\n{\n\treturn step(compare, texture2D(shadowMap, coords.xy).r);\n}\n\nfloat sample_shadow_map_linear(sampler2D shadowMap, vec2 coords, float compare, vec2 texelSize)\n{\n\tvec2 pixelPos = coords / texelSize + vec2(0.5);\n\tvec2 fracPart = fract(pixelPos);\n\tvec2 startTexel = (pixelPos - fracPart) * texelSize;\n\n\tfloat blTexel = sample_shadow_map(shadowMap, startTexel, compare);\n\tfloat brTexel = sample_shadow_map(shadowMap, startTexel + vec2(texelSize.x, 0.0), compare);\n\tfloat tlTexel = sample_shadow_map(shadowMap, startTexel + vec2(0.0, texelSize.y), compare);\n\tfloat trTexel = sample_shadow_map(shadowMap, startTexel + texelSize, compare);\n\n\tfloat mixA = mix(blTexel, tlTexel, fracPart.y);\n\tfloat mixB = mix(brTexel, trTexel, fracPart.y);\n\n\treturn mix(mixA, mixB, fracPart.x);\n}\n\nfloat sample_shadow_map_pcf(sampler2D shadowMap, vec2 coords, float compare, vec2 texelSize)\n{\n\tconst float NUM_SAMPLES = 3.0;\n\tconst float SAMPLES_START = (NUM_SAMPLES - 1.0) / 2.0;\n\tconst float NUM_SAMPLES_SQUARED = NUM_SAMPLES * NUM_SAMPLES;\n\n\tfloat result = 0.0;\n\tfor (float y = -SAMPLES_START; y <= SAMPLES_START; y += 1.0)\n\t{\n\t\tfor (float x = -SAMPLES_START; x <= SAMPLES_START; x += 1.0)\n\t\t{\n\t\t\tvec2 coordsOffset = vec2(x, y) * texelSize;\n\t\t\tresult += sample_shadow_map_linear(shadowMap, coords + coordsOffset, compare, texelSize);\n\t\t}\n\t}\n\treturn result / NUM_SAMPLES_SQUARED;\n}\n\n\n/*chunk-timer*/\nuniform float u_timer_rw;\n\n\n/*chunk-random*/\nfloat random(vec3 seed, int i){\n\tvec4 seed4 = vec4(seed,i);\n\tfloat dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));\n\treturn fract(sin(dot_product) * 43758.5453);\n}\n\n\n\n/*chunk-debug_aabbs*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nattribute vec3 a_box_position_rw;\nattribute vec3 a_box_size_rw;\nattribute vec3 a_box_color_rw;\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\nvarying vec3 v_box_color_rw;\nvoid vertex(){\n    vec4 pos;\n    pos.xyz=a_position_rw*a_box_size_rw;    \n    pos.xyz+=a_box_position_rw;\n    pos.w=1.0;    \n    v_box_color_rw=a_box_color_rw;\n    gl_Position = u_view_projection_rw*u_model_rw*pos;\t\n    gl_PointSize =5.0;\n\n}\n<?=chunk('precision')?>\nvarying vec3 v_box_color_rw;\nvoid fragment(void) {\t\ngl_FragColor=vec4(v_box_color_rw,1.0);\n}\n\n\n\n\n\n/*chunk-quat-dquat*/\n\nvec3 quat_transform(vec4 q, vec3 v)\n{\n   return (v + cross(2.0 * q.xyz, cross(q.xyz, v) + q.w * v));\n}\n\n/*chunk-mat3-transpose*/\nmat3 transpose(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}"), r.context_param, r.$str = function (t, i) { return e.str(t, "chunk", "param")(i ? e.webgl.shader.nested_get_chunk : e.webgl.shader.get_chunk, e.webgl.shader.get_param) }, r.nested_get_chunk = function (t) { return e.webgl.shader.$str(e.webgl.shader.chunks[t], !0) }, r.get_chunk = function (t) { return e.webgl.shader.chunks[t] }, r.get_param = function (t) { return e.webgl.shader.context_param && void 0 !== e.webgl.shader.context_param[t] ? e.webgl.shader.context_param[t] : "" }, r.compile = function () { function t(t, e, i) { var r = t.createShader(i); t.shaderSource(r, e); var n = t.getShaderSource(r); return t.compileShader(r), t.getShaderParameter(r, 35713) ? r : (console.log("source", n), console.error("Error compiling shader : ", t.getShaderInfoLog(r)), console.log(e), t.deleteShader(r), null) } var i = function () { var t = { 5126: ["uniform1f", 2], 35664: ["uniform2fv", 2], 35665: ["uniform3fv", 2], 35666: ["uniform4fv", 2], 35678: ["uniform1i", 2], 35680: ["uniform1i", 2], 35675: ["uniformMatrix3fv", 3], 35676: ["uniformMatrix4fv", 3], float: 5126, vec2: 35664, vec3: 35665, vec4: 35666 }; function e(e, i, r, n) { var s = e.getUniformLocation(i.program, r), a = t[n], o = {}; 3 === a[1] ? o.params = [s, !1, 0] : 2 === a[1] && (o.params = [s, 0]), o.func = e[a[0]], o.params_length = o.params.length - 1, i.uniforms[r] = o } return function (t, i) { var r, n = 0, s = 0; for (i.uniforms = {}, n = 0; n < t.getProgramParameter(i.program, 35718); n++)if ((r = t.getActiveUniform(i.program, n)).size > 1) for (s = 0; s < r.size; s++)e(t, i, r.name.replace("[0]", "[" + s + "]"), r.type); else 1 === r.size && e(t, i, r.name, r.type); for (i.attributes = {}, i.all_attributes = [], n = 0; n < t.getProgramParameter(i.program, 35721); n++)r = t.getActiveAttrib(i.program, n), i.attributes[r.name] = { name: r.name, location: t.getAttribLocation(i.program, r.name) }, i.all_attributes.push(i.attributes[r.name]) } }(); return function (r, n, s) { var a, o; if (!n.compiled) return e.webgl.shader.context_param = {}, Object.assign(e.webgl.shader.context_param, s), Object.assign(e.webgl.shader.context_param, n.params), n.vs = e.webgl.shader.$str(n.vs, !0), n.fs = e.webgl.shader.$str(n.fs, !0), n.gl = r, !!(a = t(r, n.vs, 35633)) && ((o = t(r, n.fs, 35632)) ? (n.program = function (t, e, i, r) { var n = t.createProgram(); return t.attachShader(n, e), t.attachShader(n, i), t.linkProgram(n), t.getProgramParameter(n, 35714) ? r && (t.validateProgram(n), !t.getProgramParameter(n, 35715)) ? (console.error("Error validating program", t.getProgramInfoLog(n)), t.deleteProgram(n), null) : (t.detachShader(n, e), t.detachShader(n, i), t.deleteShader(i), t.deleteShader(e), n) : (console.error("Error creating shader program.", t.getProgramInfoLog(n)), t.deleteProgram(n), null) }(r, a, o, !0), r.useProgram(n.program), i(r, n), r.useProgram(null), n.compiled = !0, !0) : (r.deleteShader(a), !1)) } }(), r.parse_flat = function (t, i) { var r = t.split("/*--fragment--*/"), n = new e.webgl.shader(r[0].toString().trim(), r[1].toString().trim()); return n.source = t, n.params = i || {}, n }, r.parse_shader = function () { var t = ["vertex", "fragment"]; function i(e) { e = e.replace(/\\n/g, "\n"); var i = []; t.forEach(function (t) { i.push({ f: t, i: e.indexOf(t) }) }), i.sort(function (t, e) { return t.i - e.i }); var r = e.split(""); function n(t, i) { return e.substr(i, function (t) { for (var e = 1; 0 !== e && t < r.length;)"{" === r[t] ? e++ : "}" === r[t] && e--, t++; return t }(e.indexOf(t) + t.length) - i) } var s = 0, a = {}; return i.forEach(function (t) { var i = new RegExp("void " + t.f + "[\\s\\S]*?{", "ig"), r = e.match(i); null !== r && r.length > 0 && (a[t.f] = n(r[0], s), s += a[t.f].length) }), a } function r(t) { var e = {}, i = "", r = null; return function (t, e) { null !== t && t.forEach(e) }(t.match(/(\w+ +\w+ *\([^\)]*\) *\{)|(\w+ +\w+ +\w+ *\([^\)]*\) *\{)/g), function (t) { i = t.replace(/\s+/g, " ").substr(0, t.indexOf("(")).trim(), (r = { a: i.split(" "), d: t }).f = r.a[r.a.length - 1], e[i] = r }), e } return function (t, n, s) { s = s || {}; var a, o, _, l, u = new e.webgl.shader, h = null, c = "", d = "", m = null, p = "", f = ""; for (h in u.parts = i(t), u.level = 0, u.parts) u.parts[h] = u.parts[h].replace(/\r?\n\s+\{|\r\s+\{/g, "{").replace(/\s+\(/g, "("); if (n) { for (h in u.level = n.level + 1, u.parts) if (!1 !== s[h] && (c = u.parts[h], d = n.parts[h])) { for (m in a = r(c), o = r(d), a) o[m] && (_ = a[m], l = o[m], p = "super_" + _.f, u.level > 1 ? (f = m.replace(_.f, p), d = (d = d.replace(f + "(", f + u.level + "(")).replace(p + "(", p + u.level + "("), p = l.d.replace(l.f, "super_" + l.f), d = d.replace(l.d, p)) : (p = l.d.replace(l.f, "super_" + l.f), d = d.replace(l.d, p))); u.parts[h] = d + c } u.parts.vertex = u.parts.vertex || n.parts.vertex, u.parts.fragment = u.parts.fragment || n.parts.fragment } return u.vs = u.parts.vertex + "void main(){vertex();}", u.fs = u.parts.fragment + "void main(){fragment();}", u.parent = n || null, u } }(), r.parse = function (t) { return this.parse_shader(t, void 0, !0, !0) }, r }) }(_FM.fin, _FM.ge), function (t, e) { var i; t.shading = {}, i = t.webgl.shader.create_chunks_lib("/*chunk-flat-material*/\n\n<?=chunk('precision')?>\n\nattribute vec3 a_position_rw;\nattribute vec2 a_uv_rw;\nattribute vec4 a_color_rw;\nuniform mat4 u_view_projection_rw;\nuniform mat3 u_texture_matrix_rw;\nuniform mat4 u_model_rw;\nvarying vec2 v_uv_rw;\nvarying vec4 v_color_rw;\nvarying vec4 v_position_rw;\nvec4 att_position(void);\nvec3 att_uv(void);\n\nvec4 att_position(void){\n    return vec4(a_position_rw,1.0);\n}\nvec3 att_uv(void){\n    return vec3(a_uv_rw,1.0);\n}\n\nvoid vertex(void){\n    v_position_rw=u_model_rw*att_position();\n    gl_Position=u_view_projection_rw*v_position_rw;\n    v_uv_rw=(u_texture_matrix_rw*att_uv()).xy;\n    v_color_rw=a_color_rw;\n    gl_PointSize =10.0;\n}\n<?=chunk('precision')?>\n\nvarying vec2 v_uv_rw;\nvarying vec4 v_position_rw;\nvarying vec4 v_color_rw;\nuniform mat4 u_object_material_rw;\nuniform sampler2D u_texture_rw;\nvoid fragment(void) {\t\n\n    gl_FragColor = texture2D(u_texture_rw, v_uv_rw)*v_color_rw ;\n    gl_FragColor.rgb*=u_object_material_rw[0].rgb;    \n\tgl_FragColor.w*=u_object_material_rw[0].w;    \n\t\n    \n\n}\n\n\n/*chunk-shaded-material*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nattribute vec3 a_normal_rw;\nattribute vec2 a_uv_rw;\nattribute vec4 a_color_rw;\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\nuniform mat3 u_texture_matrix_rw;\n\nvarying vec2 v_uv_rw;\nvarying vec4 v_position_rw;\nvarying vec3 v_normal_rw;\nvarying vec4 v_color_rw;\n\nvec4 att_position(void);\nvec4 att_normal(void);\nvec3 att_uv(void);\n\nvec4 att_position(void){\n    return vec4(a_position_rw,1.0);\n}\nvec4 att_normal(void){\n    return vec4(a_normal_rw,0.0);\n}\n\nvec3 att_uv(void){\n    return vec3(a_uv_rw,1.0);\n}\n\nvoid vertex(){\t\n\tv_position_rw=u_model_rw*att_position();\n    gl_Position=u_view_projection_rw*v_position_rw;\n\tv_normal_rw=(u_model_rw*att_normal()).xyz;\t\n\tv_uv_rw=(u_texture_matrix_rw*att_uv()).xy;\n\n\tv_color_rw=a_color_rw;\n\t\t\n}\n\n<?=chunk('precision')?>\n\n<?=chunk('global-render-system-lighting')?>\n\nvarying vec2 v_uv_rw;\nvarying vec4 v_position_rw;\nvarying vec3 v_normal_rw;\nvarying vec4 v_color_rw;\n\nuniform mat4 u_object_material_rw;\nuniform sampler2D u_texture_rw;\nuniform vec4 u_eye_position_rw;\n\nvoid fragment(void) {\n\t\n\tvec3 total_light=get_render_system_lighting(\n\tu_object_material_rw,\n\tv_position_rw.xyz,\n\tnormalize(v_normal_rw),\n\tnormalize(u_eye_position_rw.xyz - v_position_rw.xyz));\n\t\n\t\n\n\tgl_FragColor = vec4(total_light, u_object_material_rw[0].w)* \n\ttexture2D(u_texture_rw, v_uv_rw)*v_color_rw;\t\n\tgl_FragColor.w*=u_object_material_rw[0].w;\n\t\n}\n\n"), t.shading.material = t.define(function (r, n) { function s(i) { i = i || {}, n.apply(this, [i]), this.uuid = t.guidi(), this.object_material = new Float32Array(16), this.ambient = new Float32Array(this.object_material.buffer, 0, 4), this.diffuse = new Float32Array(this.object_material.buffer, 16, 4), this.specular = new Float32Array(this.object_material.buffer, 32, 4), this.texture = i.texture || null, e.vec3.copy(this.ambient, i.ambient || [.5, .5, .5]), e.vec3.copy(this.diffuse, i.diffuse || [.5, .5, .5]), e.vec3.copy(this.specular, i.specular || [.863, .863, .863]), this.ambient[3] = 1, this.texture_matrix = i.texture_matrix || e.mat3(), i.set_texture_matrix && e.mat3.translate_rotate_scale(this.texture_matrix, i.set_texture_matrix[0], i.set_texture_matrix[1], i.set_texture_matrix[2], i.set_texture_matrix[3], i.set_texture_matrix[4]), this.instances_count = -1, this.wireframe = i.wireframe || !1, this.flags = 2, void 0 !== i.flags && (this.flags += i.flags), this.shader = i.shader || t.shading.material.shader, this.draw_type = 4, void 0 !== i.draw_type && (this.draw_type = i.draw_type), i.always_display && (this.flags += 2), this.on_before_render = new t.event(this), this.on_after_render = new t.event(this), this.draw_elements = !1, this.transparent_layer = i.transparent_layer || 0, void 0 !== i.transparent && this.set_tansparency(i.transparent), this.cull_face = i.cull_face || 1029, i.both_sides && (this.flags += 2048) } var a; return s.shader = t.webgl.shader.parse(i["flat-material"]), r.set_tansparency = function (t) { return this.ambient[3] = Math.min(t, 1), t < 1 ? this.set_flag(128) : this.unset_flag(128), this }, r.set_shinness = function (t) { return this.specular[3] = t, this }, r.set_ambient = function (t, e, i) { return this.ambient[0] = t, this.ambient[1] = e, this.ambient[2] = i, this }, r.set_diffuse = function (t, e, i) { return this.diffuse[0] = t, this.diffuse[1] = e, this.diffuse[2] = i, this }, r.render_mesh = (a = [null, null, null], r.complete_render_mesh = function (t, e, i) { this.instances_count > -1 ? this.instances_count > 0 && (this.draw_elements ? t.gl.ANGLE_instanced_arrays.drawElementsInstancedANGLE(this.final_draw_type, this.final_draw_count, 5125, 4 * this.final_draw_offset, this.instances_count) : t.gl.ANGLE_instanced_arrays.drawArraysInstancedANGLE(this.final_draw_type, this.final_draw_offset, this.final_draw_count, this.instances_count)) : this.draw_elements ? t.gl.drawElements(this.final_draw_type, this.final_draw_count, 5125, 4 * this.final_draw_offset) : t.gl.drawArrays(this.final_draw_type, this.final_draw_offset, this.final_draw_count) }, function (t, e, i) { var r; a[0] = t, a[1] = e, a[2] = i, 1024 & this.flags ? t.gl_disable(2929) : t.gl_enable(2929), 0 != (2048 & this.flags) ? t.gl_disable(2884) : t.gl_enable(2884), (r = e.uniforms.u_object_material_rw) && (r.params[r.params_length] = this.object_material, r.func.apply(e.gl, r.params)), (r = e.uniforms.u_texture_matrix_rw) && (r.params[r.params_length] = this.texture_matrix, r.func.apply(e.gl, r.params)), t.use_texture(this.texture, 0), this.final_draw_type = this.wireframe ? 1 : this.draw_type, this.final_draw_count = i.draw_count || i.geometry.num_items, this.final_draw_offset = i.draw_offset || 0, this.draw_elements = t.activate_geometry_index_buffer(i.geometry, this.wireframe), this.wireframe && (this.final_draw_count *= 2, this.final_draw_offset *= 2), this.on_before_render.trigger(a), this.complete_render_mesh(t, e, i), this.on_after_render.trigger(a) }), s }, t.flags_setting), t.shading.shaded_material = t.define(function (e, r) { function n(e) { return e = e || {}, r.apply(this, [e]), this.shader = t.shading.shaded_material.shader, this.flags = 4, this.light_pass_limit = 1e4, this.lights_count = -1, this.set_shinness(e.shinness || 100), void 0 !== e.transparent && this.set_tansparency(e.transparent), e.cast_shadows && (this.flags += 16), e.receive_shadows && (this.flags += 32), void 0 !== e.flags && this.set_flag(e.flags), e.both_sides && (this.flags += 2048), this } return n.shader = t.webgl.shader.parse(i["shaded-material"]), n }, t.shading.material), t.shading.light = t.define(function (t, i) { return t.update_bounds = function (t, e) { if (this.light_type > -1) { var i = .5 * this.range, r = this.world_position; this.bounds[0] = r[0], this.bounds[1] = r[1], this.bounds[2] = r[2], this.bounds[3] = r[0], this.bounds[4] = r[1], this.bounds[5] = r[2], minx = r[0] - i, miny = r[1] - i, minz = r[2] - i, maxx = r[0] + i, maxy = r[1] + i, maxz = r[2] + i, this.expand_bounds(minx, miny, minz), this.expand_bounds(minx, miny, maxz), this.expand_bounds(minx, maxy, minz), this.expand_bounds(minx, maxy, maxz), this.expand_bounds(maxx, miny, minz), this.expand_bounds(maxx, miny, maxz), this.expand_bounds(maxx, maxy, minz), this.expand_bounds(maxx, maxy, maxz) } }, t.set_intensity = function (t) { return this.ambient[3] = t, this }, t.set_ambient = function (t, i, r) { return e.vec3.set(this.ambient, t, i, r), this }, t.set_diffuse = function (t, i, r) { return e.vec3.set(this.diffuse, t, i, r), this }, t.set_specular = function (t, i, r) { return e.vec3.set(this.specular, t, i, r), this }, t.enable_shadows = function (t) { return t = t || {}, this.cast_shadows = !0, this.shadow_bias = t.shadow_bias || 1e-8, this.shadow_intensity = t.shadow_intensity || this.shadow_intensity, this.shadow_map_size = t.shadow_map_size || 1024, this.shadow_camera_distance = t.shadow_camera_distance || 30, this }, function (t) { t = t || {}, i.apply(this, [t]), this.light_material = new Float32Array(16), this.ambient = new Float32Array(this.light_material.buffer, 0, 4), this.diffuse = new Float32Array(this.light_material.buffer, 16, 4), this.specular = new Float32Array(this.light_material.buffer, 32, 4), this.attenuation = new Float32Array(this.light_material.buffer, 48, 4), this.diffuse[3] = -1, this.specular[3] = -1, this.range = 2e4, this.light_type = 0, this.enabled = !0, this.item_type = 8, this.view_angle = Math.PI, this.flags = 2, this.version = 0, e.vec3.copy(this.ambient, t.ambient || [.1, .1, .1]), e.vec3.copy(this.diffuse, t.diffuse || [.87, .87, .87]), e.vec3.copy(this.specular, t.specular || [.85, .85, .85]), e.vec4.copy(this.attenuation, t.attenuation || [0, 0, 0, 0]), this.ambient[3] = t.intensity || 1, this.diffuse[3] = -1, this.specular[3] = -1, this.cast_shadows = t.cast_shadows || !1, this.shadow_bias = t.shadow_bias || 1e-8, this.shadow_intensity = t.shadow_intensity || .25, this.shadow_map_size = t.shadow_map_size || 1024, this.shadow_camera_distance = t.shadow_camera_distance || 30 } }, t.renderable), t.shading.point_light = t.define(function (t, i) { var r, n, s, a, o; return t.set_attenuation_by_distance = (o = [[7, 1, .7, 1.8], [13, 1, .35, .44], [20, 1, .22, .2], [32, 1, .14, .07], [50, 1, .09, .032], [65, 1, .07, .017], [100, 1, .045, .0075], [160, 1, .027, .0028], [200, 1, .022, .0019], [325, 1, .014, 7e-4], [600, 1, .007, 2e-4], [3250, 1, .0014, 7e-6]], function (t) { for (s = 0; s < o.length; s++)if (t < o[s][0]) { n = s; break } return 0 === n ? this.set_attenuation.apply(this, o[0]) : (r = n - 1, a = o[n][0] - o[r][0], a = (t - o[r][0]) / a, this.attenuation[0] = o[r][1] + (o[n][1] - o[r][1]) * a, this.attenuation[1] = o[r][2] + (o[n][2] - o[r][2]) * a, this.attenuation[2] = o[r][3] + (o[n][3] - o[r][3]) * a, this) }), t.set_attenuation = function (t, i, r) { return e.vec3.set(this.attenuation, t, i, r), this }, function (t) { t = t || {}, i.apply(this, [t]), this.flags = 0, this.shadow_intensity = .9, this.range = t.range || 20, t.attenuation ? this.set_attenuation(this.attenuation[0], this.attenuation[1], this.attenuation[2]) : this.set_attenuation_by_distance(2 * this.range), this.specular[3] = 0, this.diffuse[3] = 0, this.light_type = 1 } }, t.shading.light), t.shading.spot_light = t.define(function (t, e) { return t.set_outer_angle = function (t) { return this.view_angle = t, this.diffuse[3] = Math.cos(t / 2), this }, t.set_inner_angle = function (t) { return this.specular[3] = Math.cos(t / 2), this }, function (t) { t = t || {}, e.apply(this, [t]), this.range = t.range || 10, t.attenuation ? this.set_attenuation(this.attenuation[0], this.attenuation[1], this.attenuation[2]) : this.set_attenuation_by_distance(2 * this.range), this.set_outer_angle(t.outer || .8726646259971648).set_inner_angle(t.inner || .8726646259971648), this.light_type = 2 } }, t.shading.point_light) }(_FM.ge, _FM.math), function (t, e, i, r) { i.register_component("ge_transform", t.define(function (t, e) { t.set_position = function (t, e, i) { return r.vec3.set(this.position, t, e, i), this.require_update = 1, this }, t.set_scale = function (t, e, i) { return r.vec3.set(this.scale, t, e, i), this.require_update = 1, this }, t.rotate_eular = function (t, e, i) { return r.quat.rotate_eular(this.rotation, t, e, i), this.require_update = 1, this }; var i = r.vec3(), n = r.quat(); function s(t, e, i, n) { this.entity = e, this.position = r.vec3(t.position), this.scale = r.vec3(t.scale || [1, 1, 1]), this.rotation = r.quat(t.rotation), this.position_world = r.vec3(), this.scale_world = r.vec3(), this.rotation_world = r.quat(), this.animation_data = void 0, this.require_update = 1, this.parent = void 0, this.flags = 0, this.version = 0 } return t.drage_to_direction = function (t, e) { return r.vec3.scale(i, t, e), r.quat.invert(n, this.rotation_world), r.vec3.transform_quat(i, i, n), r.vec3.add(this.position, this.position, i), this.require_update = 1, this }, s.validate = function (t) { t.app.use_system("ge_transform_system") }, s }, i.component)), i.register_component("ge_transform_controller", t.define(function (t, e) { function i(t, i, n, s) { this.entity = i, e.apply(this, arguments), this.rotate = r.vec3(0, 0, 0), this.matrix_world = r.mat4(), this.up_vector = new Float32Array(this.matrix_world.buffer, 16, 3), this.fw_vector = new Float32Array(this.matrix_world.buffer, 32, 3), this.sd_vector = new Float32Array(this.matrix_world.buffer, 0, 3), this.transform = i.ge_transform, t.rotate && r.vec3.copy(this.rotate, t.rotate), this.rotate_eular(this.rotate[0], this.rotate[1], this.rotate[2]), t.position && this.set_position(t.position[0], t.position[1], t.position[2]) } return t.rotate_eular = function (t, e, i) { return r.quat.rotate_eular(this.transform.rotation, t, e, i), this.transform.require_update = 1, this }, t.yaw_pitch = function (t, e) { return this.rotate[0] += t, this.rotate[1] += e, r.quat.rotate_eular(this.transform.rotation, this.rotate[0], this.rotate[1], this.rotate[2]), this.transform.require_update = 1, this }, t.set_rotate = function (t, e, i) { return this.rotate[0] = t, this.rotate[1] = e, this.rotate[2] = i, r.quat.rotate_eular(this.transform.rotation, this.rotate[0], this.rotate[1], this.rotate[2]), this.transform.require_update = 1, this }, t.set_position = function (t, e, i) { return this.transform.position[0] = t, this.transform.position[1] = e, this.transform.position[2] = i, this.transform.require_update = 1, this }, t.set_position_x = function (t) { return this.transform.position[0] = t, this.transform.require_update = 1, this }, t.set_position_y = function (t) { return this.transform.position[1] = t, this.transform.require_update = 1, this }, t.set_position_z = function (t) { return this.transform.position[2] = t, this.transform.require_update = 1, this }, t.set_position_x_inc = function (t) { return this.transform.position[0] += t, this.transform.require_update = 1, this }, t.set_position_y_inc = function (t) { return this.transform.position[1] += t, this.transform.require_update = 1, this }, t.set_position_z_inc = function (t) { return this.transform.position[2] += t, this.transform.require_update = 1, this }, t.move_front_back = function (t) { return this.transform.position[0] += this.fw_vector[0] * t, this.transform.position[1] += this.fw_vector[1] * t, this.transform.position[2] += this.fw_vector[2] * t, this.transform.require_update = 1, this }, t.move_forward_xz = function (t) { return this.transform.position[0] += this.fw_vector[0] * t, this.transform.position[2] += this.fw_vector[2] * t, this.transform.require_update = 1, this }, t.move_forward_xy = function (t) { return this.transform.position[0] += this.fw_vector[0] * t, this.transform.position[1] += this.fw_vector[1] * t, this.transform.require_update = 1, this }, t.move_left_right = function (t) { return this.transform.position[0] += this.sd_vector[0] * t, this.transform.position[1] += this.sd_vector[1] * t, this.transform.position[2] += this.sd_vector[2] * t, this.transform.require_update = 1, this }, t.move_up_down = function (t) { return this.transform.position[0] += this.up_vector[0] * t, this.transform.position[1] += this.up_vector[1] * t, this.transform.position[2] += this.up_vector[2] * t, this.transform.require_update = 1, this }, i.validate = function (t) { t.app.use_system("ge_transform_system") }, i }, i.component)), i.register_system("ge_transform_system", t.define(function (t, i) { var n = 0, s = null, a = null, o = r.vec3(), _ = r.quat(), l = null, u = null, h = null; t.step = function () { for (this.transforms.length = 0, n = 0; null !== (a = this.app.iterate_entities("ge_transform"));)s = a.ge_transform, this.transforms[n++] = s, s.flags; for (this.process(this.transforms, 1); null !== (a = this.app.iterate_entities("ge_transform_controller"));)s = a.ge_transform_controller, this.transforms[n++] = s, 0 !== s.transform.require_update && (r.mat4.from_quat(s.matrix_world, s.transform.rotation_world), r.mat4.scale(s.matrix_world, s.transform.scale_world), s.matrix_world[12] = s.transform.position_world[0], s.matrix_world[13] = s.transform.position_world[1], s.matrix_world[14] = s.transform.position_world[2]) }, t.step_end = function () { for (n = 0; n < this.transforms.length; n++)(s = this.transforms[n]).require_update < 0 ? s.require_update = Math.abs(s.require_update) : s.require_update = 0 }, e.create_animation_data = function () { var t = new Float32Array(10); return { data: t, position: new Float32Array(t.buffer, 0, 3), scale: new Float32Array(t.buffer, 12, 3), rotation: new Float32Array(t.buffer, 24, 4) } }; var c, d, m, p, f, g, v, w, x, y, b, E, A, z, T, M, L, I, S, R, F, k, G, N, C, P, q = e.create_animation_data(); return t.process = function (t, e) { for (n = 0; n < t.length; n++)s = t[n], l = s.scale, h = s.position, u = s.rotation, s.animation_data && (s.animation_data.position && (q.position[0] = s.position[0] + s.animation_data.position[0], q.position[1] = s.position[1] + s.animation_data.position[1], q.position[2] = s.position[2] + s.animation_data.position[2], h = q.position), s.animation_data.scale && (q.scale[0] = s.scale[0] + s.animation_data.scale[0], q.scale[1] = s.scale[1] + s.animation_data.scale[1], q.scale[2] = s.scale[2] + s.animation_data.scale[2], l = q.scale), s.animation_data.rotation ? (x = q.rotation, y = s.rotation, b = s.animation_data.rotation, c = y[0], d = y[1], m = y[2], p = y[3], f = b[0], g = b[1], v = b[2], w = b[3], x[0] = c * w + p * f + d * v - m * g, x[1] = d * w + p * g + m * f - c * v, x[2] = m * w + p * v + c * g - d * f, x[3] = p * w - c * f - d * g - m * v, u = q.rotation) : s.animation_data.eular && (x = _, c = Math.sin(.5 * s.animation_data.eular[0]), d = Math.sin(.5 * s.animation_data.eular[1]), m = Math.sin(.5 * s.animation_data.eular[2]), f = Math.cos(.5 * s.animation_data.eular[0]), g = Math.cos(.5 * s.animation_data.eular[1]), v = Math.cos(.5 * s.animation_data.eular[2]), x[0] = c * g * v - f * d * m, x[1] = f * d * v + c * g * m, x[2] = f * g * m - c * d * v, x[3] = f * g * v + c * d * m, c = x[0], d = x[1], m = x[2], p = x[3], (E = c * c + d * d + m * m + p * p) > 0 && (E = 1 / Math.sqrt(E)), x[0] = c * E, x[1] = d * E, x[2] = m * E, x[3] = p * E, x = q.rotation, y = s.rotation, b = _, c = y[0], d = y[1], m = y[2], p = y[3], f = b[0], g = b[1], v = b[2], w = b[3], x[0] = c * w + p * f + d * v - m * g, x[1] = d * w + p * g + m * f - c * v, x[2] = m * w + p * v + c * g - d * f, x[3] = p * w - c * f - d * g - m * v, u = q.rotation), s.require_update = 1), void 0 !== s.parent ? (s.parent.require_update !== e && 100 !== s.parent.require_update || (s.require_update = e), s.require_update === e && (x = s.rotation_world, y = s.parent.rotation_world, b = u, c = y[0], d = y[1], m = y[2], p = y[3], f = b[0], g = b[1], v = b[2], w = b[3], x[0] = c * w + p * f + d * v - m * g, x[1] = d * w + p * g + m * f - c * v, x[2] = m * w + p * v + c * g - d * f, x[3] = p * w - c * f - d * g - m * v, s.scale_world[0] = s.parent.scale_world[0] * l[0], s.scale_world[1] = s.parent.scale_world[1] * l[1], s.scale_world[2] = s.parent.scale_world[2] * l[2], 2 & s.flags ? (o[0] = h[0] * s.parent.scale_world[0], o[1] = h[1] * s.parent.scale_world[1], o[2] = h[2] * s.parent.scale_world[2], A = o[0], z = o[1], T = o[2], M = s.parent.rotation_world[0], L = s.parent.rotation_world[1], I = s.parent.rotation_world[2], S = s.parent.rotation_world[3], N = L * (G = M * z - L * A) - I * (k = I * A - M * T), C = I * (F = L * T - I * z) - M * G, P = M * k - L * F, F *= R = 2 * S, k *= R, G *= R, N *= 2, C *= 2, P *= 2, o[0] = A + F + N, o[1] = z + k + C, o[2] = T + G + P) : (A = h[0], z = h[1], T = h[2], M = s.parent.rotation_world[0], L = s.parent.rotation_world[1], I = s.parent.rotation_world[2], S = s.parent.rotation_world[3], N = L * (G = M * z - L * A) - I * (k = I * A - M * T), C = I * (F = L * T - I * z) - M * G, P = M * k - L * F, F *= R = 2 * S, k *= R, G *= R, N *= 2, C *= 2, P *= 2, o[0] = A + F + N, o[1] = z + k + C, o[2] = T + G + P), s.position_world[0] = o[0] + s.parent.position_world[0], s.position_world[1] = o[1] + s.parent.position_world[1], s.position_world[2] = o[2] + s.parent.position_world[2], s.version = (1 + (0 | s.version)) % 99999)) : s.require_update === e && (s.scale_world[0] = l[0], s.scale_world[1] = l[1], s.scale_world[2] = l[2], s.position_world[0] = h[0], s.position_world[1] = h[1], s.position_world[2] = h[2], s.rotation_world[0] = u[0], s.rotation_world[1] = u[1], s.rotation_world[2] = u[2], s.rotation_world[3] = u[3], s.version = (1 + (0 | s.version)) % 99999) }, function () { i.apply(this, arguments), this.transforms = [], this.priority = 100 } }, i.system)) }(_FM.fin, _FM.ge, _FM.ecs, _FM.math), ge = _FM.ge, ecs = _FM.ecs, math = _FM.math, ecs.register_component("ge_camera", ge.define(function (t, e) { t.update_aspect = function (t) { this.aspect = t, this.update_view_projection = 1 }; var i, r, n, s = 0; function a(t, i, r, n) { e.apply(this, arguments), this.view = math.mat4(), this.view_inverse = math.mat4(), this.projection = math.mat4(), this.projection_inverse = math.mat4(), this.view_projection = math.mat4(), this.view_projection_inverse = math.mat4(), this.version = 0, this.up_vector = new Float32Array(this.view.buffer, 16, 3), this.fw_vector = new Float32Array(this.view.buffer, 32, 3), this.sd_vector = new Float32Array(this.view.buffer, 0, 3), this.frustum_plans = [math.vec4(), math.vec4(), math.vec4(), math.vec4(), math.vec4(), math.vec4()], this.world_position = new Float32Array(this.view.buffer, 48, 3), this.bounds = math.aabb(), this._bounds = math.aabb(), this.is_locked = !1, this.entity = i, this.update_view_projection = !0, this.type = t.type || "perspective", "perspective" === this.type ? (this.fov = .017453292519943295 * (void 0 !== t.fov ? t.fov : 60), this.near = void 0 !== t.near ? t.near : .1, this.far = void 0 !== t.far ? t.far : 2e4, this.aspect = void 0 !== t.aspect ? t.aspect : 1) : (this.left = t.left || -.5, this.right = t.right || .5, this.bottom = t.bottom || -.5, this.top = t.top || .5, this.near = t.near || .1, this.far = t.far || 20, this.aspect = Math.abs((this.right - this.left) / (this.top - this.bottom))), this.vp_left = 0, this.vp_top = 0, this.vp_width = 1, this.vp_height = 1, this.drag_direction = math.vec3(), this.last_drag_direction = math.vec3(), this.version = 0, this.update_view_projection = 1 } return t.update_frustum_plane = function (t, e, i, r, n) { s = e * e + i * i + r * r + n * n, s = 1 / Math.sqrt(s), this.frustum_plans[t][0] = e * s, this.frustum_plans[t][1] = i * s, this.frustum_plans[t][2] = r * s, this.frustum_plans[t][3] = n * s }, t.calc_bounds = function () { var t, e, i, r, n, s; function a(a, o, _) { t = Math.min(t, a), e = Math.min(e, o), i = Math.min(i, _), r = Math.max(r, a), n = Math.max(n, o), s = Math.max(s, _) } return function () { var o = Math.tan(this.fov / 2) * this.aspect, _ = o * this.near, l = o * this.far, u = o * this.near, h = o * this.far; t = 99999, e = 99999, i = 99999, r = -99999, n = -99999, s = -99999, a(-_, -u, this.near), a(_, -u, this.near), a(_, u, this.near), a(-_, u, this.near), a(-l, -h, -this.far), a(l, -h, -this.far), a(l, h, -this.far), a(-l, h, -this.far), this._bounds[0] = t, this._bounds[1] = e, this._bounds[2] = i, this._bounds[3] = r, this._bounds[4] = n, this._bounds[5] = s } }(), t.update_frustum = function (t) { math.aabb.transform_mat4(this.bounds, this._bounds, this.view), this.update_frustum_plane(0, t[3] - t[0], t[7] - t[4], t[11] - t[8], t[15] - t[12]), this.update_frustum_plane(1, t[3] + t[0], t[7] + t[4], t[11] + t[8], t[15] + t[12]), this.update_frustum_plane(2, t[3] + t[1], t[7] + t[5], t[11] + t[9], t[15] + t[13]), this.update_frustum_plane(3, t[3] - t[1], t[7] - t[5], t[11] - t[9], t[15] - t[13]), this.update_frustum_plane(4, t[3] - t[2], t[7] - t[6], t[11] - t[10], t[15] - t[14]), this.update_frustum_plane(5, t[3] + t[2], t[7] + t[6], t[11] + t[10], t[15] + t[14]) }, t.frustum_aabb = (t._frustum_aabb = function (t, e, i, r, n, s) { var a, o = 0; for (o = 0; o < 6; o++)if (a = this.frustum_plans[o], Math.max(t * a[0], r * a[0]) + Math.max(e * a[1], n * a[1]) + Math.max(i * a[2], s * a[2]) + a[3] < 0) return !1; return !0 }, function (t) { return this._frustum_aabb(t[0], t[1], t[2], t[3], t[4], t[5]) }), t.aabb_aabb = function (t) { return (i = this.bounds)[0] <= t[3] && i[3] >= t[0] && i[1] <= t[4] && i[4] >= t[1] && i[2] <= t[5] && i[5] >= t[2] }, t.get_mouse_ray_pos = (r = math.vec4(), n = math.vec3(), t.set_drag_direction = function (t, e, i, s) { return r[0] = t / i * 2 - 1, r[1] = -e / s * 2 + 1, r[2] = -1, math.vec3.transform_mat4(n, r, this.view_projection_inverse), r[2] = 1, math.vec3.transform_mat4(r, r, this.view_projection_inverse), math.vec3.subtract(this.drag_direction, r, this.last_drag_direction), math.vec3.normalize(this.drag_direction, this.drag_direction), math.vec3.copy(this.last_drag_direction, r), this.drag_direction }, function (t, e, i, s, a) { return r[0] = e / s * 2 - 1, r[1] = -i / a * 2 + 1, r[2] = -1, math.vec3.transform_mat4(n, r, this.view_projection_inverse), r[2] = 1, math.vec3.transform_mat4(t, r, this.view_projection_inverse), t }), a.validate = function (t) { t.app.use_system("ge_camera_system") }, a }, ecs.component)), ecs.register_component("ge_mouse_camera_controller", fin.define(function (t, e) { function i(t, e, i, r) { this.entity = e, console.log(e), this.element = t.element, this.wheel_delta = t.wheel_delta || .25, this.set_mouse_input(this.element), this.mouse_camera_ray_pos = math.vec3(), this.mouse_camera_ray = math.vec3(), this.on_mouse_down = new ge.event(this, [0, 0, null]), this.on_mouse_up = new ge.event(this, [0, 0, null]), this.on_mouse_drage = new ge.event(this, [0, 0, null]), this.on_mouse_wheel = new ge.event(this, [0, null]), this.mouse_ray_start = math.vec3(), this.mouse_ray_end = math.vec3(), this.suspended = !1, t.on_mouse_down && this.on_mouse_down.add(t.on_mouse_down), t.on_mouse_up && this.on_mouse_up.add(t.on_mouse_up), t.on_mouse_drage && this.on_mouse_drage.add(t.on_mouse_drage), t.on_mouse_wheel && this.on_mouse_wheel.add(t.on_mouse_wheel) } return t.mouse_wheel = function (t, e) { this.on_mouse_wheel.params[0] = t, this.on_mouse_wheel.params[1] = e, !1 !== this.on_mouse_wheel.trigger_params() && (this.entity.ge_camera.is_locked || this.entity.ge_transform_controller.move_front_back(-this.wheel_delta * t)) }, t.get_mouse_camera_pos = function (t) { this.entity.ge_camera.get_mouse_ray_pos(t, this.mouse_x, this.mouse_y, this.elm_rect.width, this.elm_rect.height) }, t.mouse_drage = function (t, e, i) { this.entity.ge_camera.set_drag_direction(this.mouse_x, this.mouse_y, this.elm_rect.width, this.elm_rect.height), this.on_mouse_drage.params[0] = t, this.on_mouse_drage.params[1] = e, this.on_mouse_drage.params[2] = i, !1 !== this.on_mouse_drage.trigger_params() && (this.entity.ge_camera.is_locked || this.entity.ge_transform_controller.yaw_pitch(.005 * -e, .005 * -t)) }, t.mouse_click = t.mouse_move = function (t, e, i) { }, t.mouse_move2 = function (t, e, i) { this.entity.ge_camera.get_mouse_ray_pos(this.mouse_camera_ray_pos, this.mouse_x, this.mouse_y, this.elm_rect.width, this.elm_rect.height), math.vec3.subtract(this.mouse_camera_ray, this.mouse_camera_ray_pos, this.entity.ge_camera.world_position), math.vec3.normalize(this.mouse_camera_ray, this.mouse_camera_ray) }, t.mouse_down = function (t, e, i) { this.on_mouse_down.params[0] = t, this.on_mouse_down.params[1] = e, this.on_mouse_down.params[2] = i, this.on_mouse_down.trigger_params() }, t.mouse_up = function (t, e, i) { this.on_mouse_up.params[0] = t, this.on_mouse_up.params[1] = e, this.on_mouse_up.params[2] = i, this.on_mouse_up.trigger_params() }, t.mouse_drage2 = function (t, e, i) { }, t.set_mouse_input = function (t) { var e = this; this.elm_rect = t.getBoundingClientRect(), t.addEventListener(/Firefox/i.test(navigator.userAgent) ? "DOMMouseScroll" : "mousewheel", function (t) { e.mouse_wheel(t.detail ? -120 * t.detail : t.wheelDelta, t) }, !1); var i = 0, r = 0, n = null; t.addEventListener("mousedown", function (s) { this.elm_rect = t.getBoundingClientRect(), n = this.elm_rect, i = s.clientX - n.left, r = s.clientY - n.top, e.elm_width = n.right - n.left, e.elm_height = n.bottom - n.top, e.mouse_buttons = s.buttons, e.mouse_down_x = i, e.mouse_down_y = r, e.mouse_down(e.mouse_down_x, e.mouse_down_y, s), e.mouse_delta = 1, e.mouse_is_down = !0, e.mouse_is_up = !1 }), t.addEventListener("click", function (t) { e.mouse_click(e.mouse_x, e.mouse_y, t) }), t.addEventListener("mouseup", function (t) { e.mouse_buttons = 0, e.mouse_is_up = !0, e.mouse_is_down = !1, e.mouse_up(e.mouse_x, e.mouse_y, t) }), t.addEventListener("mousemove", function (s) { n = t.getBoundingClientRect(), i = s.clientX - n.left, r = s.clientY - n.top, e.elm_width = n.right - n.left, e.elm_height = n.bottom - n.top, e.mouse_buttons = s.buttons, e.mouse_x = i, e.mouse_y = r, e.mouse_draging = !1, e.mouse_move(e.mouse_x, e.mouse_y, s), 1 == s.buttons && (e.mouse_down_x = e.mouse_down_x || i, e.mouse_down_y = e.mouse_down_y || r, e.mouse_dx = i - e.mouse_down_x, e.mouse_dy = r - e.mouse_down_y, e.mouse_drage(e.mouse_dx, e.mouse_dy, s), e.mouse_down_x = i, e.mouse_down_y = r, e.mouse_draging = !0) }) }, t.set_mouse_ray = function () { math.vec3.copy(this.mouse_ray_start, this.entity.ge_camera.world_position), this.entity.ge_camera.get_mouse_ray_pos(this.mouse_ray_end, this.mouse_x, this.mouse_y, this.elm_rect.width, this.elm_rect.height) }, i.validate = function (t) { t.app.use_system("ge_camera_system"), t.app.use_system("ge_render_system") }, i }, ecs.component)), ecs.register_component("ge_keyboard_camera_controller", fin.define(function (t, e) { function i(t, e, i, r) { this.entity = e, console.log(e), this.element = t.element, this.front_back_delta = t.front_back_delta || 1, this.shift_key = !1, this.set_keyboard_input(this.element), this.key_down = !1, this.on_key_down = t.on_key_down } return t.set_keyboard_input = function (t) { var e = this; e.keys = [], t.addEventListener("keydown", function (t) { e.keys[t.keyCode] = !0, e.shift_key = t.shiftKey, e.key_down = !0 }), t.addEventListener("keyup", function (t) { e.keys[t.keyCode] = !1, e.shift_key = t.shiftKey, e.key_down = !1 }) }, t.update = function () { this.keys[87] && (this.shift_key ? this.entity.ge_transform_controller.move_front_back(4 * -this.front_back_delta) : this.entity.ge_transform_controller.move_front_back(-this.front_back_delta), this.entity.ge_transform.require_update = -1), this.keys[83] && (this.shift_key ? this.entity.ge_transform_controller.move_front_back(4 * this.front_back_delta) : this.entity.ge_transform_controller.move_front_back(this.front_back_delta), this.entity.ge_transform.require_update = -1), this.key_down && this.on_key_down && this.on_key_down(this.keys) }, i.validate = function (t) { t.app.use_system("ge_camera_system"), t.app.use_system("ge_render_system") }, i }, ecs.component)), ecs.register_system("ge_camera_system", ge.define(function (t, e) { var i, r, n, s, a, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y, b, E, A, z, T, M, L, I, S, R, F, k, G, N, C, P, q = null, j = null, D = null; return t.step = function () { for (; null !== (D = this.app.iterate_entities("ge_keyboard_camera_controller"));)D.ge_keyboard_camera_controller.update(); for (; null !== (D = this.app.iterate_entities("ge_camera"));)j = D.ge_camera, q = D.ge_transform, 1 === j.update_view_projection && ("perspective" === j.type ? math.mat4.perspective(j.projection, j.fov, j.aspect, j.near, j.far) : math.mat4.ortho(j.projection, j.left, j.right, j.bottom, j.top, j.near, j.far), R = j.projection_inverse, F = j.projection, i = F[0], r = F[1], n = F[2], s = F[3], a = F[4], o = F[5], _ = F[6], l = F[7], u = F[8], h = F[9], c = F[10], d = F[11], m = F[12], p = F[13], f = F[14], g = F[15], (v = (w = i * o - r * a) * (S = c * g - d * f) - (x = i * _ - n * a) * (I = h * g - d * p) + (y = i * l - s * a) * (L = h * f - c * p) + (b = r * _ - n * o) * (M = u * g - d * m) - (E = r * l - s * o) * (T = u * f - c * m) + (A = n * l - s * _) * (z = u * p - h * m)) && (v = 1 / v, R[0] = (o * S - _ * I + l * L) * v, R[1] = (n * I - r * S - s * L) * v, R[2] = (p * A - f * E + g * b) * v, R[3] = (c * E - h * A - d * b) * v, R[4] = (_ * M - a * S - l * T) * v, R[5] = (i * S - n * M + s * T) * v, R[6] = (f * y - m * A - g * x) * v, R[7] = (u * A - c * y + d * x) * v, R[8] = (a * I - o * M + l * z) * v, R[9] = (r * M - i * I - s * z) * v, R[10] = (m * E - p * y + g * w) * v, R[11] = (h * y - u * E - d * w) * v, R[12] = (o * T - a * L - _ * z) * v, R[13] = (i * L - r * T + n * z) * v, R[14] = (p * x - m * b - f * w) * v, R[15] = (u * b - h * x + c * w) * v)), 0 !== q.require_update && (j.version = (1 + (0 | j.version)) % 99999, R = j.view, C = q.rotation_world, i = C[0], r = C[1], n = C[2], s = C[3], w = i * (k = i + i), x = i * (G = r + r), y = i * (N = n + n), b = r * G, E = r * N, A = n * N, z = s * k, T = s * G, M = s * N, R[0] = 1 - (b + A), R[1] = x + M, R[2] = y - T, R[3] = 0, R[4] = x - M, R[5] = 1 - (w + A), R[6] = E + z, R[7] = 0, R[8] = y + T, R[9] = E - z, R[10] = 1 - (w + b), R[11] = 0, R = j.view, C = q.scale_world, R[0] *= C[0], R[1] *= C[0], R[2] *= C[0], R[3] *= C[0], R[4] *= C[1], R[5] *= C[1], R[6] *= C[1], R[7] *= C[1], R[8] *= C[2], R[9] *= C[2], R[10] *= C[2], R[11] *= C[2], j.view[12] = q.position_world[0], j.view[13] = q.position_world[1], j.view[14] = q.position_world[2], j.update_view_projection = 1), 1 === j.update_view_projection && (j.version = (1 + (0 | j.version)) % 99999, j.update_view_projection = 0, R = j.view_inverse, F = j.view, i = F[0], r = F[1], n = F[2], s = F[3], a = F[4], o = F[5], _ = F[6], l = F[7], u = F[8], h = F[9], c = F[10], d = F[11], m = F[12], p = F[13], f = F[14], g = F[15], (v = (w = i * o - r * a) * (S = c * g - d * f) - (x = i * _ - n * a) * (I = h * g - d * p) + (y = i * l - s * a) * (L = h * f - c * p) + (b = r * _ - n * o) * (M = u * g - d * m) - (E = r * l - s * o) * (T = u * f - c * m) + (A = n * l - s * _) * (z = u * p - h * m)) && (v = 1 / v, R[0] = (o * S - _ * I + l * L) * v, R[1] = (n * I - r * S - s * L) * v, R[2] = (p * A - f * E + g * b) * v, R[3] = (c * E - h * A - d * b) * v, R[4] = (_ * M - a * S - l * T) * v, R[5] = (i * S - n * M + s * T) * v, R[6] = (f * y - m * A - g * x) * v, R[7] = (u * A - c * y + d * x) * v, R[8] = (a * I - o * M + l * z) * v, R[9] = (r * M - i * I - s * z) * v, R[10] = (m * E - p * y + g * w) * v, R[11] = (h * y - u * E - d * w) * v, R[12] = (o * T - a * L - _ * z) * v, R[13] = (i * L - r * T + n * z) * v, R[14] = (p * x - m * b - f * w) * v, R[15] = (u * b - h * x + c * w) * v), R = j.view_projection, F = j.projection, P = j.view_inverse, i = F[0], r = F[1], n = F[2], s = F[3], a = F[4], o = F[5], _ = F[6], l = F[7], u = F[8], h = F[9], c = F[10], d = F[11], m = F[12], p = F[13], f = F[14], g = F[15], w = P[0], x = P[1], y = P[2], b = P[3], R[0] = w * i + x * a + y * u + b * m, R[1] = w * r + x * o + y * h + b * p, R[2] = w * n + x * _ + y * c + b * f, R[3] = w * s + x * l + y * d + b * g, w = P[4], x = P[5], y = P[6], b = P[7], R[4] = w * i + x * a + y * u + b * m, R[5] = w * r + x * o + y * h + b * p, R[6] = w * n + x * _ + y * c + b * f, R[7] = w * s + x * l + y * d + b * g, w = P[8], x = P[9], y = P[10], b = P[11], R[8] = w * i + x * a + y * u + b * m, R[9] = w * r + x * o + y * h + b * p, R[10] = w * n + x * _ + y * c + b * f, R[11] = w * s + x * l + y * d + b * g, w = P[12], x = P[13], y = P[14], b = P[15], R[12] = w * i + x * a + y * u + b * m, R[13] = w * r + x * o + y * h + b * p, R[14] = w * n + x * _ + y * c + b * f, R[15] = w * s + x * l + y * d + b * g, R = j.view_projection_inverse, F = j.view_projection, i = F[0], r = F[1], n = F[2], s = F[3], a = F[4], o = F[5], _ = F[6], l = F[7], u = F[8], h = F[9], c = F[10], d = F[11], m = F[12], p = F[13], f = F[14], g = F[15], (v = (w = i * o - r * a) * (S = c * g - d * f) - (x = i * _ - n * a) * (I = h * g - d * p) + (y = i * l - s * a) * (L = h * f - c * p) + (b = r * _ - n * o) * (M = u * g - d * m) - (E = r * l - s * o) * (T = u * f - c * m) + (A = n * l - s * _) * (z = u * p - h * m)) && (v = 1 / v, R[0] = (o * S - _ * I + l * L) * v, R[1] = (n * I - r * S - s * L) * v, R[2] = (p * A - f * E + g * b) * v, R[3] = (c * E - h * A - d * b) * v, R[4] = (_ * M - a * S - l * T) * v, R[5] = (i * S - n * M + s * T) * v, R[6] = (f * y - m * A - g * x) * v, R[7] = (u * A - c * y + d * x) * v, R[8] = (a * I - o * M + l * z) * v, R[9] = (r * M - i * I - s * z) * v, R[10] = (m * E - p * y + g * w) * v, R[11] = (h * y - u * E - d * w) * v, R[12] = (o * T - a * L - _ * z) * v, R[13] = (i * L - r * T + n * z) * v, R[14] = (p * x - m * b - f * w) * v, R[15] = (u * b - h * x + c * w) * v), "perspective" === j.type && j.calc_bounds(), j.update_frustum(j.view_projection)) }, t.validate = function (t) { this.priority = t.use_system("ge_transform_system").priority + 50 }, function (t, i) { e.apply(this, arguments) } }, ecs.system)), function (t, e, i) { var r, n, s, o; e.geometry = { shapes: {} }, e.geometry.geometry_data = e.define(function (r) { function n() { return this.compiled = !1, this.uuid = t.guidi(), this.attributes = {}, this.version = 0, this.bounds_sphere = 0, this.aabb = i.aabb(), this.index_buffer = null, this.index_data = null, this.origin = i.vec3(), this } var s, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y, b, E, A, z, T, M, L; return r.set_indices = function (t) { "[object Uint16Array]" === Object.prototype.toString.call(t) || "[object Uint32Array]" === Object.prototype.toString.call(t) ? this.index_data = t : this.index_data = n.create_index_data(t), this.index_needs_update = !0, this.num_items = this.index_data.length }, r.add_attribute = function (t, e) { return e.buffer = null, e.item_size = e.item_size || 3, e.data = e.data || null, e.needs_update = e.needs_update || !1, e.divisor = e.divisor || 0, e.array = e.array || null, e.data_offset = e.data_offset || 0, e.data_length = e.data_length || 0, e.buffer_type = e.buffer_type || 35044, e.name = t, e.geo_id = this.uuid, null !== e.data && (e.data_length = e.data.length), this.attributes[t] = e, e }, r.create_instance_id_attribute = function (t) { for (var e = this.add_attribute("a_instance_id_rw", { data: new Float32Array(t), item_size: 1, divisor: 1 }), i = 0; i < e.data.length; i++)e.data[i] = i }, r.convert_to_index_geometry = function () { var t, e, i, r = this.attributes.a_position_rw.data, s = this.attributes.a_normal_rw ? this.attributes.a_normal_rw.data : void 0, a = this.attributes.a_uv_rw ? this.attributes.a_uv_rw.data : void 0, o = [], _ = [], l = [], u = {}, h = []; for (e = 0; e < r.length; e += 3)u[t = r[e] + ":" + r[e + 1] + ":" + r[e + 2]] || (u[t] = o.length / 3 + 1, o.push(r[e], r[e + 1], r[e + 2]), s && _.push(s[e], s[e + 1], s[e + 2]), a && (i = e / 3 * 2, l.push(a[i], a[i + 1]))), h.push(u[t] - 1); var c = n.create({ vertices: new Float32Array(o), normals: _.length > 0 ? new Float32Array(_) : void 0, uvs: l.length > 0 ? new Float32Array(l) : void 0 }); return c.set_indices(h), c }, r.auto_normals = function () { this.attributes.a_normal_rw || n.calc_normals(this) }, r.clone = function () { var t = n.create({ vertices: new Float32Array(this.attributes.a_position_rw.data), normals: this.attributes.a_normal_rw ? new Float32Array(this.attributes.a_normal_rw.data) : void 0, uvs: this.attributes.a_uv_rw ? new Float32Array(this.attributes.a_uv_rw.data) : void 0 }); return null !== this.index_data && t.set_indices(this.index_data), t }, r.center_pivot = function (t, e, i, r, s, a) { var o = this.attributes.a_position_rw; return n.center_pivot(this, t, e, i, r, s, a, o.data, o.data.length, o.item_size) }, r.scale_position_rotation = function (t, e, i, r, s, a, o, _, l, u) { u = u || this.attributes.a_position_rw, n.scale_position_rotation(t, e, i, r, s, a, o, _, l, u.data, u.data.length, u.item_size), n.calc_bounds(this, u.data, u.data.length, u.item_size) }, n.index_data_type = Uint32Array, n.center_pivot = function (t, e, i, r, s, a, o, _, l, u) { var h = t.aabb; n.scale_position_rotation(1, 1, 1, -h[0], -h[1], -h[2], 0, 0, 0, _, l, u), n.calc_bounds(t, _, l, u); var c = .5 * ((h = t.aabb)[3] - h[0]), d = .5 * (h[4] - h[1]), m = .5 * (h[5] - h[2]); n.scale_position_rotation(1, 1, 1, -c, -d, -m, 0, 0, 0, _, l, u), n.calc_bounds(t, _, l, u), n.scale_position_rotation(e, i, r, 0, 0, 0, s, a, o, _, u), n.calc_bounds(t, _, l, u) }, n.create_index_data = function (t) { return new this.index_data_type(t) }, n.scale_position_rotation = (s = i.mat4(), o = i.quat(), function (t, e, r, a, _, l, u, h, c, d, m, p) { i.quat.rotate_eular(o, u, h, c), i.mat4.from_quat(s, o), s[0] *= t, s[1] *= e, s[2] *= r, s[4] *= t, s[5] *= e, s[6] *= r, s[8] *= t, s[9] *= e, s[10] *= r, s[12] = a, s[13] = _, s[14] = l, n.transform(d, m, p, s) }), n.calc_bounds = (_ = i.vec3(), l = i.vec3(), u = 0, n.transform = function (t, e, r, n) { for (u = 0; u < e; u += r)i.vec3.transform_mat4x(_, t[u], t[u + 1], t[u + 2], n), t[u] = _[0], t[u + 1] = _[1], t[u + 2] = _[2] }, function (t, e, r, n) { for (t.bounds_sphere = 0, i.vec3.set(_, 1 / 0, 1 / 0, 1 / 0), i.vec3.set(l, -1 / 0, -1 / 0, -1 / 0), u = 0; u < r; u += n)t.bounds_sphere = Math.max(t.bounds_sphere, Math.abs(Math.hypot(e[u], e[u + 1], e[u + 2]))), _[0] = Math.min(_[0], e[u]), _[1] = Math.min(_[1], e[u + 1]), _[2] = Math.min(_[2], e[u + 2]), l[0] = Math.max(l[0], e[u]), l[1] = Math.max(l[1], e[u + 1]), l[2] = Math.max(l[2], e[u + 2]); return t.origin[0] = _[0] + .5 * (l[0] - _[0]), t.origin[1] = _[1] + .5 * (l[1] - _[1]), t.origin[2] = _[2] + .5 * (l[2] - _[2]), i.aabb.set(t.aabb, _[0], _[1], _[2], l[0], l[1], l[2]), t.bounds_sphere }), n.calc_normals = (E = i.vec3(), A = i.vec3(), z = i.vec3(), T = i.vec3(), M = i.vec3(), L = i.vec3(), i.vec3(), i.vec3(), n.invert_normals = function (t) { for (b = t.attributes.a_normal_rw.data, w = 0; w < b.length; w += 3)b[w] = -b[w], b[w + 1] = -b[w + 1], b[w + 2] = -b[w + 2]; t.attributes.needs_update = !0 }, function (t, e) { var r = t.attributes.a_position_rw.data; t.attributes.a_normal_rw || t.add_attribute("a_normal_rw", { data: new Float32Array(r.length) }), b = t.attributes.a_normal_rw.data; var n = t.index_data; b.fill(0); var s = r.length, o = 9; null !== n && (s = n.length, o = 3); for (var _ = 0; _ < s; _ += o)null !== n ? (w = n[_], x = n[_ + 1], y = n[_ + 2], i.vec3.set(E, r[3 * w], r[3 * w + 1], r[3 * w + 2]), i.vec3.set(A, r[3 * x], r[3 * x + 1], r[3 * x + 2]), i.vec3.set(z, r[3 * y], r[3 * y + 1], r[3 * y + 2])) : (i.vec3.set(E, r[_ + 0], r[_ + 1], r[_ + 2]), i.vec3.set(A, r[_ + 3], r[_ + 4], r[_ + 5]), i.vec3.set(z, r[_ + 6], r[_ + 7], r[_ + 8])), i.vec3.subtract(T, z, A), i.vec3.subtract(M, E, A), null !== n ? (w *= 3, x *= 3, y *= 3) : (w = _, x = _ + 3, y = _ + 6), e ? (i.vec3.cross(L, T, M), i.vec3.normalize(T, L), b[w + 0] += T[0], b[w + 1] += T[1], b[w + 2] += T[2], b[x + 0] += T[0], b[x + 1] += T[1], b[x + 2] += T[2], b[y + 0] += T[0], b[y + 1] += T[1], b[y + 2] += T[2]) : (i.vec3.cross(L, T, M), i.vec3.copy(T, L), b[w + 0] += T[0], b[w + 1] += T[1], b[w + 2] += T[2], b[x + 0] += T[0], b[x + 1] += T[1], b[x + 2] += T[2], b[y + 0] += T[0], b[y + 1] += T[1], b[y + 2] += T[2]); for (a = 0; a < b.length; a += 3)i.vec3.set(T, b[a], b[a + 1], b[a + 2]), i.vec3.normalize(L, T), b[a] = L[0], b[a + 1] = L[1], b[a + 2] = L[2] }), n.calc_tangents = (h = i.vec3(), c = i.vec3(), d = i.vec4(), m = i.vec3(), p = i.vec3(), f = i.vec3(), g = i.vec3(), v = i.vec3(), function (t) { var e = t.attributes.a_position_rw.data, r = t.attributes.a_normal_rw.data, n = t.attributes.a_tangent_rw.data, s = t.attributes.a_uv_rw.data, a = t.index_data, o = new Float32Array(e.length); o.fill(0); var _, l, u, w, x, y, b, E, A, z, T, M, L, I, S, R, F, k, G, N, C, P = new Float32Array(e.length); P.fill(0); for (var q = 0; q < a.length; q += 3)_ = a[q], l = a[q + 1], w = 3 * _, y = 3 * (u = a[q + 2]), b = e[x = 3 * l] - e[w], E = e[y] - e[w], A = e[x + 1] - e[w + 1], z = e[y + 1] - e[w + 1], T = e[x + 2] - e[w + 2], M = e[y + 2] - e[w + 2], L = 2 * _, S = 2 * u, R = s[I = 2 * l] - s[L], F = s[S] - s[L], k = s[I + 1] - s[L + 1], N = 1 / (R * (G = s[S + 1] - s[L + 1]) - F * k), i.vec3.set(g, (G * b - k * E) * N, (G * A - k * z) * N, (G * T - k * M) * N), i.vec3.set(v, (R * E - F * b) * N, (R * z - F * A) * N, (R * M - F * T) * N), o[w] += g[0], o[w + 1] += g[1], o[w + 2] += g[2], o[x] += g[0], o[x + 1] += g[1], o[x + 2] += g[2], o[y] += g[0], o[y + 1] += g[1], o[y + 2] += g[2], P[w] += v[0], P[w + 1] += v[1], P[w + 2] += v[2], P[x] += v[0], P[x + 1] += v[1], P[x + 2] += v[2], P[y] += v[0], P[y + 1] += v[1], P[y + 2] += v[2]; for (var j = 0; j < e.length; j += 3)C = j / 3, i.vec3.set(h, r[j], r[j + 1], r[j + 2]), i.vec3.set(c, o[j], o[j + 1], o[j + 2]), i.vec3.scale(f, h, i.vec3.dot(h, c)), i.vec3.subtract(p, c, f), i.vec3.normalize(d, p), i.vec3.cross(m, h, c), i.vec3.set(p, P[j], P[j + 1], P[j + 2]), d[3] = i.vec3.dot(m, p) < 0 ? -1 : 1, n[4 * C] = d[0], n[4 * C + 1] = d[1], n[4 * C + 2] = d[2], n[4 * C + 3] = d[3] }), n.lines_builder = new function () { var t, i, r, s, a, o; return this.vertices = new e.array, this.clear = function () { return this.vertices.clear(), this }, this.add = function (e, n, s) { return t = e, i = n, r = s, this.vertices.push(e), this.vertices.push(n), this.vertices.push(s), this }, this.add2 = function (t, e, i, r, n, s) { return this.add(t, e, i), this.add(r, n, s), this }, this.add_to = function (e, n, s) { return this.add(t, i, r), this.add(e, n, s), this }, this.move_to = function (e, n, _) { return t = e, i = n, r = _, s = e, a = n, o = _, this }, this.close_path = function () { return this.add(t, i, r), this.vertices.push(s), this.vertices.push(a), this.vertices.push(o), this }, this.update_geo = function (e) { var i = e.attributes.a_position_rw; for (t = 0; t < i.data.length; t++)i.data[t] = this.vertices.data[t]; i.needs_update = !0 }, this.build = function () { var i = new e.geometry.geometry_data; for (i.add_attribute("a_position_rw", { data: new Float32Array(this.vertices.length), item_size: 3 }), t = 0; t < this.vertices.length; t++)i.attributes.a_position_rw.data[t] = this.vertices.data[t]; return i.num_items = this.vertices.length / 3, n.calc_bounds(i, i.attributes.a_position_rw.data, i.attributes.a_position_rw.data.length, 3), this.clear(), i }, this }, n.create = function (t) { var i = t.vertex_size || 3, r = new e.geometry.geometry_data; if (t.vertices && (r.add_attribute("a_position_rw", { data: t.vertices, item_size: i }), r.num_items = t.vertices.length / i), t.normals && r.add_attribute("a_normal_rw", { data: t.normals, item_size: i }), t.uvs && r.add_attribute("a_uv_rw", { data: t.uvs, item_size: 2 }), t.colors && r.add_attribute("a_color_rw", { data: t.colors, item_size: 4 }), t.attr) for (var s in t.attr) r.add_attribute(s, t.attr[s]); return r.attributes.a_position_rw && n.calc_bounds(r, r.attributes.a_position_rw.data, r.attributes.a_position_rw.data.length, 3), r }, n.merge = function (t) { var i, r, s, a = {}, o = 0; for (r in t[0].attributes) i = t[0].attributes[r], a[r] = { __size: 0, __datas: [], item_size: i.item_size, divisor: i.divisor }; var _ = new e.geometry.geometry_data; _.subs = []; var l = 0, u = 0; t.forEach(function (t) { for (r in t.index_data && (o += t.index_data.length), t.attributes) a[r] && (a[r].__size += t.attributes[r].data.length, a[r].__datas.push(t.attributes[r].data)), "a_position_rw" === r && (l = t.attributes[r].data.length / t.attributes[r].item_size, _.subs.push({ v_index: u, v_count: l }), u += l) }); var h = 0, c = 0; for (r in a) i = t[0].attributes[r], a[r].data = new Float32Array(a[r].__size), h = 0, a[r].__datas.forEach(function (t) { for (s = 0; s < t.length; s++)a[r].data[h++] = t[s] }), delete a[r].__size, delete a[r].__datas, _.add_attribute(r, a[r]); return o > 0 && (_.index_data = n.create_index_data(o), h = 0, c = 0, t.forEach(function (t, e) { for (s = 0; s < t.index_data.length; s++)_.index_data[h++] = _.subs[e].v_index + t.index_data[s]; _.subs[e].i_start = 4 * c, _.subs[e].i_count = t.index_data.length, c += t.index_data.length })), _.num_items = _.index_data.length, _ }, n.create_float32_ids = function (t) { for (var e = new Float32Array(t), i = 0; i < t; i++)e[i] = i; return e }, n.create_float32_timeline = function (t) { for (var e = new Float32Array(t), i = 0; i < t; i++)e[i] = i / t; return e }, n.to_distributed_geometry = function () { var t = new e.array, i = new e.array, r = new e.array, s = new e.array, a = { aabb: [], origin: [] }, o = 0, _ = 0; function l(e) { t.push(e.attributes.a_position_rw.data[o]).push(e.attributes.a_position_rw.data[o + 1]).push(e.attributes.a_position_rw.data[o + 2]), e.attributes.a_normal_rw && r.push(e.attributes.a_normal_rw.data[o]).push(e.attributes.a_normal_rw.data[o + 1]).push(e.attributes.a_normal_rw.data[o + 2]), e.attributes.a_uv_rw && (_ = o / 3 * 2, s.push(e.attributes.a_uv_rw.data[_]).push(e.attributes.a_uv_rw.data[_ + 1])) } return function (e, _) { i.clear(), r.clear(), s.clear(); var u, h = []; _.forEach(function (r) { if (t.clear(), r.length) r.forEach(function (t) { for (o = 3 * t.draw_offset; o < 3 * t.draw_offset + 3 * t.draw_count; o += 3)l(e) }); else for (o = 3 * r.draw_offset; o < 3 * r.draw_offset + 3 * r.draw_count; o += 3)l(e); n.calc_bounds(a, t.data, t.length, 3), u = r.length ? r[0] : r, Object.assign(u, { draw_offset: i.length / 3, draw_count: t.length / 3, origin: [a.origin[0], a.origin[1], a.origin[2]] }), h.push(u), !1 !== u.center_pivot && n.center_pivot(a, 1, 1, 1, 0, 0, 0, t.data, t.length, 3), i.append_other(t) }); var c = n.create({ vertices: i.float32Array(), normals: r.length > 0 ? r.float32Array() : void 0, uvs: s.length > 0 ? s.float32Array() : void 0 }); return c.distribution = h, c } }(), n }), e.geometry.shapes.from_gltf = (r = { MODE_POINTS: 0, MODE_LINES: 1, MODE_LINE_LOOP: 2, MODE_LINE_STRIP: 3, MODE_TRIANGLES: 4, MODE_TRIANGLE_STRIP: 5, MODE_TRIANGLE_FAN: 6, TYPE_BYTE: 5120, TYPE_UNSIGNED_BYTE: 5121, TYPE_SHORT: 5122, TYPE_UNSIGNED_SHORT: 5123, TYPE_UNSIGNED_INT: 5125, TYPE_FLOAT: 5126, COMP_SCALAR: 1, COMP_VEC2: 2, COMP_VEC3: 3, COMP_VEC4: 4, COMP_MAT2: 4, COMP_MAT3: 9, COMP_MAT4: 16 }, n = function (t, e) { var i = t.accessors[e], n = t.bufferViews[i.bufferView], s = function (t, e) { var i = t.buffers[e]; if (null != i.dView) return i; if ("data:" != i.uri.substr(0, 5)) return i; for (var r = i.uri.indexOf("base64,") + 7, n = window.atob(i.uri.substr(r)), s = new DataView(new ArrayBuffer(n.length)), a = 0; a < n.length; a++)s.setUint8(a, n.charCodeAt(a)); return i.dView = s, i }(t, n.buffer), a = (i.byteOffset || 0) + (n.byteOffset || 0), o = 0, _ = null, l = null; switch (i.componentType) { case r.TYPE_FLOAT: _ = Float32Array, l = "getFloat32"; break; case r.TYPE_SHORT: _ = Int16Array, l = "getInt16"; break; case r.TYPE_UNSIGNED_SHORT: _ = Uint16Array, l = "getUint16"; break; case r.TYPE_UNSIGNED_INT: _ = Uint32Array, l = "getUint32"; break; case r.TYPE_UNSIGNED_BYTE: _ = Uint8Array, l = "getUint8"; break; default: return console.log("ERROR processAccessor", "componentType unknown", i.componentType), null }o = null != n.byteStride ? n.byteStride * i.count : i.count * r["COMP_" + i.type] * _.BYTES_PER_ELEMENT; for (var u = _.BYTES_PER_ELEMENT, h = o / u, c = new _(h), d = 0, m = 0; m < h; m++)d = a + m * u, c[m] = s.dView[l](d, !0); return { data: c, max: i.max, min: i.min, count: i.count, compLen: r["COMP_" + i.type] } }, function (t) { console.log(t); var i = []; return t.meshes.forEach(function (s) { for (var a, o, _ = 0; _ < s.primitives.length; _++) { o = (a = s.primitives[_]).attributes, itm = { mode: null != a.mode ? a.mode : r.MODE_TRIANGLES, indices: null, vertices: null, normals: null, texcoord: null, joints: null, weights: null, armature: null }, itm.vertices = n(t, o.POSITION), null != a.indices && (itm.indices = n(t, a.indices)), null != o.NORMAL && (itm.normals = n(t, o.NORMAL)), null != o.WEIGHTS_0 && (itm.weights = n(t, o.WEIGHTS_0)), null != o.JOINTS_0 && (itm.joints = n(t, o.JOINTS_0)), console.log(itm); var l = e.geometry.geometry_data.create({ vertices: itm.vertices.data, normals: itm.normals ? itm.normals.data : void 0 }); itm.indices && l.set_indices(itm.indices.data), i.push(l) } }), i }), e.geometry.shapes.cube = function (t) { (t = t || {}).size = t.size || 1; var r = t.width || t.size, n = t.height || t.size, s = t.depth; void 0 === s && (s = t.size); var a, o, _, l, u, h, c, d, m, p, f, g, v = t.divs || 1, w = Math.floor(t.divs_x) || v, x = Math.floor(t.divs_y) || v, y = Math.floor(t.divs_z) || v, b = i.vec3(), E = [], A = [], z = [], T = [], M = 0; function L(t, e, i, r, n, s, v, w, x, y) { for (a = s / x, o = v / y, _ = s / 2, l = v / 2, u = w / 2, h = x + 1, c = y + 1, d = 0, p = 0; p < c; p++)for (g = p * o - l, m = 0; m < h; m++)f = m * a - _, b[t] = f * r, b[e] = g * n, b[i] = u, A.push(b[0], b[1], b[2]), b[t] = 0, b[e] = 0, b[i] = w > 0 ? 1 : -1, z.push(b[0], b[1], b[2]), T.push(m / x), T.push(p / y), d += 1; for (p = 0; p < y; p++)for (m = 0; m < x; m++) { var L = M + m + h * p, I = M + m + h * (p + 1), S = M + (m + 1) + h * (p + 1), R = M + (m + 1) + h * p; E.push(L, I, R), E.push(I, S, R) } M += d } L(2, 1, 0, -1, -1, s, n, r, y, x), L(2, 1, 0, 1, -1, s, n, -r, y, x), L(0, 2, 1, 1, 1, r, s, n, w, y), L(0, 2, 1, 1, -1, r, s, -n, w, y), L(0, 1, 2, 1, -1, r, n, s, w, x), L(0, 1, 2, -1, -1, r, n, -s, w, x); var I = new e.geometry.geometry_data; return I.add_attribute("a_position_rw", { data: new Float32Array(A) }), I.add_attribute("a_normal_rw", { data: new Float32Array(z) }), I.add_attribute("a_uv_rw", { data: new Float32Array(T), item_size: 2 }), I.add_attribute("a_tangent_rw", { data: new Float32Array(A.length / 3 * 4), item_size: 4 }), I.set_indices(E), I.shape_type = "cube", e.geometry.geometry_data.calc_tangents(I), e.geometry.geometry_data.calc_bounds(I, I.attributes.a_position_rw.data, I.attributes.a_position_rw.data.length, 3), I }, e.geometry.shapes.plane = function (t) { (t = t || {}).size = t.size || 1, width = t.width || t.size, height = t.height || t.size, t.divs = t.divs || 1, t.divsX = t.divsX || t.divs, t.divsY = t.divsY || t.divs, divs_x = t.divsX, divs_y = t.divsY; var i, r, n = width / 2, s = height / 2, a = Math.floor(divs_x), o = Math.floor(divs_y), _ = a + 1, l = o + 1, u = width / a, h = height / o, c = (divs_x + 1) * (divs_y + 1), d = new e.geometry.geometry_data; d.add_attribute("a_position_rw", { data: new Float32Array(3 * c), item_size: 3 }); var m = null, p = null; d.add_attribute("a_normal_rw", { data: new Float32Array(3 * c), item_size: 3 }), m = d.attributes.a_normal_rw.data, d.add_attribute("a_uv_rw", { data: new Float32Array(2 * c), item_size: 2 }), p = d.attributes.a_uv_rw.data, d.add_attribute("a_tangent_rw", { data: new Float32Array(4 * c), item_size: 4 }), d.index_data = e.geometry.geometry_data.create_index_data(a * o * 6), d.index_needs_update = !0, d.num_items = d.index_data.length, d.shape_type = "plane"; var f, g, v, w, x = d.attributes.a_position_rw.data, y = d.index_data, b = 0, E = 0; for (r = 0; r < l; r++) { var A = r * h - s; for (i = 0; i < _; i++) { var z = i * u - n; x[3 * E + 0] = z, x[3 * E + 1] = -A, x[3 * E + 2] = 0, null !== m && (m[3 * E + 0] = 0, m[3 * E + 1] = 0, m[3 * E + 2] = 1), null !== p && (p[2 * E + 0] = i / a, p[2 * E + 1] = 1 - r / o), E++ } } for (b = 0, r = 0; r < o; r++)for (i = 0; i < a; i++)f = i + _ * r, g = i + _ * (r + 1), v = i + 1 + _ * (r + 1), w = i + 1 + _ * r, y[b++] = f, y[b++] = g, y[b++] = w, y[b++] = g, y[b++] = v, y[b++] = w; return e.geometry.geometry_data.calc_tangents(d), e.geometry.geometry_data.calc_bounds(d, d.attributes.a_position_rw.data, d.attributes.a_position_rw.data.length, 3), d }, e.geometry.shapes.sphere = (s = i.vec3(), o = i.vec3(), function (t) { (t = t || {}).rad = t.rad || 1, t.divs = t.divs || 8, t.divsX = t.divsX || t.divs, t.divsY = t.divsY || t.divs; var r, n, a = t.radX || t.rad, _ = t.radY || t.rad, l = t.radZ || t.rad, u = Math.max(3, Math.floor(t.divsX)), h = Math.max(2, Math.floor(t.divsY)), c = void 0 !== t.phiStart ? t.phiStart : 0, d = void 0 !== t.phiLength ? t.phiLength : 2 * Math.PI, m = void 0 !== t.thetaStart ? t.thetaStart : 0, p = void 0 !== t.thetaLength ? t.thetaLength : Math.PI, f = m + p, g = 0, v = [], w = (u + 1) * (h + 1), x = new e.geometry.geometry_data; x.add_attribute("a_position_rw", { data: new Float32Array(3 * w), item_size: 3 }); var y = null, b = null; x.add_attribute("a_normal_rw", { data: new Float32Array(3 * w), item_size: 3 }), y = x.attributes.a_normal_rw.data, x.add_attribute("a_uv_rw", { data: new Float32Array(2 * w), item_size: 2 }), b = x.attributes.a_uv_rw.data, x.add_attribute("a_tangent_rw", { data: new Float32Array(4 * w), item_size: 4 }), x.index_data = e.geometry.geometry_data.create_index_data(6 * w), x.num_items = x.index_data.length, x.index_needs_update = !0, x.shape_type = "sphere"; var E = x.attributes.a_position_rw.data, A = x.index_data, z = 0, T = 0; for (n = 0; n <= h; n++) { var M = [], L = n / h, I = 0 == n ? .5 / u : n == h ? -.5 / u : 0; for (r = 0; r <= u; r++) { var S = r / u; o[0] = -a * Math.cos(c + S * d) * Math.sin(m + L * p), o[1] = _ * Math.cos(m + L * p), o[2] = l * Math.sin(c + S * d) * Math.sin(m + L * p), E[3 * T + 0] = o[0], E[3 * T + 1] = o[1], E[3 * T + 2] = o[2], null !== y && (i.vec3.normalize(s, o), y[3 * T + 0] = s[0], y[3 * T + 1] = s[1], y[3 * T + 2] = s[2]), null !== b && (b[2 * T + 0] = S + I, b[2 * T + 1] = 1 - L), T++, M.push(g++) } v.push(M) } for (z = 0, n = 0; n < h; n++)for (r = 0; r < u; r++) { var R = v[n][r + 1], F = v[n][r], k = v[n + 1][r], G = v[n + 1][r + 1]; (0 !== n || m > 0) && (A[z++] = R, A[z++] = F, A[z++] = G), (n !== h - 1 || f < Math.PI) && (A[z++] = F, A[z++] = k, A[z++] = G) } return e.geometry.geometry_data.calc_tangents(x), e.geometry.geometry_data.calc_bounds(x, x.attributes.a_position_rw.data, x.attributes.a_position_rw.data.length, 3), x }), e.geometry.shapes.terrain = function () { var t, i = 1200, r = new Uint8Array(0), n = new Float32Array(0), s = {}, a = i / 2, o = 0; function _(t, e) { return o = r[(e + a) * i + (t + a)] } for (var l = 1; l <= 1024;)s[l] = { i: 0, list: [] }, l *= 2; function u(e, n, s) { r[t = (n + a) * i + (e + a)] = Math.min(r[t], s) } a = (i = 2056) / 2, t = i * i, r.length < t && (r = new Uint8Array(t), n = new Float32Array(4 * t)); var h, c, d, m, f, g, v, w, y = new Float32Array(6e5), b = 0, E = 0, A = new Float32Array(2e5), T = 4, M = 16, L = 2; function I(t, e) { return g[e * v + t] } var S = function () { var t, e, n, s, _ = 0, l = [-1, 1, -.75, 1, -.5, 1, -.25, 1, 0, 1, .25, 1, .5, 1, .75, 1, 1, 1, 1, .75, 1, .5, 1, .25, 1, 0, 1, -.25, 1, -.5, 1, -.75, 1, -1, .75, -1, .5, -1, .25, -1, 0, -1, -.25, -1, -.5, -1, -.75, -1, -1, -1, -1, -.75, -1, -.5, -1, -.25, -1, 0, -1, .25, -1, .5, -1, .75, -1, 1], h = []; h[16] = !0, h[32] = !0, h[48] = !0, h[64] = !0; var c = l.length; return function (d, m, p, f) { for (t = l[0], e = l[1], _ = f; _ < c;)o = r[(m + (s = l[_ + 1]) * p + a) * i + (d + (n = l[_]) * p + a)], (h[_] || o < p) && (w = d + t * p, x = m + e * p, E = d + n * p, A = m + s * p, u(g = d, v = m, z = p), y[b] = g, y[b + 2] = v, b += 6, u(w, x, z), y[b] = w, y[b + 2] = x, b += 6, u(E, A, z), y[b] = E, y[b + 2] = A, b += 6, t = n, e = s), _ += f; var g, v, w, x, E, A, z } }(), R = new Float32Array(1024), F = 0, k = 0, G = 0, N = !0, C = !1; function P(u, P, q, D) { for (g = P, E = 0, function t(e, i, r, n, s) { h = I(e, i), c = I(e - r, i - r), d = I(e + r, i - r), m = I(e + r, i + r), f = I(e - r, i + r); var a = E; return y[a] = Math.max(Math.abs(.5 * (c + d) - h), Math.abs(.5 * (f + m) - h), Math.abs(.5 * (c + f) - h), Math.abs(.5 * (d + m) - h)), n > -1 && (y[n + s] = a), r > T && (E += 5, r *= .5, y[a] = Math.max(y[a], t(e - r, i - r, r, a, 1), t(e + r, i - r, r, a, 2), t(e - r, i + r, r, a, 3), t(e + r, i + r, r, a, 4))), y[a] }(w = (v = q) / 2, w, w, -1, 0), k = 0; k < E;)A[k] = y[k++]; b = 0, r.fill(255), function (t, e, i, r, n) { var a = 0; for (R[F = 0] = t, R[F + 1] = e, R[F + 2] = i, R[F + 3] = a, F += 4; F > 0;)t = R[F -= 4], e = R[F + 1], i = R[F + 2], a = R[F + 3], G = r, i > M || i > T && n[a] > G ? (i *= .5, R[F] = t + i, R[F + 1] = e + i, R[F + 2] = i, R[F + 3] = n[a + 4], R[F += 4] = t - i, R[F + 1] = e + i, R[F + 2] = i, R[F + 3] = n[a + 3], R[F += 4] = t + i, R[F + 1] = e - i, R[F + 2] = i, R[F + 3] = n[a + 2], R[F += 4] = t - i, R[F + 1] = e - i, R[F + 2] = i, R[F + 3] = n[a + 1], F += 4) : (p = s[i], p.list[p.i++] = t, p.list[p.i++] = e) }(w, w, w, D, A), function () { for (l = T, C = !1; l <= M;) { for (p = s[l], k = 0, j = p.i; k < j;)x = p.list[k++], z = p.list[k++], fd = 16, N && l >= T && (C = !1, _(x - l, z) < l ? C = !0 : _(x + l, z) < l ? C = !0 : _(x, z - l) < l ? C = !0 : _(x, z + l) < l && (C = !0), C && (fd = l / o, fd < 16 ? fd = Math.max(2, 8 / fd) : fd = 2, fd = Math.min(L, fd))), S(x, z, l, fd); l *= 2 } }(), function (e, s, o, _, u) { for (k = e, l = M; k < s;)x = y[k], z = y[k + 2], _xx = x * u + o, _zz = z * u + _, t = (_zz + a) * i + (_xx + a), 222 !== r[t] ? (r[t] = 222, n[t *= 4] = I(x, z), nx = I(x - l, z) - I(x + l, z), ny = 2 * l, nz = I(x, z - l) - I(x, z + l), _fp = nx * nx + ny * ny + nz * nz, _fp > 0 && (_fp = 1 / Math.sqrt(_fp)), nx *= _fp, ny *= _fp, nz *= _fp, n[t + 1] = nx, n[t + 2] = ny, n[t + 3] = nz) : t *= 4, y[k + 1] = n[t], y[k + 3] = n[t + 1], y[k + 4] = n[t + 2], y[k + 5] = n[t + 3], y[k] = _xx, y[k + 2] = _zz, k += 6 }(0, b, 0, 0, 1); var O = u.attributes.a_position_rw; O.data = new Float32Array(b / 6 * 8); var U = 0; for (k = 0; k < b; k += 6)O.data[U] = y[k], O.data[U + 1] = y[k + 1], O.data[U + 2] = y[k + 2], O.data[U + 3] = y[k + 3], O.data[U + 4] = y[k + 4], O.data[U + 5] = y[k + 5], O.data[U + 6] = O.data[U] / v, O.data[U + 7] = O.data[U + 2] / v, U += 8; u.num_items = U / 8, O.data_length = U, O.needs_update = !0, e.geometry.geometry_data.calc_bounds(u, O.data, O.data.length, 8) } return function (t) { var i = new e.geometry.geometry_data; if (i.add_attribute("a_position_rw", { item_size: 3, data: new Float32Array(0), stride: 32 }), i.add_attribute("a_normal_rw", { item_size: 3, stride: 32, offset: 12 }), i.add_attribute("a_uv_rw", { item_size: 2, stride: 32, offset: 24 }), t.url) { var r = t.divisor || 1; e.load_working_image_data(t.url, function (e, n, s) { for (var a = new Float32Array((t.size + 1) * (t.size + 1)), o = 0; o < e.length / 4; o++)a[o] = e[4 * o] / r; P(i, a, t.size, t.details || 4) }, t.size, t.size) } return i } }(), e.geometry.shapes.obj = function () { var i, r, n, s, a, o, _, l = e.define(function (t) { return t.clear = function () { this.indices.clear(), this.normal.clear(), this.texture.clear() }, function () { this.indices = new e.array, this.texture = new e.array, this.normal = new e.array, this.vindex = 0 } }), u = [], h = new t.object_pooler(function () { return new l }), c = new e.array, d = 3, m = new e.array, p = 2, f = new e.array, g = new e.array, v = new e.array, w = new e.array, x = new e.array; function y(t, e) { e = (e - 1) * d, g.push(c.data[e]).push(c.data[e + 1]).push(c.data[e + 2]) } function b(t, e) { e = (e - 1) * d, w.push(f.data[e]).push(f.data[e + 1]).push(f.data[e + 2]) } function E(t, e) { e = (e - 1) * p, v.push(m.data[e]).push(m.data[e + 1]) } return { extract_mesh: function (t, i) { for (n = t.obj_meta.meshes[i], g.clear(), w.clear(), r = 3 * n.draw_offset; r < 3 * n.draw_offset + 3 * n.draw_count; r += 3)g.push(t.attributes.a_position_rw.data[r]).push(t.attributes.a_position_rw.data[r + 1]).push(t.attributes.a_position_rw.data[r + 2]), w.push(t.attributes.a_normal_rw.data[r]).push(t.attributes.a_normal_rw.data[r + 1]).push(t.attributes.a_normal_rw.data[r + 2]); var s = e.geometry.geometry_data.create({ vertices: g.float32Array(), normals: w.float32Array() }), a = [s.origin[0], s.origin[1], s.origin[2]]; return s.center_pivot(1, 1, 1, 0, 0, 0), s.origin = a, s }, parse: function (t, l) { var A = { materials: [], meshes: [] }; if (x.push("").push(0), l) { var z = {}; l.split("\n").forEach(function (t) { z = function (t, e, i) { if (-1 != (a = e.indexOf("#")) && (e = e.substring(0, a)), e = e.trim(), "newmtl" === (s = e.split(/\s+/))[0]) i.name && (t.materials.push(i), i = {}), i.name = s[1]; else if ("Kd" === s[0]) for (i.diffuse = [], r = 0; r < 3; ++r)i.diffuse.push(parseFloat(s[r + 1])); else if ("Ka" === s[0]) for (i.ambient = [], r = 0; r < 3; ++r)i.ambient.push(parseFloat(s[r + 1])); else if ("Ks" === s[0]) for (i.specular = [], r = 0; r < 3; ++r)i.specular.push(parseFloat(s[r + 1])); else "Ns" === s[0] ? i.specularExponent = parseFloat(s[1]) : "d" === s[0] || "Tr" === s[0] ? i.transparent = parseFloat(s[1]) : "illum" === s[0] ? i.illumMode = parseFloat(s[1]) : "map_Ka" === s[0] ? i.ambientMap = e.replace(s[0], "").trim() : "map_Kd" === s[0] ? i.diffuseMap = e.replace(s[0], "").trim() : "map_Ks" === s[0] ? i.specularMap = e.replace(s[0], "").trim() : "map_d" === s[0] ? i.alphaMat = e.replace(s[0], "").trim() : "map_bump" === s[0] || "bump" === s[0] ? i.bumpMap = e.replace(s[0], "").trim() : "disp" === s[0] && (i.displacementMap = e.replace(s[0], "").trim()); return i }(A, t, z) }), A.materials.push(z) } for (t.split("\n").forEach(function (t) { !function (t, e) { if (-1 != (a = e.indexOf("#")) && (e = e.substring(0, a)), e = e.trim(), "v" === (s = e.split(/\s+/))[0]) 3 == (d = s[4] ? 4 : 3) ? c.push(parseFloat(s[1])).push(parseFloat(s[2])).push(parseFloat(s[3])) : 4 == d && c.push(parseFloat(s[1])).push(parseFloat(s[2])).push(parseFloat(s[3])).push(parseFloat(s[4])); else if ("vt" === s[0]) 2 == (p = s[3] ? 3 : 2) ? m.push(parseFloat(s[1])).push(parseFloat(s[2])) : 3 == p && m.push(parseFloat(s[1])).push(parseFloat(s[2])).push(parseFloat(s[3])); else if ("vn" === s[0]) f.push(parseFloat(s[1])).push(parseFloat(s[2])).push(parseFloat(s[3])); else if ("f" === s[0]) for ((i = h.get()).clear(), u[u.length] = i, r = 1; r < s.length; ++r)o = s[r].indexOf("//"), _ = s[r].split(/\W+/), o > 0 ? (i.indices.push(parseInt(_[0])), i.normal.push(parseInt(_[1]))) : 1 === _.length ? i.indices.push(parseInt(_[0])) : 2 === _.length ? (i.indices.push(parseInt(_[0])), i.texture.push(parseInt(_[1]))) : 3 === _.length && (i.indices.push(parseInt(_[0])), i.texture.push(parseInt(_[1])), i.normal.push(parseInt(_[2]))); else if ("usemtl" === s[0]) if (0 === u.length) x.data[0] = s[1]; else { var n = s[1], l = u.length; x.push(n).push(l) } }(0, t) }), u.forEach(function (t) { t.vindex = g.length / 3, 3 === t.indices.length ? (y(0, t.indices.data[0]), y(0, t.indices.data[1]), y(0, t.indices.data[2])) : 4 === t.indices.length && (y(0, t.indices.data[0]), y(0, t.indices.data[1]), y(0, t.indices.data[2]), y(0, t.indices.data[0]), y(0, t.indices.data[2]), y(0, t.indices.data[3])), 3 === t.normal.length ? (b(0, t.normal.data[0]), b(0, t.normal.data[1]), b(0, t.normal.data[2])) : 4 === t.normal.length && (b(0, t.normal.data[0]), b(0, t.normal.data[1]), b(0, t.normal.data[2]), b(0, t.normal.data[0]), b(0, t.normal.data[2]), b(0, t.normal.data[3])), 3 === t.texture.length && (E(0, t.texture.data[0]), E(0, t.texture.data[1]), E(0, t.texture.data[2])) }), A.meshes = [], r = 0; r < x.length; r += 2)A.meshes.push({ mat: x.data[r], draw_offset: u[x.data[r + 1]].vindex, draw_count: 0 }); for (r = 0; r < A.meshes.length - 1; r++)(n = A.meshes[r]).draw_count = A.meshes[r + 1].draw_offset - n.draw_offset; (n = A.meshes[r]).draw_count = g.length / 3 - n.draw_offset; var T = e.geometry.geometry_data.create({ vertices: g.float32Array(), normals: w.length > 0 ? w.float32Array() : void 0, uvs: v.length > 0 ? v.float32Array() : void 0 }); for (T.obj_meta = A, r = 0; r < u.length; r++)h.free(u[r]); return u.length = 0, g.clear(), w.clear(), v.clear(), x.clear(), c.clear(), f.clear(), m.clear(), T } } }(), e.geometry.shapes.flat_quad = new e.geometry.geometry_data, e.geometry.shapes.flat_quad.add_attribute("a_position_rw", { item_size: 3, data: new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0]) }), e.geometry.shapes.flat_quad.num_items = 12, e.geometry.mesh = e.define(function (t, e) { return t.update_bounds = function (t, e) { i.aabb.transform_mat4(this.bounds, this.geometry.aabb, t), this.bounds_sphere = this.geometry.bounds_sphere * e.scale_world[0] }, function (t) { t = t || {}, e.apply(this, [t]), this.geometry = t.geometry || null, this.material = t.material || null, this.has_multi_materials = !1, this.material.length > 0 && (this.has_multi_materials = !0), this.draw_offset = t.draw_offset || 0, t.draw_count ? this.draw_count = t.draw_count : null !== this.geometry && (this.draw_count = this.geometry.num_items), this.item_type = 4, this.flags = t.flags || 0 } }, e.renderable), e.geometry.mesh.triangles = e.define(function (t, i) { var r = 0; return t.add = function (t, e, i, n, s, a, o, _, l) { return r = this.ii, this.vertices[r++] = t, this.vertices[r++] = e, this.vertices[r++] = i, this.vertices[r++] = n, this.vertices[r++] = s, this.vertices[r++] = a, this.vertices[r++] = o, this.vertices[r++] = _, this.vertices[r++] = l, this.ii = r, this.geometry.attributes.a_position_rw.data_length = r, this.geometry.attributes.a_position_rw.needs_update = !0, this.draw_count = r / 3, this }, t.render_list = function () { this.geometry.attributes.a_position_rw.needs_update && e.geometry.geometry_data.calc_normals(this.geometry) }, function (t) { if (t = t || {}, i.apply(this, [t]), t.max_triangles = t.max_triangles || 1e3, this.vertices = new Float32Array(9 * t.max_triangles), this.geometry = e.geometry.geometry_data.create({ vertices: this.vertices, normals: new Float32Array(this.vertices.length) }), this.material = t.material || null, this.ii = 0, this.draw_offset = 0, this.draw_count = 0, this.item_type = 4, this.flags = t.flags || 0, t.triangles) for (var r = 0; r < t.triangles.length; r++)this.add.apply(this, t.triangles[r]) } }, e.renderable) }(_FM.fin, _FM.ge, _FM.math), function (t, e, i) { e.cui = e.define(function (i, r) { var n, s; return i.bubble_event = function (t, e, i) { t && (t[e] ? t[e].apply(t, i) : this.bubble_event(t.parent, e, i)) }, i.set_mouse_position = function (t, e, i) { if (t = Math.floor(t), e = Math.floor(e), this.mouse_x = t, this.mouse_y = e, this.mouse_dx = this.mouse_x - this.last_mouse_x, this.mouse_dy = this.mouse_y - this.last_mouse_y, this.mouse_down_dx = this.mouse_x - this.mouse_down_x, this.mouse_down_dy = this.mouse_y - this.mouse_down_y, this.mouse_down_delta = Math.sqrt(this.mouse_down_dx * this.mouse_down_dx + this.mouse_down_dy * this.mouse_down_dy), this.mouse_delta = Math.sqrt(this.mouse_dx * this.mouse_dx + this.mouse_dy * this.mouse_dy), i === this.mouse_button && 0 === this.mouse_delta) return this.last_mouse_x = t, this.last_mouse_y = e, 1 === i && (this.mouse_down_x = t, this.mouse_down_y = e), !1; if (this.mouse_is_moving = !1, 0 !== this.mouse_delta && (this.mouse_is_moving = !0), this.mouse_click = !1, this.mouse_down && 0 === i && !this.last_mouse_draging && (this.mouse_is_moving || 0 !== this.mouse_down_delta || (this.mouse_click = !0, this.mouse_down = !1)), this.mouse_draging = !1, this.mouse_down && 0 !== this.mouse_down_delta && (this.mouse_draging = !0), 1 !== i || this.mouse_down || this.mouse_draging ? 0 === i && (this.mouse_down = !1) : (this.mouse_down = !0, this.mouse_down_x = t, this.mouse_down_y = e), this.last_mouse_x = t, this.last_mouse_y = e, this.mouse_button = i, this.mouse_down && !this.mouse_draging && (this.mouse_node_id = 0, this.mouse_hit_node(this.doc.body, this.doc)), 0 !== this.mouse_node_id) { var r = this.doc.nodes[this.mouse_node_id]; r && (this.mouse_draging ? r.on_mouse_draging ? r.on_mouse_draging(r, this.mouse_dx, this.mouse_dy) : this.bubble_event(r.parent, "on_mouse_draging", [r, this.mouse_dx, this.mouse_dy]) : this.mouse_down && !this.mouse_draging ? r.on_mouse_down && r.on_mouse_down(r, this.mouse_down_x, this.mouse_down_y) : this.mouse_click && (r.on_mouse_click ? r.on_mouse_click(r, this.mouse_x, this.mouse_y) : this.bubble_event(r.parent, "on_mouse_click", [r, this.mouse_x, this.mouse_y]))) } return this.last_mouse_draging = this.mouse_draging, this.mouse_draging = !1, 0 === this.mouse_button && (this.mouse_node_id = 0), !0 }, i.render_node = function (t, e, i) { if (e.render ? e.render(t, e, this, this.components[e.type]) : this.components[e.type].render(t, e, this), e.actual_height = e._height, e.actual_width = e._width, e.gx = e._x + i.gx, e.gy = e._y + i.gy, e.children) { var r; "hidden" === e.styles.overflow && (t.beginPath(), t.rect(e.styles.padding_left, e.styles.padding_top, e._width - (e.styles.padding_left + e.styles.padding_right), e._height - (e.styles.padding_top + e.styles.padding_bottom)), t.clip()), t.translate(-e.scroll_left, -e.scroll_top); for (var n = e.styles.padding_top, s = e.styles.padding_left, a = 0, o = 0; o < e.children.length; o++)(r = e.children[o]).styles.visibled && (s + r._width + e.styles.padding_right > e._width && (s = e.styles.padding_left, n += a), "absolute" === r.styles.position && (s = 0, n = 0), s += r._left + r.styles.margin_left, n += r._top + r.styles.margin_top, t.save(), t.translate(s, n + r.styles.margin_top), r._x = s - e.scroll_left, r._y = n + r.styles.margin_top - e.scroll_top, s += this.render_node(t, r, e), t.restore(), a = r.actual_height + r.styles.margin_bottom) } return e.initiated = !0, e.actual_width }, i.mouse_hit_node = function (t, e) { if (t.styles.visibled && this.mouse_x > t.gx && this.mouse_x < t.gx + t.actual_width && this.mouse_y > t.gy && this.mouse_y < t.gy + t.actual_height && (t.styles.mouse_events && (this.mouse_node_id = t.uuid), t.children)) for (var i = 0; i < t.children.length; i++)this.mouse_hit_node(t.children[i], t) }, i.get_node = function (t) { return this.doc.nodes_names[t] }, i.init_node = function (t, i) { if (!t.initiated) { t.uuid = e.guidi(), this.doc.nodes[t.uuid] = t, t.name = t.name || "n" + t.uuid, this.doc.nodes_names[t.name] = t, t.document = i.document ? i.document : i, t.scroll_left = t.scroll_left || 0, t.scroll_top = t.scroll_top || 0, t.type = t.type || "block", t.left = t.left || "0px", t.top = t.top || "0px", t.styles = t.styles || {}, t.styles.padding && (void 0 === t.styles.padding_left && (t.styles.padding_left = t.styles.padding), void 0 === t.styles.padding_right && (t.styles.padding_right = t.styles.padding), void 0 === t.styles.padding_top && (t.styles.padding_top = t.styles.padding), void 0 === t.styles.padding_bottom && (t.styles.padding_bottom = t.styles.padding)), this.components[t.type].init && this.components[t.type].init(t, i, this), t.height = t.height || "100%", t.width = t.width || "100%"; var r = i._width - (i.styles.padding_left + i.styles.padding_right), s = i._height - (i.styles.padding_top + i.styles.padding_bottom); for (var a in t.left.indexOf("%") > 0 ? t._left = parseFloat(t.left) / 100 * r : t._left = parseFloat(t.left), t.top.indexOf("%") > 0 ? t._top = parseFloat(t.top) / 100 * s : t._top = parseFloat(t.top), t.width.indexOf("%") > 0 ? t._width = parseFloat(t.width) / 100 * r : t._width = parseFloat(t.width), t.parent = i, t.height.indexOf("%") > 0 ? t._height = parseFloat(t.height) / 100 * s : t._height = parseFloat(t.height), t._x = 0, t._y = 0, this.styles) void 0 === t.styles[a] && (t.styles[a] = this.styles[a]); if (t.on_init && t.on_init(t, i), t.styles.background_color.join && (n.images_loader.load(t.styles.background_color[0], [n.background_pattern_creator, t, this, t.styles.background_color[1] || "repeat", t.styles.background_color[2]]), t.styles.background_color = "transparent"), t.initiated = !0, t.children) for (var o = 0; o < t.children.length; o++)t.children[o].index = o, this.init_node(t.children[o], t) } }, i.display_document = function (t) { if (t ? this.doc = t : t = this.doc, t._width = this.canv.width, t._height = this.canv.height, t.gx = 0, t.gy = 0, !t.body.initiated) { for (var e in n.components) this.components[e] = n.components[e]; t.styles = this.styles, this.doc.nodes = {}, this.doc.nodes_names = {}, this.init_node(t.body, t) } this.canv.ctx.clearRect(0, 0, this.canv.width, this.canv.height), this.render_node(this.canv.ctx, t.body, t), this.canv.ctx.fillStyle = "rgba(10,10,10,0.37)", this.canv.ctx.fillRect(this.mouse_x - 3, this.mouse_y - 3, 6, 6) }, (n = function (i) { i = i || {}, t.merge_object({ width: 512, height: 512 }, i, !0), this.components = {}, this.canv = e.create_canvas(i.width, i.height), this.mouse_node_id = 0, this.mouse_x = -10, this.mouse_y = -10, this.last_mouse_x = 0, this.last_mouse_y = 0, this.mouse_dx = 0, this.mouse_dy = 0, this.styles = { font: "arial", font_size: 12, text_valign: "top", text_align: "left", background_color: "transparent", background_alpha: 1, foreground_color: "black", margin_left: 0, margin_right: 0, margin_top: 0, margin_bottom: 0, padding_left: 0, padding_right: 0, padding_top: 0, padding_bottom: 0, overflow: "visible", position: "relative", mouse_events: !0, visibled: !0, border_size: 0, border_type: "outset", border_color: "transparent", focus_rect: !1 }, this.doc = null }).load_images = {}, n.load_image = function (t) { if (n.load_images[t]) return n.load_images[t]; var e = new Image; return e.src = t, n.load_images[t] = e, e }, n.background_pattern_creator = (s = e.create_canvas(1, 1), function (t, e, i, r, n) { n = n || 64, s.set_size(n, n), s.ctx.drawImage(t, 0, 0, n, n), e.styles.background_color = i.canv.ctx.createPattern(s, r), i.needs_update = !0 }), n.images_loader = new e.bulk_image_loader(5), n.images_loader.onload = function (t, e) { var i = e[0]; e[0] = t, i.apply(this, e), n.images_loader.free(t) }, n.components = {}, n.define_component = function (t, e) { this.components[t] = e, e.ui = this }, n.define_component("block", { render: function (t, e, i) { "transparent" !== e.styles.background_color && (t.fillStyle = e.styles.background_color, t.globalAlpha = e.styles.background_alpha, t.fillRect(0, 0, e._width, e._height)), t.globalAlpha = 1, e.styles.border_size > 0 && (t.lineWidth = e.styles.border_size, t.strokeStyle = e.styles.border_color, t.strokeRect(0, 0, e._width, e._height), "outset" === e.styles.border_type ? (t.strokeStyle = "rgba(110,110,110,0.5)", t.beginPath(), t.moveTo(0, e._height), t.lineTo(0, 0), t.lineTo(e._width, 0), t.stroke(), t.strokeStyle = "rgba(50,50,50,0.5)", t.beginPath(), t.moveTo(0, e._height), t.lineTo(e._width, e._height), t.lineTo(e._width, 0), t.stroke()) : "inset" === e.styles.border_type && (t.strokeStyle = "rgba(50,50,50,0.5)", t.beginPath(), t.moveTo(0, e._height), t.lineTo(0, 0), t.lineTo(e._width, 0), t.stroke(), t.strokeStyle = "rgba(110,110,110,0.5)", t.beginPath(), t.moveTo(0, e._height), t.lineTo(e._width, e._height), t.lineTo(e._width, 0), t.stroke())), t.lineWidth = 1, e.uuid === i.mouse_node_id && i.mouse_down && e.styles.focus_rect && (t.fillStyle = "rgba(0,0,0,0.25)", t.fillRect(0, 0, e._width, e._height)) } }), n.define_component("scroll-panel", { init: function (t, e, i) { t.styles.overflow = "hidden", t.on_mouse_draging = function (t, e, i) { this.scroll_top -= i, this.scroll_top = Math.max(this.scroll_top, 0) } }, render: function (t, e, i) { n.components.block.render(t, e, i) } }), n.define_component("text", { init: function (t, e, i) { void 0 === t.height && (t.height = "20px"), void 0 === t.styles.mouse_events && (t.styles.mouse_events = !1), void 0 === t.styles.background_color && (t.styles.background_color = "transparent") }, render: function (t, e, i) { t.font = e.styles.font_size + "px " + e.styles.font, e._text !== e.text && (e._text_m = t.measureText(e.text), e._text = e.text, e._height = Math.max(e._height, e._text_m.actualBoundingBoxDescent + e.styles.padding_top + e.styles.padding_bottom), e._width = Math.max(e._width, e._text_m.width + e.styles.padding_left + e.styles.padding_right)); var r = e.styles.padding_left, s = e.styles.padding_top; n.components.block.render(t, e, i), t.textAlign = e.styles.text_align, t.textBaseline = e.styles.text_valign, t.fillStyle = e.styles.foreground_color, "center" === e.styles.text_align && (r += .5 * e._width), "middle" === e.styles.text_valign && (s += .5 * e._height + .35 * e._text_m.actualBoundingBoxDescent), t.fillText(e.text, r, s) } }), n.define_component("button", { init: function (t, e, i) { t.styles.text_align = "center", t.styles.text_valign = "middle", void 0 === t.styles.border_size && (t.styles.border_size = 3) }, render: function (t, e, i) { i.mouse_down && e.uuid === i.mouse_node_id ? (e.styles.border_type = "inset", e.styles.padding_left = 2, e.styles.padding_top = 2) : (e.styles.padding_left = 0, e.styles.padding_top = 0, e.styles.border_type = "outset"), n.components.text.render(t, e, i) } }), n.define_component("hslider", { init: function (t, e, i) { t.value = t.value || 50, t.min = t.min || 0, t.max = t.max || 100, void 0 === t.height && (t.height = "20px"), t.label_padding = t.label_padding || 0, t.children = [{ on_init: function (t, e) { e.trail_width = e._width - e.label_padding - 10, t.parent.per = (t.parent.value - t.parent.min) / (t.parent.max - t.parent.min), t._left = e.trail_width * e.per }, width: "10px", styles: { background_color: "rgba(30,30,30,0.75)", position: "absolute", margin_top: 0, border_size: 1 }, on_mouse_draging: function (t, e, i) { t._left += e, t._left < 0 && (t._left = 0), t._left > t.parent.trail_width && (t._left = t.parent.trail_width), t.parent.per = t._left / t.parent.trail_width, t.parent.value = t.parent.min + (t.parent.max - t.parent.min) * t.parent.per } }] }, render: function (t, e, i) { n.components.block.render(t, e, i), t.fillStyle = "rgba(40,40,40,0.5)", t.fillRect(0, .5 * e._height - 2, e.trail_width + 10, 6), e.label_padding > 0 && (t.textBaseline = "middle", t.font = "12px " + e.styles.font, t.textAlign = "right", t.fillStyle = e.styles.foreground_color, t.fillText(parseInt(e.value), e._width - 2, .5 * e._height)) } }), n.define_component("checkbox", { init: function (t, e, i) { void 0 === t.checked && (t.checked = !1), t.styles.text_valign = "middle", void 0 === t.height && (t.height = "20px"), t.on_mouse_down = function () { this.checked = !this.checked, this.on_checked && this.on_checked(this.checked) } }, render: function (t, e, i) { e.styles.padding_left = e._height, n.components.text.render(t, e, i), t.strokeStyle = e.styles.foreground_color, t.strokeRect(4, 4, e._height - 8, e._height - 8), e.checked && (t.fillStyle = e.styles.foreground_color, t.fillRect(6, 6, e._height - 12, e._height - 12)) } }), n.define_component("listbox", { init: function (t, e, i) { n.components["scroll-panel"].init(t, e, i), t.item_height = t.item_height || 20, t.item_count = 50, console.log("node", t) }, render: function (t, e, i) { n.components["scroll-panel"].render(t, e, i), t.textAlign = "left", t.textBaseline = "middle"; var r, s = 0, a = 0; for (t.fillStyle = e.styles.foreground_color; s < e.items.length && (r = e.items[s++], t.fillText(r, 2, a + e.styles.font_size), !((a += e.item_height) > e._height));); } }), n.define_component("label-field", { init: function (t, e, i) { t.height = t.height || "25px", t.field.width = t.field_size || "60%", t.field.styles = { margin_top: 2 }, t.styles.border_size = 1, t.children = [{ type: "text", width: "40%", styles: { text_valign: "middle", font_size: 10 }, text: t.label }, t.field] }, render: function (t, e, i) { n.components.block.render(t, e, i) } }), n }), e.cui.mesh = e.define(function (t, r) { return t.on_render = function (t) { this.ui.needs_update && (this.update_document(), this.ui.needs_update = !1), this.is_picked && (t.is_locked = !0, this.mouse_controller.set_mouse_ray(), 0 !== this.mouse_controller.mouse_delta && i.utils.ray_plane_intersection(this.mouse_int_point, this.mouse_controller.mouse_ray_start, this.mouse_controller.mouse_ray_end, this.world_position, this.fw_vector) && this.set_mouse_position(this.mouse_int_point, this.mouse_controller.mouse_buttons), 0 === this.mouse_controller.mouse_buttons && (this.is_picked = !1, t.is_locked = !1, this.ui.set_mouse_position(-10, -10, 0) && this.update_document())) }, t.set_mouse_position = function (t, e) { this.mesh_version !== this.version && (this.mesh_version = this.version, i.mat4.inverse(this.imatrix_world, this.matrix_world)), i.vec3.transform_mat4(t, t, this.imatrix_world), t[0] = t[0] / this.width, t[1] = t[1] / this.height, t[0] += .5, t[1] += .5, t[1] = 1 - t[1], this.ui.set_mouse_position(t[0] * this.ui.canv.width, t[1] * this.ui.canv.height, e) && this.update_document() }, t.update_bounds = function (t, e) { i.aabb.transform_mat4(this.bounds, this.geometry.aabb, t), this.bounds_sphere = this.geometry.bounds_sphere * e.scale_world[0] }, t.update_document = function () { this.ui.display_document(), this.material.texture.source = this.ui.canv, this.material.texture.needs_update = !0, this.on_document_update.params[0] = this.ui, this.on_document_update.trigger_params() }, t.set_document = function (t) { this.ui.display_document(t), this.material.texture.needs_update = !0 }, function (t) { t = t || {}, r.apply(this, [t]), this.width = t.width / 100, this.height = t.height / 100, this.mouse_controller = t.mouse_controller, this.geometry = e.geometry.shapes.plane({ width: this.width, height: this.height }), this.material = new e.shading.material({ ambient: [1, 1, 1], specular: [0, 0, 0], transparent: .95 }), this.ui = new e.cui(t), this.material.texture = e.webgl.texture.from_size(t.width, t.height), this.material.texture.source = this.ui.canv, this.material.texture.needs_update = !0, this.material.flags += 2048, this.material.texture.parameters[10242] = 33071, this.material.texture.parameters[10243] = 33071, this.material.texture.enable_linear_interpolation(), this.ui.canv.ctx.transform(1, 0, 0, -1, 0, this.ui.canv.height), this.draw_offset = 0, this.draw_count = this.geometry.num_items, this.item_type = 4, this.flags = t.flags || 0, this.mesh_version = -1, this.imatrix_world = i.mat4(), this.flags += 2048, this.mouse_int_point = i.vec3(), this.on_document_update = new e.event(this, [null]) } }, e.renderable) }(_FM.fin, _FM.ge, _FM.math), function t(e, r, n) { r.renderer = r.define(function (s, a) { var o, _ = r.webgl.shader.create_chunks_lib("/*chunk-global-render-system-lighting*/\n\n<?for(var i= 0;i<param('fws_num_lights');i++) {?>\n\tuniform mat4 u_light_material_rw<?=i?>;\n\tuniform mat4 u_light_matrix_rw<?=i?>;\n<?}?>\n\n\n\n\n\nfloat fws_distance_to_light;\nfloat fws_lambertian;\nfloat fws_specular;\nfloat fws_attenuation;\nfloat fws_intensity;\nfloat fws_spot_light_calc;\nfloat fws_spot_theta;\nfloat fws_spot_light_status;\n\nvec3 fws_total_light;\nvec3 fws_light_value;\n\nvec3 fws_lighting(\n\tmat4 fws_object_material,\n\tmat4 fws_light_material,\n\tvec3 fws_vertex_position, \n\tvec3 fws_vertex_normal,\n\tvec3 fws_direction_to_eye,\n\tvec3 fws_direction_to_light, vec3 fws_direction_from_light) {\n\n\tfws_distance_to_light = length(fws_direction_to_light);\n\n\t\n\n\tfws_direction_to_light = normalize(fws_direction_to_light);\n\tfws_lambertian = max(dot(fws_direction_to_light, fws_vertex_normal), 0.0);\n\n\n\tfws_lambertian =dot(fws_direction_to_light, fws_vertex_normal);\n\n\tfws_intensity = fws_light_material[0].w;\n\t\n\tfws_attenuation = (fws_light_material[3].x + fws_light_material[3].y * fws_distance_to_light\n\t\t+ fws_light_material[3].z * (fws_distance_to_light * fws_distance_to_light)) + fws_light_material[3].w;\n\n\tfws_spot_light_status = step(0.000001, fws_light_material[1].w);\t\n\tfws_spot_theta = dot(fws_direction_to_light, fws_direction_from_light);\n\tfws_spot_light_calc = clamp((fws_spot_theta - fws_light_material[2].w) / (fws_light_material[1].w - fws_light_material[2].w), 0.0, 1.0);\n\tfws_intensity *= (fws_spot_light_status * (step(fws_light_material[1].w, fws_spot_theta) * fws_spot_light_calc))\n\t\t+ abs(1.0 - fws_spot_light_status);\n\n\t\n\tfws_specular = pow(max(dot(normalize(fws_direction_to_light.xyz + fws_direction_to_eye), fws_vertex_normal), 0.0), fws_object_material[2].w) * fws_lambertian;\n\tfws_specular *= fws_intensity * step(0.0, fws_lambertian);\n\t\n\t\n\n\n\tfws_light_value = (fws_light_material[0].xyz * fws_object_material[0].xyz) +\n\t\t(fws_object_material[1].xyz * fws_lambertian * fws_light_material[1].xyz * fws_intensity) +\n\t\t(fws_object_material[2].xyz * fws_specular * fws_light_material[2].xyz);\n\n\t\tfws_light_value=max(fws_light_value,0.0);\n\n\n\t\t\n\treturn (fws_light_value / fws_attenuation);\n\n\n}\n\n\nvec3 get_render_system_lighting(\n\tmat4 object_material_rw,\n\tvec3 fws_vertex,\n\tvec3 fws_normal,\n\tvec3 fws_direction_to_eye){\n\n\tfws_total_light=vec3(0.0);\n\t<?for (var i = 0;i < param('fws_num_lights');i++) {?>\n\t\t\tfws_total_light += fws_lighting(\n\t\t\t\tobject_material_rw,\n\t\t\t\tu_light_material_rw<?=i?>,\n\t\t\t\tfws_vertex, fws_normal, fws_direction_to_eye,\n\t\t\t\tu_light_matrix_rw<?=i?>[3].xyz - fws_vertex,\n\t\t\t u_light_matrix_rw<?=i?>[2].xyz);\n\t<?}?>\n\n\treturn fws_total_light;\n}\n\n\n\n\n/*chunk-global-render-system-fog-effect*/\n\nuniform vec3 u_fog_params_rw;\nuniform vec4 u_fog_color_rw;\nfloat get_linear_fog_factor(float eye_dist)\n{  \n   return clamp( (u_fog_params_rw.y - eye_dist) /\n            (u_fog_params_rw.y - u_fog_params_rw.x ), 0.0, 1.0 );\n}\n\nvec4 mix_fog_color(vec4 frag_color){\n\tfloat fog_density=0.0005;\n    const float LOG2=1.442695;\n    float z=gl_FragCoord.z/gl_FragCoord.w;\n    float fog_factor=exp2(-fog_density*fog_density*z*z*LOG2);\n    fog_factor=clamp(fog_factor,0.0,1.0);\n\treturn mix(u_fog_color_rw,frag_color,fog_factor);\n}\n\n\n/*chunk-textured-quad*/\nattribute vec2 a_position_rw;\nuniform vec4 u_pos_size;\nconst vec2 madd=vec2(0.5,0.5);\nvarying vec2 v_uv_rw;\nvoid vertex()\n{\ngl_Position = vec4((a_position_rw.xy*u_pos_size.zw)+u_pos_size.xy,0.0,1.0);\t\n\tv_uv_rw = a_position_rw.xy*madd+madd;  \n\tv_uv_rw.y=1.0-v_uv_rw.y;\n}\n<?=chunk('precision')?>\nuniform sampler2D u_texture_rw;\nvarying vec2 v_uv_rw;\nvoid fragment(void)\n{\t\ngl_FragColor = texture2D(u_texture_rw, v_uv_rw);\t\n}\n\n/*chunk-render-shadow-map*/\n\n<?=chunk('precision')?>\nuniform sampler2D u_texture_rw;\nvarying vec2 v_uv_rw;\nvoid fragment(void) {\t\t\t\n\n\tif(texture2D(u_texture_rw, v_uv_rw).a<0.02) discard;\t\n\tgl_FragColor=vec4(0.85);\t\n}\n\n\n/*chunk-receive-shadow*/\nuniform mat4 u_light_camera_matrix_rw;\nvarying vec4 v_shadow_light_vertex_rw;\n\nvoid vertex(){\n\tsuper_vertex();\t\n\tv_shadow_light_vertex_rw = u_light_camera_matrix_rw * v_position_rw;\n}\n\n\n<?=chunk('precision')?>\n<?=chunk('shadow-sampling')?>\n\n\nvarying vec3 v_normal_rw;\nvarying vec4 v_shadow_light_vertex_rw;\nuniform sampler2D u_texture_rw;\nuniform sampler2D u_shadow_map_rw;\nuniform vec4 u_shadow_params_rw;\nuniform vec4 u_shadow_attenuation_rw;\n\nuniform vec3 u_light_pos_rw;\nuniform vec3 u_light_dir_rw;\n\nvarying vec2 v_uv_rw;\nvarying vec4 v_position_rw;\n\n\nfloat get_shadow_sample() {\t\t\n\n\n\n\tfloat f=texture2D(u_texture_rw, v_uv_rw).a;\t\t\n\t\n\n\tvec3 shadow_map_coords =v_shadow_light_vertex_rw.xyz/v_shadow_light_vertex_rw.w;\n\tf*=step(-(dot(v_normal_rw,normalize(u_light_pos_rw - v_position_rw.xyz))),0.0);\n\n\tshadow_map_coords.xyz = shadow_map_coords.xyz * 0.5 + 0.5;\n\n\tf*=step(shadow_map_coords.x,1.0)*step(shadow_map_coords.y,1.0)*step(shadow_map_coords.z,1.0);\n\tf*=step(0.0,shadow_map_coords.x)*step(0.0,shadow_map_coords.y)*step(0.0,shadow_map_coords.y);\n\t\n\n\tvec3 fws_direction_to_light=(u_light_pos_rw.xyz-v_position_rw.xyz);\t\t\t\n\n\t\n\tfloat fws_distance_to_light=length(fws_direction_to_light)*0.99;\n\tfws_direction_to_light=normalize(fws_direction_to_light);\n\n\t\t\n\tfloat fws_spot_theta = dot(fws_direction_to_light,u_light_dir_rw);\n\tfloat fws_spot_light_calc = clamp((fws_spot_theta) / u_shadow_params_rw.w, 0.0, 1.0);\n\t\n\tf*=(step(1.0,fws_spot_light_calc));\n\n\t\n\tfloat fws_attenuation = (u_shadow_attenuation_rw.y * fws_distance_to_light\n\t\t+ u_shadow_attenuation_rw.z * (fws_distance_to_light * fws_distance_to_light));\n\t\t\n\n\n\n\tf/=(max(fws_attenuation,0.0));\n\n\tf*=(u_shadow_attenuation_rw.w/fws_distance_to_light);\n\n\tf*=(u_shadow_params_rw.x*(u_shadow_attenuation_rw.w/fws_distance_to_light));\n\t\n\tf=clamp(f,0.0,0.8);\n\n\treturn  ((f-sample_shadow_map_pcf(u_shadow_map_rw, shadow_map_coords.xy,\n\tshadow_map_coords.z-u_shadow_params_rw.z ,vec2(u_shadow_params_rw.y))*f)\n\t*u_shadow_params_rw.x);\n\n\t\t\n}\n\n\nvoid fragment(void) {\t\ngl_FragColor = vec4((get_shadow_sample()));\n}"); s.gl_enable = function (t) { return 1 !== this.gl_states_flags[t] && (this.gl_states_flags[t] = 1, this.gl.enable(t), !0) }, s.gl_disable = function (t) { return 0 !== this.gl_states_flags[t] && (this.gl_states_flags[t] = 0, this.gl.disable(t), !0) }, s.gl_blendFunc = function (t, e) { return (this.gl_states.blendFunc0 !== t || this.gl_states.blendFunc1 !== e) && (this.gl_states.blendFunc0 = t, this.gl_states.blendFunc1 = e, this.gl.blendFunc(t, e), !0) }, s.gl_blendEquation = function (t) { this.gl_states.blendEQuation !== t && (this.gl_states.blendEQuation = t, this.gl.blendEquation(t)) }, s.gl_depthMask = function (t) { t !== this.gl_states.depthMask && (this.gl_states.depthMask = t, this.gl.depthMask(t)) }, s.gl_depthFunc = function (t) { t !== this.gl_states.depthFunc && (this.gl_states.depthFunc = t, this.gl.depthFunc(t)) }, s.gl_cullFace = function (t) { t !== this.gl_states.cullFace && (this.gl_states.cullFace = t, this.gl.cullFace(t)) }, s.gl_bindFramebuffer2 = function (t, e) { return e !== this.gl_states.framebuffer && (this.gl_states.framebuffer = e, this.gl.bindFramebuffer(t, e), !0) }, s.set_canvas_size = function (t, e) { this.render_width = t * this.pixel_ratio, this.render_height = e * this.pixel_ratio, this.canvas.width = this.render_width, this.canvas.height = this.render_height; var i = 0; for (i = 0; i < this.post_processes.length; i++)this.post_processes[i].resize(this.render_width, this.render_height); for (i = 0; i < this.render_targets.length; i++)this.render_targets[i].resize(this.render_width * this.render_targets[i].ratio, this.render_height * this.render_targets[i].ratio); this.on_canvas_size(this.render_width, this.render_height) }, s.on_canvas_size = function (t, e) { }, s.clear_screen = function () { return this.gl.clear(16640), this }, s.set_default_viewport = function () { return null === this.default_render_target ? (this.gl.bindFramebuffer(36160, this.frame_buffer_layer), null !== this.active_camera && this.gl.viewport(this.vp_left * this.render_width, this.vp_top * this.render_height, this.vp_width * this.render_width, this.vp_height * this.render_height)) : this.default_render_target.bind(), this }, s.use_geometry = function () { var t = null, e = 0, i = null, n = r.geometry.geometry_data; return s.activate_geometry_index_buffer = function () { var t, e, i, r, a; return s.reset_wireframe_index_buffer = function (s, _) { var l = []; for (l.length = 0, t = 0; t < _ - 1; t += 3)i = t + 0, r = t + 1, a = t + 2, l[e = l.length] = i, l[e + 1] = r, l[e + 2] = r, l[e + 3] = a, l[e + 4] = a, l[e + 5] = i; this.wireframe_index_buffer || (this.wireframe_index_buffer = o.gl_buffers.get(s)), s.bindBuffer(34963, this.wireframe_index_buffer), s.bufferData(34963, n.create_index_data(l), 35048), l.length = 0 }, s.bind_default_wireframe_indices = function () { this.wireframe_index_buffer || (this.reset_wireframe_index_buffer(null, 1e6), this.compile_attribute(this.default_color_attribute)), this.gl.bindBuffer(34963, this.wireframe_index_buffer) }, function (s, _) { if (s.index_data) { var l = this.gl; return s.index_needs_update && (null === s.index_buffer && (s.index_buffer = o.gl_buffers.get(l)), l.bindBuffer(34963, s.index_buffer), l.bufferData(34963, s.index_data, 35048)), _ ? s.index_needs_update || !s.w_index_data ? (function (s) { if (null !== s.index_buffer) for (s.w_index_data ? s.w_index_data.length < 2 * s.index_data.length && (s.w_index_data = ggeometry_data.create_index_data(2 * s.index_data.length)) : s.w_index_data = n.create_index_data(2 * s.index_data.length), e = 0, t = 0; t < s.index_data.length; t += 3)i = s.index_data[t + 0], r = s.index_data[t + 1], a = s.index_data[t + 2], s.w_index_data[e] = i, s.w_index_data[e + 1] = r, s.w_index_data[e + 2] = r, s.w_index_data[e + 3] = a, s.w_index_data[e + 4] = a, s.w_index_data[e + 5] = i, e += 6 }(s), s.w_index_buffer || (s.w_index_buffer = o.gl_buffers.get(l)), l.bindBuffer(34963, s.w_index_buffer), l.bufferData(34963, s.w_index_data, 35048)) : l.bindBuffer(34963, s.w_index_buffer) : l.bindBuffer(34963, s.index_buffer), s.index_needs_update = !1, !0 } return !!_ && (this.gl.bindBuffer(34963, this.wireframe_index_buffer), !0) } }(), s.update_geomerty_attribute = function (t, e) { if (null === e) return this.gl.disableVertexAttribArray(t), -1; var i = this.gl, r = 0; return i.enableVertexAttribArray(t), !0 === e.needs_update ? (null === e.buffer && (e.buffer = o.gl_buffers.get(i)), i.bindBuffer(34962, e.buffer), i.bufferData(34962, e.data, e.buffer_type, e.data_offset, e.data_length), r = 1, e.version += 1, e.needs_update = !1) : null !== e.buffer && i.bindBuffer(34962, e.buffer), i.vertexAttribPointer(t, e.item_size, e.data_type, !1, e.stride, e.offset), i.ANGLE_instanced_arrays.vertexAttribDivisorANGLE(t, e.divisor), r }, s.compile_geometry = (s.compile_attribute = function (t) { if (!t.compiled) return t.stride = t.stride || 0, t.offset = t.offset || 0, t.needs_update = t.needs_update || !1, t.array = t.array || null, t.data_type = t.data_type || 5126, t.buffer_type = t.buffer_type || 35044, t.version = t.version || 1, t.divisor = t.divisor || 0, t.array = t.array || null, t.data_offset = t.data_offset || 0, t.data_length = t.data_length || 0, t.data && (t.data_length = t.data.length, null !== t.buffer && void 0 !== t.buffer || (t.buffer = o.gl_buffers.get(this.gl)), this.gl.bindBuffer(34962, t.buffer), this.gl.bufferData(34962, t.data, t.buffer_type, t.data_offset, t.data_length)), t.compiled = !0, t }, s.use_geometry_attribute = function (t, e) { this.compile_attribute(e), this.update_geomerty_attribute(t, e) }, function (t, e) { if (!e.compiled) { for (aid in this.wireframe_index_buffer || (this.reset_wireframe_index_buffer(t, 1e6), this.compile_attribute(this.default_color_attribute)), e.attributes) this.compile_attribute(e.attributes[aid]); e.attributes.a_color_rw = e.attributes.a_color_rw || this.default_color_attribute, e.index_data && (null === e.index_buffer && (e.index_buffer = o.gl_buffers.get(t)), t.bindBuffer(34963, e.index_buffer), t.bufferData(34963, e.index_data, 35048)), e.compiled = !0 } }), function (r) { if (r.compiled || this.compile_geometry(this.gl, r), (t = this.active_shader).used_geo_id !== r.uuid) for (t.used_geo_id = r.uuid, e = 0; e < t.all_attributes.length; e++)i = t.all_attributes[e], r.attributes[i.name] ? this.update_geomerty_attribute(i.location, r.attributes[i.name]) : this.update_geomerty_attribute(i.location, null) } }(), s.use_shader = function (t, e) { var i; return this.last_shader_id != t.uuid && (null !== this.active_shader && this.active_shader.exit(this), t.compiled || r.webgl.shader.compile(this.gl, t, this.shader_parameters), this.gl.useProgram(t.program), t.enter(this), (i = t.uniforms.u_fog_params_rw) && (i.params[i.params_length] = this.fog_params, i.func.apply(t.gl, i.params)), (i = t.uniforms.u_fog_color_rw) && (i.params[i.params_length] = this.u_fog_color, i.func.apply(t.gl, i.params)), (i = t.uniforms.u_timer_rw) && (i.params[i.params_length] = this.timer, i.func.apply(t.gl, i.params)), this.active_shader = t, this.active_shader.camera_version = -1, this.last_shader_id = t.uuid, this.active_shader.used_geo_id = -100, !0) }; var l, u, h, c, d, m, f, g, v, w, x, y, b, E, A, z, T, M, L, I, S, R, F, k, G, N, C, P, q, j, D, O, U, B, H, X, K, Z, V, W, Q, Y, $, J, tt, et, it, rt, nt, st, at, ot, _t, lt, ut, ht, ct, dt = [34070, 34069, 34072, 34071, 34074, 34073]; s.update_texture = function (t) { var e = this.gl; if (null === t.gl_texture && (t.gl_texture = o.gl_textures.get(e)), e.bindTexture(t.target, t.gl_texture), 34067 === t.target) for (i = 0; i < t.source.length; i++)e.texImage2D(dt[i], 0, t.format, t.format, texture.format_type, t.source[i]); else null !== t.source && (t.source.src || t.source.getContext) ? e.texImage2D(t.target, 0, t.format, t.format, t.format_type, t.source) : e.texImage2D(t.target, 0, t.format, t.width, t.height, 0, t.format, t.format_type, t.source); for (p in t.parameters) e.texParameteri(t.target, p, t.parameters[p]); return t.generate_mipmap && e.generateMipmap(t.target), e.bindTexture(t.target, null), t.needs_update = !1, t.free_source(), t }, s.use_texture = function (t, e) { null !== t ? (t.needs_update && this.update_texture(t), null !== t.gl_texture ? (t.last_used_time = this.timer, this.texture_slots[e] !== t.uuid && (this.texture_slots[e] = t.uuid, this.gl.activeTexture(33984 + e), this.gl.bindTexture(t.target, t.gl_texture))) : this.use_texture(this.default_texture, e)) : this.use_texture(this.default_texture, e) }, s.use_direct_texture = function (t, e) { this.gl.activeTexture(33984 + e), this.gl.bindTexture(t.target, t.gl_texture) }, s.draw_textured_quad = (l = { item_size: 2, data: new Float32Array([-1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1]) }, u = r.webgl.shader.parse(_["textured-quad"]), h = n.vec4(), function (t, e, i, r, n) { h[0] = e, h[1] = i, h[2] = r, h[3] = n, this.use_geometry_attribute(0, l), this.use_shader(u), u.set_uniform("u_pos_size", h), this.gl_disable(2929), this.gl_disable(2884), this.use_texture(t, 0), this.gl.drawArrays(4, 0, 6) }), s.draw_full_quad = function () { this.gl.bindBuffer(34962, this.full_quad), this.gl.enableVertexAttribArray(0), this.gl.vertexAttribPointer(0, 2, 5126, !1, 0, 0), this.gl.drawArrays(4, 0, 6) }, s.apply_post_processes = function () { this.post_process_input = this.default_render_target.color_texture, this.post_target = this.default_render_target.swap, this.gl_disable(2929); for (var t = 0; t < this.post_processes.length; t++)post_process = this.post_processes[t], post_process.enabled && (post_process.apply(this, this.post_process_input, this.post_target), this.post_process_input = this.post_target.color_texture, this.post_target = this.post_target.swap); this.output_to_screen && (this.render_target_id = -1, this.gl.bindFramebuffer(36160, null), this.use_shader(r.effects.post_process.shader), this.gl.viewport(this.render_width * this.vp_left, this.render_height * this.vp_top, this.render_width * this.vp_width, this.render_height * this.vp_height), this.use_direct_texture(this.post_process_input, 0), this.draw_full_quad(), this.has_error = this.gl.getError(), this.has_error !== this.gl.NO_ERROR && console.error(this.has_error)), this.gl_enable(2929) }, s.render_light_shadows = (nt = {}, st = null, at = n.quat(), ot = n.vec4(), _t = n.vec3(), lt = n.vec3(), ut = n.vec4(), ht = 0, ct = 0, function (t, e, i, s) { st = function (t, e) { return (st = nt[e]) || ((st = new r.webgl.render_target(t, e, e)).attach_color(), st.attach_depth(), nt[e] = st), st }(this, t.shadow_map_size); var a, o, l, u = null, h = 0, p = 0, dt = (this.gl, !1); for (t.camera || (t.camera = { view: n.mat4(), view_inverse: n.mat4(), projection: n.mat4(), view_projection: n.mat4(), light_version: -1, camera_version: -1, version: 0 }, 0 === t.light_type ? (p = 2 * t.shadow_camera_distance, z = t.camera.projection, b = 1 / (-p - p), E = 1 / (-p - p), A = 1 / (.75 * -p - 5 * p), z[0] = -2 * b, z[1] = 0, z[2] = 0, z[3] = 0, z[4] = 0, z[6] = 0, z[7] = 0, z[8] = 0, z[9] = 0, z[5] = -2 * E, z[10] = 2 * A, z[11] = 0, z[12] = (-p + p) * b, z[13] = (p + -p) * E, z[14] = (5 * p + .75 * -p) * A, z[15] = 1) : 1 === t.light_type ? (p = 2.6179938779914944, z = t.camera.projection, b = 1 / Math.tan(p / 2), z[0] = b / 1, z[1] = 0, z[2] = 0, z[3] = 0, z[4] = 0, z[5] = b, z[6] = 0, z[7] = 0, z[8] = 0, z[9] = 0, z[11] = -1, z[12] = 0, z[13] = 0, z[15] = 0, 8 * t.range != null && 8 * t.range != 1 / 0 ? (b = 1 / (.5 - 8 * t.range), z[10] = (8 * t.range + .5) * b, z[14] = 2 * t.range * 8 * .5 * b) : (z[10] = -1, z[14] = -1), p = -1.5707963267948966, y = at, c = Math.sin(.5 * p), d = Math.sin(0), m = Math.sin(0), g = Math.cos(.5 * p), v = Math.cos(0), w = Math.cos(0), y[0] = c * v * w - g * d * m, y[1] = g * d * w + c * v * m, y[2] = g * v * m - c * d * w, y[3] = g * v * w + c * d * m, c = y[0], d = y[1], m = y[2], f = y[3], (x = c * c + d * d + m * m + f * f) > 0 && (x = 1 / Math.sqrt(x)), y[0] = c * x, y[1] = d * x, y[2] = m * x, y[3] = f * x, z = t.camera.view, b = (j = at)[0], E = j[1], A = j[2], T = j[3], S = b * (M = b + b), R = b * (L = E + E), F = b * (I = A + A), k = E * L, G = E * I, N = A * I, C = T * M, P = T * L, q = T * I, z[0] = 1 - (k + N), z[1] = R + q, z[2] = F - P, z[3] = 0, z[4] = R - q, z[5] = 1 - (S + N), z[6] = G + C, z[7] = 0, z[8] = F + P, z[9] = G - C, z[10] = 1 - (S + k), z[11] = 0) : 2 === t.light_type && (z = t.camera.projection, b = 1 / Math.tan(t.view_angle / 2), z[0] = b / 1, z[1] = 0, z[2] = 0, z[3] = 0, z[4] = 0, z[5] = b, z[6] = 0, z[7] = 0, z[8] = 0, z[9] = 0, z[11] = -1, z[12] = 0, z[13] = 0, z[15] = 0, 4 * t.range != null && 4 * t.range != 1 / 0 ? (b = 1 / (.1 - 4 * t.range), z[10] = (4 * t.range + .1) * b, z[14] = 2 * t.range * 4 * .1 * b) : (z[10] = -1, z[14] = -.2)), t.camera.world_position = new Float32Array(t.camera.view.buffer, 48, 3)), ((u = t.camera).light_version !== t.version || dt) && (1 === t.light_type ? (u.view[12] = t.world_position[0], u.view[13] = t.world_position[1], u.view[14] = t.world_position[2]) : (z = u.view, D = t.matrix_world, z[0] = D[0], z[1] = D[1], z[2] = D[2], z[3] = D[3], z[4] = D[4], z[5] = D[5], z[6] = D[6], z[7] = D[7], z[8] = D[8], z[9] = D[9], z[10] = D[10], z[11] = D[11], z[12] = D[12], z[13] = D[13], z[14] = D[14], z[15] = D[15]), dt = !0), (u.camera_version !== e.version || dt) && (0 === t.light_type && (p = -t.shadow_camera_distance, u.world_position[0] = e.fw_vector[0] * p + e.world_position[0], u.world_position[1] = e.fw_vector[1] * p + e.world_position[1], u.world_position[2] = e.fw_vector[2] * p + e.world_position[2]), dt = !0), dt && (z = u.view_inverse, D = u.view, b = D[0], E = D[1], A = D[2], T = D[3], O = D[4], U = D[5], B = D[6], H = D[7], X = D[8], K = D[9], Z = D[10], V = D[11], W = D[12], Q = D[13], Y = D[14], $ = D[15], (J = (S = b * U - E * O) * (it = Z * $ - V * Y) - (R = b * B - A * O) * (et = K * $ - V * Q) + (F = b * H - T * O) * (tt = K * Y - Z * Q) + (k = E * B - A * U) * (q = X * $ - V * W) - (G = E * H - T * U) * (P = X * Y - Z * W) + (N = A * H - T * B) * (C = X * Q - K * W)) && (J = 1 / J, z[0] = (U * it - B * et + H * tt) * J, z[1] = (A * et - E * it - T * tt) * J, z[2] = (Q * N - Y * G + $ * k) * J, z[3] = (Z * G - K * N - V * k) * J, z[4] = (B * q - O * it - H * P) * J, z[5] = (b * it - A * q + T * P) * J, z[6] = (Y * F - W * N - $ * R) * J, z[7] = (X * N - Z * F + V * R) * J, z[8] = (O * et - U * q + H * C) * J, z[9] = (E * q - b * et - T * C) * J, z[10] = (W * G - Q * F + $ * S) * J, z[11] = (K * F - X * G - V * S) * J, z[12] = (U * P - O * tt - B * C) * J, z[13] = (b * tt - E * P + A * C) * J, z[14] = (Q * R - W * k - Y * S) * J, z[15] = (X * k - K * R + Z * S) * J), z = u.view_projection, D = u.projection, rt = u.view_inverse, b = D[0], E = D[1], A = D[2], T = D[3], O = D[4], U = D[5], B = D[6], H = D[7], X = D[8], K = D[9], Z = D[10], V = D[11], W = D[12], Q = D[13], Y = D[14], $ = D[15], S = rt[0], R = rt[1], F = rt[2], k = rt[3], z[0] = S * b + R * O + F * X + k * W, z[1] = S * E + R * U + F * K + k * Q, z[2] = S * A + R * B + F * Z + k * Y, z[3] = S * T + R * H + F * V + k * $, S = rt[4], R = rt[5], F = rt[6], k = rt[7], z[4] = S * b + R * O + F * X + k * W, z[5] = S * E + R * U + F * K + k * Q, z[6] = S * A + R * B + F * Z + k * Y, z[7] = S * T + R * H + F * V + k * $, S = rt[8], R = rt[9], F = rt[10], k = rt[11], z[8] = S * b + R * O + F * X + k * W, z[9] = S * E + R * U + F * K + k * Q, z[10] = S * A + R * B + F * Z + k * Y, z[11] = S * T + R * H + F * V + k * $, S = rt[12], R = rt[13], F = rt[14], k = rt[15], z[12] = S * b + R * O + F * X + k * W, z[13] = S * E + R * U + F * K + k * Q, z[14] = S * A + R * B + F * Z + k * Y, z[15] = S * T + R * H + F * V + k * $), u.camera_version = e.version, u.light_version = t.version, u.version = e.version + t.version, st.bind(), this.gl_cullFace(1028), ht = 0, h = 0; h < i.length; h++)if (0 != (16 & (a = i[h]).material.flags)) { if (t.light_type > 0 && n.vec3.calc_distance(u.view[12], u.view[13], u.view[14], a.world_position[0], a.world_position[1], a.world_position[2]) - a.bounds_sphere > 3 * t.range) continue; ht++, o = a.material.shader, t.light_type > -1 && (o.default_shadow_map || (o.default_shadow_map = o.extend(_["render-shadow-map"], { fragment: !1 }), o.default_shadow_map.shadow_shader = !0), o = o.default_shadow_map), this.use_shader(o) && ((l = o.uniforms.u_view_projection_rw).params[l.params_length] = u.view_projection, l.func.apply(o.gl, l.params)), (l = o.uniforms.u_model_rw).params[l.params_length] = a.matrix_world, l.func.apply(o.gl, l.params), this.use_geometry(a.geometry), a.material.render_mesh(this, o, a) } if (ct = ht, s.length > 0) { for (this.gl_enable(3042), this.gl_blendFunc(770, 771), ht = 0, h = 0; h < s.length; h++)if (0 != (16 & (a = s[h]).material.flags)) { if (t.light_type > 0 && n.vec3.calc_distance(u.view[12], u.view[13], u.view[14], a.world_position[0], a.world_position[1], a.world_position[2]) - a.bounds_sphere > 3 * t.range) continue; ht++, o = a.material.shader, t.light_type > -1 && (o.default_shadow_map || (o.default_shadow_map = o.extend(_["render-shadow-map"], { fragment: !1 }), o.default_shadow_map.shadow_shader = !0), o = o.default_shadow_map), this.use_shader(o) && ((l = o.uniforms.u_view_projection_rw).params[l.params_length] = u.view_projection, l.func.apply(o.gl, l.params)), (l = o.uniforms.u_model_rw).params[l.params_length] = a.matrix_world, l.func.apply(o.gl, l.params), this.use_geometry(a.geometry), a.material.render_mesh(this, o, a) } ct += ht } if (ot[0] = t.shadow_intensity, ot[1] = 1 / t.shadow_map_size, ot[2] = t.shadow_bias, lt[0] = t.matrix_world[8], lt[1] = t.matrix_world[9], lt[2] = t.matrix_world[10], ot[3] = Math.cos(.5 * t.view_angle), 0 === t.light_type ? (_t[0] = lt[0] * t.range, _t[1] = lt[1] * t.range, _t[2] = lt[2] * t.range) : (_t[0] = t.world_position[0], _t[1] = t.world_position[1], _t[2] = t.world_position[2]), this.gl_cullFace(1029), this.set_default_viewport(), ct > 0) { for (this.receive_shadow_count = 0, 1 === t.light_type ? (ut[0] = 0, ut[1] = 2 * (t.attenuation[0] + t.attenuation[1]), ut[2] = 2 * t.attenuation[2], ut[3] = .95 * t.range) : 2 === t.light_type ? (ut[0] = 0, ut[1] = .75 * t.attenuation[1], ut[2] = .5 * t.attenuation[2], ut[3] = t.range, ut[0] = 1, ut[1] = 0, ut[2] = 0, ut[3] = t.range) : (ut[0] = 1, ut[1] = 0, ut[2] = 0, ut[3] = t.range), this.gl_blendFunc(1, 1), this.fw_rendering_mode || (this.gl_enable(3042), this.gl_depthMask(!1), this.gl_depthFunc(514), this.fw_rendering_mode = !0), this.gl_blendEquation(32779), this.use_direct_texture(st.color_texture, 0), this.use_direct_texture(st.depth_texture, 4), h = 0; h < i.length; h++)if (0 != (32 & (a = i[h]).material.flags)) { if (t.light_type > 0 && n.vec3.calc_distance(u.view[12], u.view[13], u.view[14], a.world_position[0], a.world_position[1], a.world_position[2]) - a.bounds_sphere > 2 * t.range) continue; this.receive_shadow_count++, o = a.material.shader, t.light_type > -1 && (o.default_shadow_receiver || (o.default_shadow_receiver = o.extend(_["receive-shadow"], { fragment: !1 }), o.default_shadow_receiver.shadow_shader = !0), o = o.default_shadow_receiver), this.use_shader(o) && ((l = o.uniforms.u_view_projection_rw).params[l.params_length] = e.view_projection, l.func.apply(o.gl, l.params)), (l = o.uniforms.u_shadow_map_rw).params[l.params_length] = 4, l.func.apply(o.gl, l.params), (l = o.uniforms.u_light_camera_matrix_rw).params[l.params_length] = u.view_projection, l.func.apply(o.gl, l.params), (l = o.uniforms.u_light_pos_rw).params[l.params_length] = _t, l.func.apply(o.gl, l.params), (l = o.uniforms.u_light_dir_rw).params[l.params_length] = lt, l.func.apply(o.gl, l.params), (l = o.uniforms.u_shadow_params_rw).params[l.params_length] = ot, l.func.apply(o.gl, l.params), (l = o.uniforms.u_shadow_attenuation_rw).params[l.params_length] = ut, l.func.apply(o.gl, l.params), (l = o.uniforms.u_model_rw) && (l.params[l.params_length] = a.matrix_world, l.func.apply(o.gl, l.params)), this.use_geometry(a.geometry), a.material.render_mesh(this, o, a) } if (s.length > 0) for (this.gl_depthFunc(513), h = 0; h < s.length; h++)if (0 != (32 & (a = s[h]).material.flags)) { if (t.light_type > 0 && n.vec3.calc_distance(u.view[12], u.view[13], u.view[14], a.world_position[0], a.world_position[1], a.world_position[2]) - a.bounds_sphere > 2 * t.range) continue; this.receive_shadow_count++, o = a.material.shader, t.light_type > -1 && (o.default_shadow_receiver || (o.default_shadow_receiver = o.extend(_["receive-shadow"], { fragment: !1 }), o.default_shadow_receiver.shadow_shader = !0), o = o.default_shadow_receiver), this.use_shader(o) && ((l = o.uniforms.u_view_projection_rw).params[l.params_length] = e.view_projection, l.func.apply(o.gl, l.params)), (l = o.uniforms.u_shadow_map_rw).params[l.params_length] = 4, l.func.apply(o.gl, l.params), (l = o.uniforms.u_light_camera_matrix_rw).params[l.params_length] = u.view_projection, l.func.apply(o.gl, l.params), (l = o.uniforms.u_light_pos_rw).params[l.params_length] = _t, l.func.apply(o.gl, l.params), (l = o.uniforms.u_light_dir_rw).params[l.params_length] = lt, l.func.apply(o.gl, l.params), (l = o.uniforms.u_shadow_params_rw).params[l.params_length] = ot, l.func.apply(o.gl, l.params), (l = o.uniforms.u_shadow_attenuation_rw).params[l.params_length] = ut, l.func.apply(o.gl, l.params), (l = o.uniforms.u_model_rw) && (l.params[l.params_length] = a.matrix_world, l.func.apply(o.gl, l.params)), this.use_geometry(a.geometry), a.material.render_mesh(this, o, a) } this.gl_blendEquation(32774), this.fw_rendering_mode && (this.gl_disable(3042), this.gl_depthFunc(513), this.gl_depthMask(!0), this.fw_rendering_mode = !1) } }); var mt = n.vec4(), pt = n.mat4(); pt.fill(0), pt[3] = 0, pt[15] = .5; var ft = n.mat4(); return s.render_single_mesh = function (e, i) { (t.use_shader(i.material.shader) || update_shading_lights) && (shader = t.active_shader, update_shading_lights = !1, shader.camera_version !== e.version && (shader.camera_version = e.version, uni = shader.uniforms.u_view_projection_rw, uni && (uni.params[uni.params_length] = e.view_projection, uni.func.apply(shader.gl, uni.params)), uni = shader.uniforms.u_view_rw, uni && (uni.params[uni.params_length] = e.view_inverse, uni.func.apply(shader.gl, uni.params)), uni = shader.uniforms.u_view_fw, uni && (uni.params[uni.params_length] = e.fw_vector, uni.func.apply(shader.gl, uni.params)), uni = shader.uniforms.u_view_sd, uni && (uni.params[uni.params_length] = e.sd_vector, uni.func.apply(shader.gl, uni.params)), uni = shader.uniforms.u_view_up, uni && (uni.params[uni.params_length] = e.up_vector, uni.func.apply(shader.gl, uni.params)))), uni = shader.uniforms.u_model_rw, uni && (uni.params[uni.params_length] = i.matrix_world, uni.func.apply(shader.gl, uni.params)), t.use_geometry(i.geometry), i.material.render_mesh(t, shader, i) }, s.render_scene = function (t, e, i, r, n) { if (this.has_error === this.gl.NO_ERROR) { this.last_shader_id = -1, this.render_target_id = -1, this.active_shader = null, this.texture_slots[0] = -1, this.texture_slots[1] = -1, this.texture_slots[2] = -1, this.flat_meshes = e, this.opuque_meshes = i, this.transparent_meshes = r, this.active_camera = t; var s, a, o, _, l, u = 0, h = 0, c = !1, d = 0; if (this.gl, _ = this.active_shader, this.set_default_viewport(), this.clear_screen(), this.fw_rendering_mode && (this.gl_disable(3042), this.gl_depthFunc(513), this.gl_depthMask(!0), this.fw_rendering_mode = !1), i.length > 0) for (this.light_pass_count = 0, this.lights_batch_size = 0, u = 0; u < n.length; u++)if (o = n[u], this.shading_lights[this.lights_batch_size++] = o, c = this.lights_batch_size === this.fws_num_lights || u === n.length - 1) { for (s = 0; s < i.length; s++)if (a = i[s], !(this.light_pass_count >= a.material.light_pass_limit)) { if (this.use_shader(a.material.shader) || c) { for (c = !1, (_ = this.active_shader).camera_version !== t.version && (_.camera_version = t.version, (l = _.uniforms.u_view_projection_rw) && (l.params[l.params_length] = t.view_projection, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_rw) && (l.params[l.params_length] = t.view_inverse, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_fw) && (l.params[l.params_length] = t.fw_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_sd) && (l.params[l.params_length] = t.sd_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_up) && (l.params[l.params_length] = t.up_vector, l.func.apply(_.gl, l.params))), d = a.material.lights_count, total_lights = 0, -1 === d && (d = this.lights_batch_size), h = 0; h < d; h++)null != (o = this.shading_lights[h]) && (0 === o.light_type ? (mt[0] = o.world_position[0], mt[1] = o.world_position[1], mt[2] = o.world_position[2], o.world_position[0] = 99999 * o.matrix_world[8], o.world_position[1] = 99999 * o.matrix_world[9], o.world_position[2] = 99999 * o.matrix_world[10], o.attenuation[3] = 1) : o.attenuation[3] = 0, (l = _.uniforms["u_light_material_rw" + h]).params[l.params_length] = o.light_material, l.func.apply(_.gl, l.params), (l = _.uniforms["u_light_matrix_rw" + h]).params[l.params_length] = o.matrix_world, l.func.apply(_.gl, l.params), 0 === o.light_type && (o.world_position[0] = mt[0], o.world_position[1] = mt[1], o.world_position[2] = mt[2])); for (h = d; h < this.fws_num_lights; h++)(l = _.uniforms["u_light_material_rw" + h]) && (l.params[l.params_length] = pt, l.func.apply(_.gl, l.params)), (l = _.uniforms["u_light_matrix_rw" + h]) && (l.params[l.params_length] = ft, l.func.apply(_.gl, l.params)); mt[0] = t.world_position[0], mt[1] = t.world_position[1], mt[2] = t.world_position[2], mt[3] = this.lights_batch_size, (l = _.uniforms.u_eye_position_rw) && (l.params[l.params_length] = mt, l.func.apply(_.gl, l.params)) } (l = _.uniforms.u_model_rw) && (l.params[l.params_length] = a.matrix_world, l.func.apply(_.gl, l.params)), this.use_geometry(a.geometry), a.material.render_mesh(this, _, a) } this.lights_batch_size = 0, this.light_pass_count++, n.length > this.fws_num_lights && (this.gl_blendFunc(1, 1), this.fw_rendering_mode || (this.gl_enable(3042), this.gl_depthMask(!1), this.gl_depthFunc(514), this.fw_rendering_mode = !0)) } for (this.fw_rendering_mode && (this.gl_disable(3042), this.gl_depthFunc(513), this.gl_depthMask(!0), this.fw_rendering_mode = !1), s = 0; s < e.length; s++)a = e[s], this.use_shader(a.material.shader) && (_ = this.active_shader).camera_version !== t.version && (_.camera_version = t.version, (l = _.uniforms.u_view_projection_rw) && (l.params[l.params_length] = t.view_projection, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_rw) && (l.params[l.params_length] = t.view_inverse, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_fw) && (l.params[l.params_length] = t.fw_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_sd) && (l.params[l.params_length] = t.sd_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_up) && (l.params[l.params_length] = t.up_vector, l.func.apply(_.gl, l.params))), (l = _.uniforms.u_model_rw) && (l.params[l.params_length] = a.matrix_world, l.func.apply(_.gl, l.params)), this.use_geometry(a.geometry), a.material.render_mesh(this, _, a); for (u = 0; u < n.length; u++)(o = n[u]).cast_shadows && this.render_light_shadows(o, t, i, r), this.texture_slots[0] = -1; if (r.length > 0) for (this.fw_rendering_mode && (this.gl_disable(3042), this.gl_depthFunc(513), this.gl_depthMask(!0), this.fw_rendering_mode = !1), s = 0; s < r.length; s++)if (4 & (a = r[s]).material.flags) { if (this.light_pass_count >= a.material.light_pass_limit) continue; for (this.light_pass_count = 0, this.lights_batch_size = 0, u = 0; u < n.length; u++)if (o = n[u], this.shading_lights[this.lights_batch_size++] = o, c = this.lights_batch_size === this.fws_num_lights || u === n.length - 1) { if (this.use_shader(a.material.shader) || c) { for ((_ = this.active_shader).camera_version !== t.version && (_.camera_version = t.version, (l = _.uniforms.u_view_projection_rw) && (l.params[l.params_length] = t.view_projection, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_rw) && (l.params[l.params_length] = t.view_inverse, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_fw) && (l.params[l.params_length] = t.fw_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_sd) && (l.params[l.params_length] = t.sd_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_up) && (l.params[l.params_length] = t.up_vector, l.func.apply(_.gl, l.params))), (l = _.uniforms.u_model_rw) && (l.params[l.params_length] = a.matrix_world, l.func.apply(_.gl, l.params)), d = a.material.lights_count, total_lights = 0, -1 === d && (d = this.lights_batch_size), h = 0; h < d; h++)null != (o = this.shading_lights[h]) && (0 === o.light_type ? (mt[0] = o.world_position[0], mt[1] = o.world_position[1], mt[2] = o.world_position[2], o.world_position[0] = 99999 * o.matrix_world[8], o.world_position[1] = 99999 * o.matrix_world[9], o.world_position[2] = 99999 * o.matrix_world[10], o.attenuation[3] = 1) : o.attenuation[3] = 0, (l = _.uniforms["u_light_material_rw" + h]).params[l.params_length] = o.light_material, l.func.apply(_.gl, l.params), (l = _.uniforms["u_light_matrix_rw" + h]).params[l.params_length] = o.matrix_world, l.func.apply(_.gl, l.params), 0 === o.light_type && (o.world_position[0] = mt[0], o.world_position[1] = mt[1], o.world_position[2] = mt[2])); for (h = d; h < this.fws_num_lights; h++)(l = _.uniforms["u_light_material_rw" + h]) && (l.params[l.params_length] = pt, l.func.apply(_.gl, l.params)), (l = _.uniforms["u_light_matrix_rw" + h]) && (l.params[l.params_length] = ft, l.func.apply(_.gl, l.params)); mt[0] = t.world_position[0], mt[1] = t.world_position[1], mt[2] = t.world_position[2], mt[3] = this.lights_batch_size, (l = _.uniforms.u_eye_position_rw) && (l.params[l.params_length] = mt, l.func.apply(_.gl, l.params)), 0 === this.light_pass_count ? (this.gl_enable(3042), this.gl_blendFunc(770, 771), this.gl_cullFace(1028), this.use_geometry(a.geometry), a.material.render_mesh(this, _, a), this.gl_cullFace(1029), this.use_geometry(a.geometry), a.material.render_mesh(this, _, a)) : (this.gl_blendFunc(770, 1), this.use_geometry(a.geometry), a.material.render_mesh(this, _, a)) } this.lights_batch_size = 0, this.light_pass_count++, n.length > this.fws_num_lights && (this.gl_blendFunc(1, 1), this.fw_rendering_mode || (this.gl_enable(3042), this.gl_depthMask(!1), this.gl_depthFunc(514), this.fw_rendering_mode = !0)) } } else this.use_shader(a.material.shader), (_ = this.active_shader).camera_version !== t.version && (_.camera_version = t.version, (l = _.uniforms.u_view_projection_rw) && (l.params[l.params_length] = t.view_projection, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_rw) && (l.params[l.params_length] = t.view_inverse, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_fw) && (l.params[l.params_length] = t.fw_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_sd) && (l.params[l.params_length] = t.sd_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_up) && (l.params[l.params_length] = t.up_vector, l.func.apply(_.gl, l.params))), (l = _.uniforms.u_model_rw) && (l.params[l.params_length] = a.matrix_world, l.func.apply(_.gl, l.params)), this.gl_enable(3042), this.gl_blendFunc(770, 771), this.use_geometry(a.geometry), a.material.render_mesh(this, _, a); this.fw_rendering_mode && (this.gl_disable(3042), this.gl_depthFunc(513), this.gl_depthMask(!0), this.fw_rendering_mode = !1), this.set_default_viewport(), null !== this.active_shader && this.active_shader.exit(this), null !== this.default_render_target && this.apply_post_processes() } }, (o = function (t) { var i = (t = t || {}).canvas; i || (i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).setAttribute("style", "position:absolute;width:100%;height:100%;left:0;top:0;box-sizing: border-box;"), this.priority = 5e3; var s = (t = e.merge_object(t, { alpha: !1, depth: !0, stencil: !0, antialias: !1, premultipliedAlpha: !1, preserveDrawingBuffer: !1, xrCompatible: !0 })).context || i.getContext("webgl", t); if (this.shader_parameters = { fws_num_lights: t.lights_count_per_pass || 4 }, null === s) throw null !== i.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context."); this.pixel_ratio = t.pixel_ratio || window.devicePixelRatio, i.addEventListener("webglcontextlost", function () { console.log("webglcontextlost", this) }, !1), i.addEventListener("webglcontextrestored", function () { console.log("webglcontextrestored", this) }, !1), s.OES_vertex_array_object = s.getExtension("OES_vertex_array_object"), s.OES_standard_derivatives = s.getExtension("OES_standard_derivatives"), s.WEBGL_depth_texture = s.getExtension("WEBGL_depth_texture"), s.ANGLE_instanced_arrays = s.getExtension("ANGLE_instanced_arrays"), s.OES_element_index_uint = s.getExtension("OES_element_index_uint"), this.gl_states = { depthMask: !1, blendFunc0: -1, blendFunc1: -1, framebuffer: void 0 }, this.gl_states_flags = new Uint8Array(65536), this.gl = s, this.canvas = i, this.render_target_id = 0, this.render_target1 = new r.webgl.render_target(this, 10, 10), this.render_target1.attach_depth_buffer().attach_color(), this.render_target1.clear_buffer = !1, this.default_render_target = this.render_target1, this.render_target2 = new r.webgl.render_target(this, 10, 10), this.render_target2.attach_depth_buffer(this.render_target1.depth_buffer).attach_color(), this.render_target2.clear_buffer = !1, this.render_target1.swap = this.render_target2, this.render_target2.swap = this.render_target1, this.post_processes = [], this.render_targets = [this.render_target1, this.render_target2], this.texture_slots = [-1, -1, -1, -1, -1, -2, -1, -1, -1], this.texture_updates = [], this.default_texture = new r.webgl.texture, this.default_texture.needs_update = !0, this.update_texture(this.default_texture), this.gl_enable(2929), this.gl_cullFace(1029), this.gl_enable(2884), this.gl.clearColor(0, 0, 0, 1), this.full_quad = o.gl_buffers.get(s), s.bindBuffer(34962, this.full_quad), s.bufferData(34962, new Float32Array([-1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1]), 35044, 0, 12), this.fws_num_lights = this.shader_parameters.fws_num_lights, this.shading_lights = []; for (var a = 0; a < this.shader_parameters.fws_num_lights; a++)this.shading_lights[a] = null; this.has_error = 0, this.light_pass_count = 0, this.lights_batch_size = 0, this.active_camera = null, this.frame_buffer_layer = null, this.default_color_attribute = { name: "a_color_rw", item_size: 4, data: new Float32Array(18e5) }, this.vp_left = 0, this.vp_top = 0, this.vp_width = 1, this.vp_height = 1, this.sbs_display = !1, this.sbs_depth = 2, this.default_color_attribute.data.fill(1), this.is_renderer = !0, this.active_camera = null, this.fog_params = n.vec3(0, 0, 0), this.fog_color = n.vec4(.165, .165, .165, .001), this.timer = 0, this.output_to_screen = !0, this.frame_eye_index = 0, this.render_width = this.canvas.width, this.render_height = this.canvas.height }).gl_buffers = new e.object_pooler(function (t) { return t.createBuffer() }), o.gl_textures = new e.object_pooler(function (t) { return t.createTexture() }), o }) }(_FM.fin, _FM.ge, _FM.math), function () { return function terrain(ecs, ge, math) { ge.terrain = {}; var WORKER_THREAD_MESSAGES = { REQUEST_REGION_MESH: 2e3, REQUEST_REGION_QT: 3e3, REQUEST_REGION_CQT: 3500 }; ge.terrain.processor = ge.define(function (proto, _super) { proto.setup_mesh_processor = function () { var i; return proto.regions_from_image_url = function (t, e, i, r, n, s, a) { var o = this; r = r || 1, ge.load_working_image_data(t, function (t, n, s) { for (var _ = 999999, l = -999999, u = 0, h = [], c = 0; c < t.length / 4; c++)(u = t[4 * c] / r) < _ && (_ = u), u > l && (l = u), h[c] = u; size = l - _, o.worker.postMessage([200, e, i, n, h, a || 1]) }, n, s) }, proto.regions_from_data = (i = 0, function (t, e, r, n, s, a) { if (a) for (i = 0; i < t.length; i++)t[i] *= a; this.worker.postMessage([200, e, r, n, t, s]) }), proto.update_terrain_parameters = function () { this.worker.postMessage([100, this.world_size, this.region_size, this.terrain_quality]), this.worker.postMessage([400, this.sun_direction[0] * this.world_size * this.region_size, this.sun_direction[1] * this.world_size * this.region_size, this.sun_direction[2] * this.world_size * this.region_size]) }, proto.generate_regions = function (t, e, i, r, n) { this.worker.postMessage([9999, t, e, i, r, n]) }, function () { var worker = ge.worker(function (thread) { var regions = {}, world_size, region_size, region_size1, region_size2, terrain_quality = 1, region_size_scale, region_size_scale1, reg_x, reg_z, reg, reg_key; console.log("regions", regions), regions.pool = [], regions.pool.free = function (t) { this.push(t) }, regions.pool.get = function () { return this.length > 0 ? this.pop() : { HP: {} } }; var PATCH_SIZE = 16, MIN_PATCH_SIZE = 2, MIN_FAN_DETAIL = 2, CQT_DETAIL = 0, ORIG_MIN_PATCH_SIZE = 0, WORKING_PATCH_SIZE = PATCH_SIZE, WORKING_MIN_PATCH_SIZE = MIN_PATCH_SIZE, vkey, vindex_width = 1200, vmap = new Uint8Array(0), vdata = new Float32Array(0), vindex_width2 = vindex_width / 2, check_vlevel_value = 0, time_start, rast_time; function check_vlevel(t, e) { return check_vlevel_value = vmap[(e + vindex_width2) * vindex_width + (t + vindex_width2)] } function set_vlevel(t, e, i) { vmap[vkey = (e + vindex_width2) * vindex_width + (t + vindex_width2)] = Math.min(vmap[vkey], i) } var output = new Float32Array(24e5), oi = 0, render_strips = (st = 0, function (t) { for (st = 0; st < region_size; st += 2 * t)set_vlevel(st, 0, t), set_vlevel(st, region_size, t), set_vlevel(0, st, t), set_vlevel(region_size, st, t) }), st, patches = {}, sun_x = 15e3, sun_y = 5500, sun_z = 15e3; thread[400] = function (t, e, i, r) { sun_x = e, sun_y = i, sun_z = r }, thread[100] = function (t, e, i, r) { world_size = e, region_size1 = (region_size = i) + 1, region_size2 = .5 * region_size, 0 === (terrain_quality = r) ? (PATCH_SIZE = 4, MIN_PATCH_SIZE = 1, MIN_DETAIL = 1, CQT_DETAIL = 4, MIN_FAN_DETAIL = 2) : 1 === terrain_quality && (PATCH_SIZE = 8, MIN_PATCH_SIZE = 2, CQT_DETAIL = 8, MIN_FAN_DETAIL = 2), 2 === terrain_quality ? (PATCH_SIZE = 16, MIN_PATCH_SIZE = 4, CQT_DETAIL = 12, MIN_FAN_DETAIL = 2) : 3 === terrain_quality ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 4, CQT_DETAIL = 9, MIN_FAN_DETAIL = 2) : 4 === terrain_quality ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 8, CQT_DETAIL = 24, MIN_FAN_DETAIL = 4) : 5 === terrain_quality ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 16, CQT_DETAIL = 32, MIN_FAN_DETAIL = 4) : 6 === terrain_quality && (PATCH_SIZE = 32, MIN_PATCH_SIZE = 16, CQT_DETAIL = 32, MIN_FAN_DETAIL = 8), ORIG_MIN_PATCH_SIZE = MIN_PATCH_SIZE; for (var n = 1; n <= region_size;)patches[n] = { i: 0, list: [] }, n *= 2; vindex_width2 = (vindex_width = 2 * region_size + 8) / 2, vkey = vindex_width * vindex_width, vmap.length < vkey && (vmap = new Uint8Array(vkey), vdata = new Float32Array(4 * vkey)) }, thread[200] = function () { var t, e, i, r, n, s; return function (a, o, _, l, u, h) { for (u = function (t, e) { var i = new Float32Array((e + 1) * (e + 1)); for (reg_z = 0; reg_z < e; reg_z++)for (reg_x = 0; reg_x < e; reg_x++)i[reg_z * (e + 1) + reg_x] = t[reg_z * e + reg_x]; for (reg_z = 0; reg_z < e; reg_z++)i[reg_z * (e + 1) + e] = t[reg_z * e + (e - 1)]; for (reg_x = 0; reg_x < e; reg_x++)i[e * (e + 1) + reg_x] = t[(e - 1) * e + reg_x]; return i[e * (e + 1) + e] = (t[(e - 1) * e + (e - 1)] + t[(e - 1) * e + (e - 1)]) / 2, i }(u, l), region_size_scale1 = 1 + (region_size_scale = region_size / h), s = Math.floor(l / region_size_scale), l += 1, reg_z = 0; reg_z < s; reg_z++)for (reg_x = 0; reg_x < s; reg_x++) { for ((reg = regions[reg_key = (reg_z + _) * world_size + (reg_x + o)] || regions.pool.get()).HP = {}, reg.QT = void 0, reg.data = reg.data || new Float32Array(region_size_scale1 * region_size_scale1), void 0 !== reg.size && reg.size !== region_size_scale1 && (reg.data = new Float32Array(region_size_scale1 * region_size_scale1)), reg.minh = 999999, reg.maxh = -999999, reg.rx = reg_x + o, reg.rz = reg_z + _, reg.x = reg.rx * region_size, reg.z = reg.rz * region_size, reg.scale = h, reg.size = region_size_scale1, i = reg_x * region_size_scale, e = 0; e < region_size_scale1; e++)for (r = (reg_z * region_size_scale + e) * l + i, n = e * region_size_scale1, t = 0; t < region_size_scale1; t++)ht = u[r + t] || 0, ht < reg.minh && (reg.minh = ht), ht > reg.maxh && (reg.maxh = ht), reg.data[n + t] = ht; regions[reg_key] = reg, reg.key = reg_key, thread.postMessage([a, reg_key, reg.rx, reg.rz, reg.minh, reg.maxh]) } console.log(s * s + " regions loaded") } }(); var H = function () { var t, e, i, r, n, s, a, o, _, l, u, h, c, d, m; return function (p, f) { return 1 === reg.scale ? reg.data[f * region_size1 + p] : (m = f * region_size1 + p, void 0 !== reg.HP[m] ? reg.HP[m] : (d = reg.data, _ = reg.size, e = p / reg.scale, t = f / reg.scale, n = (i = 0 | (e < 0 ? 0 : e >= _ ? _ - 1 : e)) === _ - 1 ? i : i + 1, s = (r = 0 | (t < 0 ? 0 : t >= _ ? _ - 1 : t)) === _ - 1 ? r : r + 1, p = e % 1, f = t % 1, l = d[i + r * _], u = d[n + r * _], h = d[i + s * _], c = d[n + s * _], a = ((u *= u) - (l *= l)) * p + l, o = (c * c - c * h) * p + h * h, reg.HP[m] = Math.sqrt((o - a) * f + a), reg.HP[m])) } }(), HH = function (t, e) { return t > -1 && t < region_size1 && e > -1 && e < region_size1 ? H(t, e) : (rs = region_size, _rx = 0, _rz = 0, t < 0 ? (_rx = -1, t = rs + t) : t > rs && (_rx = 1, t %= rs), e < 0 ? (_rz = -1, e = rs + e) : e > rs && (_rz = 1, e %= rs), reg_key = (reg.rz + _rz) * world_size + (reg.rx + _rx), temp_reg = reg, (reg = regions[reg_key]) ? (v = H(t, e), reg = temp_reg, v) : (reg = temp_reg, 0)) }, _rx, _rz, v, temp_reg, rs, reg_data, _fp, nx, ny, nz, p, i = 0, x, z, j = 0, s = 1, patch_index = 0, draw_fan = function () { var t, e, i, r, n = 0, s = [-1, 1, -.75, 1, -.5, 1, -.25, 1, 0, 1, .25, 1, .5, 1, .75, 1, 1, 1, 1, .75, 1, .5, 1, .25, 1, 0, 1, -.25, 1, -.5, 1, -.75, 1, -1, .75, -1, .5, -1, .25, -1, 0, -1, -.25, -1, -.5, -1, -.75, -1, -1, -1, -1, -.75, -1, -.5, -1, -.25, -1, 0, -1, .25, -1, .5, -1, .75, -1, 1], a = []; a[16] = !0, a[32] = !0, a[48] = !0, a[64] = !0; var o = s.length; return function (_, l, u, h) { for (t = s[0], e = s[1], n = h; n < o;)check_vlevel_value = vmap[(l + (r = s[n + 1]) * u + vindex_width2) * vindex_width + (_ + (i = s[n]) * u + vindex_width2)], (a[n] || check_vlevel_value < u) && (vmap[vkey = (l + vindex_width2) * vindex_width + (_ + vindex_width2)] = Math.min(vmap[vkey], u), output[oi] = _, output[oi + 2] = l, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (l + e * u + vindex_width2) * vindex_width + (_ + t * u + vindex_width2)] = Math.min(vmap[vkey], u), output[oi] = _ + t * u, output[oi + 2] = l + e * u, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (l + r * u + vindex_width2) * vindex_width + (_ + i * u + vindex_width2)] = Math.min(vmap[vkey], u), output[oi] = _ + i * u, output[oi + 2] = l + r * u, output[oi + 3] = patch_index, oi += 6, t = i, e = r), n += h } }(), check_for_edge_cases = !1, qii = 0, rg_QT = null, hh0, hh1, hh2, hh3, hh4; function eval_area_height(t, e, i, r, n) { hh0 = H(t, e), hh1 = H(t - i, e - i), hh2 = H(t + i, e - i), hh3 = H(t + i, e + i), hh4 = H(t - i, e + i); var s = qii; return output[s] = Math.max(Math.abs(.5 * (hh1 + hh2) - hh0), Math.abs(.5 * (hh4 + hh3) - hh0), Math.abs(.5 * (hh1 + hh4) - hh0), Math.abs(.5 * (hh2 + hh3) - hh0)), r > -1 && (output[r + n] = s), i > ORIG_MIN_PATCH_SIZE && (qii += 5, i *= .5, output[s] = Math.max(output[s], eval_area_height(t - i, e - i, i, s, 1), eval_area_height(t + i, e - i, i, s, 2), eval_area_height(t - i, e + i, i, s, 3), eval_area_height(t + i, e + i, i, s, 4))), output[s] } var _RSK = new Float32Array(1024), _si = 0, dd = 0, dlen = 0; function rasterize_region(t, e, i, r, n) { var s = 0; for (_RSK[_si = 0] = t, _RSK[_si + 1] = e, _RSK[_si + 2] = i, _RSK[_si + 3] = s, _si += 4; _si > 0;)t = _RSK[_si -= 4], e = _RSK[_si + 1], i = _RSK[_si + 2], s = _RSK[_si + 3], dd = r, i > WORKING_PATCH_SIZE || i > WORKING_MIN_PATCH_SIZE && n[s] > dd ? (i *= .5, _RSK[_si] = t + i, _RSK[_si + 1] = e + i, _RSK[_si + 2] = i, _RSK[_si + 3] = n[s + 4], _RSK[_si += 4] = t - i, _RSK[_si + 1] = e + i, _RSK[_si + 2] = i, _RSK[_si + 3] = n[s + 3], _RSK[_si += 4] = t + i, _RSK[_si + 1] = e - i, _RSK[_si + 2] = i, _RSK[_si + 3] = n[s + 2], _RSK[_si += 4] = t - i, _RSK[_si + 1] = e - i, _RSK[_si + 2] = i, _RSK[_si + 3] = n[s + 1], _si += 4) : ((p = patches[i]).list[p.i++] = t, p.list[p.i++] = e) } thread[2e3] = function () { var t; function e(t) { for (qii = 0, eval_area_height(region_size2, region_size2, region_size2, -1, 0), t.QT = new Float32Array(qii), i = 0; i < qii;)t.QT[i] = output[i++] } var r, n, a, o = function (r, n) { for (r.QT || e(r), rg_QT = r.QT, r.smap, s = WORKING_MIN_PATCH_SIZE; s <= WORKING_PATCH_SIZE; s *= 2)patches[s].i = 0; rasterize_region(region_size2, region_size2, region_size2, n, rg_QT), function () { for (s = WORKING_MIN_PATCH_SIZE, t = !1, patch_index = 0; s <= WORKING_PATCH_SIZE;) { for (p = patches[s], i = 0, j = p.i; i < j;)x = p.list[i++], z = p.list[i++], fd = 16, check_for_edge_cases && (s >= WORKING_MIN_PATCH_SIZE || WORKING_MIN_PATCH_SIZE >= MIN_PATCH_SIZE) && (t = !1, check_vlevel(x - s, z) < s ? t = !0 : check_vlevel(x + s, z) < s ? t = !0 : check_vlevel(x, z - s) < s ? t = !0 : check_vlevel(x, z + s) < s && (t = !0), t && (fd = s / check_vlevel_value, fd < 16 ? fd = Math.max(2, 8 / fd) : fd = 2, fd = Math.min(MIN_FAN_DETAIL, fd), WORKING_MIN_PATCH_SIZE > MIN_PATCH_SIZE && (fd = 2))), check_for_edge_cases ? draw_fan(x, z, s, fd) : (vmap[vkey = (z - s + vindex_width2) * vindex_width + (x - s + vindex_width2)] = Math.min(vmap[vkey], s), output[oi] = x - s, output[oi + 2] = z - s, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (z - s + vindex_width2) * vindex_width + (x + s + vindex_width2)] = Math.min(vmap[vkey], s), output[oi] = x + s, output[oi + 2] = z - s, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (z + s + vindex_width2) * vindex_width + (x + s + vindex_width2)] = Math.min(vmap[vkey], s), output[oi] = x + s, output[oi + 2] = z + s, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (z - s + vindex_width2) * vindex_width + (x - s + vindex_width2)] = Math.min(vmap[vkey], s), output[oi] = x - s, output[oi + 2] = z - s, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (z + s + vindex_width2) * vindex_width + (x + s + vindex_width2)] = Math.min(vmap[vkey], s), output[oi] = x + s, output[oi + 2] = z + s, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (z + s + vindex_width2) * vindex_width + (x - s + vindex_width2)] = Math.min(vmap[vkey], s), output[oi] = x - s, output[oi + 2] = z + s, output[oi + 3] = patch_index, oi += 6), patch_index++; s *= 2 } }() }, _ = !1; thread[3e3] = function (t, i, r, n, s, a, o, _, l, u) { (reg = regions[r]) && (reg.QT || e(reg), j = reg.QT.length, u = (reg_data = u.byteLength < 4 * j ? new Float32Array(j) : new Float32Array(u)).buffer, reg_data.set(reg.QT, 0), this.postMessage([t, r, n, MIN_PATCH_SIZE, PATCH_SIZE, j, l, u], [u])) }, thread[1550] = function (t, e, i, r, n) { (reg = regions[e]) && (r -= reg.x, n -= reg.z, r += region_size2, n += region_size2, thread.postMessage([t, i, H(Math.floor(r), Math.floor(n))])) }, thread[3500] = function (t, r, n, s, a, o, _, l, u, h) { if (reg = regions[n]) { for (reg.QT || e(reg), rg_QT = reg.QT, qii = 0, function t(e, i, r, n, s, a, o) { var _ = qii; return a > -1 && (output[a + o] = _), output[_] = rg_QT[n], hh1 = H(e - r, i - r), hh2 = H(e + r, i - r), hh3 = H(e + r, i + r), hh4 = H(e - r, i + r), output[_ + 1] = hh1, output[_ + 2] = hh2, output[_ + 3] = hh3, output[_ + 4] = hh4, output[_ + 5] = Math.max(hh1, hh2, hh3, hh4), hh1 = H(e, i - r), hh2 = H(e, i + r), hh3 = H(e + r, i), hh4 = H(e - r, i), output[_ + 6] = hh1, output[_ + 7] = hh2, output[_ + 8] = hh3, output[_ + 9] = hh4, output[_ + 10] = H(e, i), output[_ + 5] = Math.max(output[_ + 5], output[_ + 10], hh1, hh2, hh3, hh4), qii += 11, r > WORKING_PATCH_SIZE || r > WORKING_MIN_PATCH_SIZE && rg_QT[n] > s ? (r *= .5, output[_ + 5] = Math.max(output[_ + 5], t(e - r, i - r, r, rg_QT[n + 1], s, _, 1), t(e + r, i - r, r, rg_QT[n + 2], s, _, 2), t(e - r, i + r, r, rg_QT[n + 3], s, _, 3), t(e + r, i + r, r, rg_QT[n + 4], s, _, 4)), output[_ + 5]) : output[_ + 5] }(region_size2, region_size2, region_size2, 0, Math.abs(s), -1, 0), j = qii, h = (reg_data = h.byteLength < 4 * j ? new Float32Array(j) : new Float32Array(h)).buffer, i = 0; i < qii;)reg_data[i] = output[i++]; this.postMessage([t, n, s, MIN_PATCH_SIZE, PATCH_SIZE, j, u, h], [h]) } }; var l = 2; return function (t, e, u, h, c, d, m, p, f, g) { if (reg = regions[u]) { if (a = h, function (t) { 0 === t ? (PATCH_SIZE = 4, MIN_PATCH_SIZE = 1, MIN_DETAIL = 1, CQT_DETAIL = 4, MIN_FAN_DETAIL = 2) : 1 === t && (PATCH_SIZE = 8, MIN_PATCH_SIZE = 2, CQT_DETAIL = 8, MIN_FAN_DETAIL = 2), 2 === t ? (PATCH_SIZE = 16, MIN_PATCH_SIZE = 4, CQT_DETAIL = 12, MIN_FAN_DETAIL = 2) : 3 === t ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 4, CQT_DETAIL = 9, MIN_FAN_DETAIL = 2) : 4 === t ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 8, CQT_DETAIL = 24, MIN_FAN_DETAIL = 4) : 5 === t ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 16, CQT_DETAIL = 32, MIN_FAN_DETAIL = 4) : 6 === t ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 16, CQT_DETAIL = 32, MIN_FAN_DETAIL = 8) : 7 === t ? (PATCH_SIZE = 64, MIN_PATCH_SIZE = 32, CQT_DETAIL = 32, MIN_FAN_DETAIL = 16) : 8 === t ? (PATCH_SIZE = 128, MIN_PATCH_SIZE = 64, CQT_DETAIL = 128, MIN_FAN_DETAIL = 32) : 9 === t && (PATCH_SIZE = 256, MIN_PATCH_SIZE = 32, CQT_DETAIL = 128, MIN_FAN_DETAIL = 64) }(e), check_for_edge_cases = !0, a < 0 ? (a = Math.abs(a), check_for_edge_cases = !1) : a > 1e3 && (check_for_edge_cases = !1), WORKING_PATCH_SIZE = PATCH_SIZE, WORKING_MIN_PATCH_SIZE = MIN_PATCH_SIZE, a > 32 && (WORKING_PATCH_SIZE *= 2, WORKING_MIN_PATCH_SIZE *= 2), time_start = Date.now(), vmap.fill(255), _ = !1, m & l && (_ = !0), _ || render_strips(MIN_PATCH_SIZE), oi = 0, o(reg, a), function (t, e, a, o, l) { if (i = t, s = PATCH_SIZE, _) for (; i < e;)x = output[i], z = output[i + 2], 222 !== vmap[vkey = ((n = z * l + o) + vindex_width2) * vindex_width + ((r = x * l + a) + vindex_width2)] ? (vmap[vkey] = 222, vdata[vkey *= 4] = H(x, z), reg.minh = Math.min(reg.minh, vdata[vkey]), reg.maxh = Math.max(reg.maxh, vdata[vkey])) : vkey *= 4, output[i + 1] = vdata[vkey], output[i] = r, output[i + 2] = n, i += 6; else for (; i < e;)x = output[i], z = output[i + 2], 222 !== vmap[vkey = ((n = z * l + o) + vindex_width2) * vindex_width + ((r = x * l + a) + vindex_width2)] ? (vmap[vkey] = 222, vdata[vkey *= 4] = H(x, z), nx = HH(x - s, z) - HH(x + s, z), ny = 2 * s, nz = HH(x, z - s) - HH(x, z + s), (_fp = nx * nx + ny * ny + nz * nz) > 0 && (_fp = 1 / Math.sqrt(_fp)), nx = .5 * (nx * _fp + 1) * 255, ny = .5 * (ny * _fp + 1) * 255, nz = .5 * (nz * _fp + 1) * 255, vdata[vkey + 1] = nx, vdata[vkey + 2] = ny, vdata[vkey + 3] = nz, reg.minh = Math.min(reg.minh, vdata[vkey]), reg.maxh = Math.max(reg.maxh, vdata[vkey])) : vkey *= 4, output[i + 1] = vdata[vkey], output[i + 3] = vdata[vkey + 1], output[i + 4] = vdata[vkey + 2], output[i + 5] = vdata[vkey + 3], output[i] = r, output[i + 2] = n, i += 6 }(0, oi, 0, 0, 1), j = 3 * Math.floor(oi / 6), g = (reg_data = g.byteLength < 4 * j ? new Float32Array(j) : new Float32Array(g)).buffer, i = 0, j = 0, _) for (; i < oi;)reg_data[j] = output[i + 2] * region_size1 + output[i], reg_data[j + 1] = output[i + 1], reg_data[j + 2] = output[i + 3], reg.minh = Math.min(reg.minh, reg_data[j + 1]), reg.maxh = Math.max(reg.maxh, reg_data[j + 1]), i += 6, j += 3; else for (; i < oi;)reg_data[j] = output[i + 2] * region_size1 + output[i], reg_data[j + 1] = output[i + 1], _fp = output[i + 3] << 16 | output[i + 4] << 8 | output[i + 5], reg_data[j + 2] = _fp / (1 << 24), reg.minh = Math.min(reg.minh, reg_data[j + 1]), reg.maxh = Math.max(reg.maxh, reg_data[j + 1]), i += 6, j += 3; rast_time = Date.now() - time_start, this.postMessage([t, u, h, reg.minh, reg.maxh, j, f, g], [g]) } } }(), thread.onmessage = function (t) { this[t.data[0]].apply(this, t.data) }, eval("(" + worker_overloaded.toString() + ")(thread)"), thread[9999] = function () { var t, e, i, r, n, s, a, o, _, l, u, h, c, d, m, p, f = function () { var t = {}; function e(t, e, i) { this.x = t, this.y = e, this.z = i } e.prototype.dot2 = function (t, e) { return this.x * t + this.y * e }, e.prototype.dot3 = function (t, e, i) { return this.x * t + this.y * e + this.z * i }; var i, r, n, s, a, o, _, l, u, h = [new e(1, 1, 0), new e(-1, 1, 0), new e(1, -1, 0), new e(-1, -1, 0), new e(1, 0, 1), new e(-1, 0, 1), new e(1, 0, -1), new e(-1, 0, -1), new e(0, 1, 1), new e(0, -1, 1), new e(0, 1, -1), new e(0, -1, -1)], c = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180], d = new Array(512), m = new Array(512); function p(t) { return t * t * t * (t * (6 * t - 15) + 10) } function f(t, e, i) { return (1 - i) * t + i * e } return t.seed = function (t) { for (t > 0 && t < 1 && (t *= 65536), (t = Math.floor(t)) < 256 && (t |= t << 8), i = 0; i < 256; i++)r = 1 & i ? c[i] ^ 255 & t : c[i] ^ t >> 8 & 255, d[i] = d[i + 256] = r, m[i] = m[i + 256] = h[r % 12] }, t.perlin = function (t, e) { return n = Math.floor(t), s = Math.floor(e), t -= n, e -= s, a = m[(n &= 255) + d[s &= 255]].dot2(t, e), o = m[n + d[s + 1]].dot2(t, e - 1), _ = m[n + 1 + d[s]].dot2(t - 1, e), l = m[n + 1 + d[s + 1]].dot2(t - 1, e - 1), u = p(t), f(f(a, _, u), f(o, l, u), p(e)) }, t }(), g = 0; return function (v, w, x, y, b, E) { for (f.seed(w.seed), h = w.offset_x, c = w.offset_z, d = w.height_scale, e = w.layers, p = 0; p < b; p++)for (m = 0; m < b; m++) { for (i = m + h * (b - 1), r = p + c * (b - 1), _ = 0, g = 0; g < e.length; g++) { for (t = e[g], a = t.base_roughness, o = 1, n = 0, s = 0; s < t.octaves; s++)n += (f.perlin(i / b * a, r / b * a) / 2 + .5) * o, a *= t.roughness, o *= t.persistence; _ += n * t.strength } l = Math.max(l, _), u = Math.min(u, _), output[p * b + m] = _ * d } this[200](200, x, y, b, output, E) } }() }, [this.worker_overloaded]); this.worker = worker, this.worker.processor = this, this.update_reg_bounds = function (t) { t.rad = (t.maxh - t.minh) / 2 * 1, t.y = t.minh + t.rad, t.a_minx = Math.min(t.x - this.region_size_half, t.x + this.region_size_half), t.a_miny = Math.min(t.y - t.rad, t.y + t.rad), t.a_minz = Math.min(t.z - this.region_size_half, t.z + this.region_size_half), t.a_maxx = Math.max(t.x - this.region_size_half, t.x + this.region_size_half), t.a_maxy = Math.max(t.y - t.rad, t.y + t.rad), t.a_maxz = Math.max(t.z - this.region_size_half, t.z + this.region_size_half) }, this.worker[100] = function (t, e) { }, this.worker[200] = function (t, e, i, r, n, s) { var a = this.processor.regions[e] || { key: e, last_time: 0, detail: -1, reg_x: i, reg_z: r, state: 0, req_detail: -1, type: 1, visibled: !0 }; for (var o in a.state = 0, a.detail = -1, a.reg_detail = -1, a.maxh = s, a.minh = n, a.x = i * this.processor.region_size * 1, a.z = r * this.processor.region_size * 1, this.processor.update_reg_bounds(a), this.processor.regions[e] = a, this.processor.hosts) this.processor.hosts[o].on_new_region(a) }, this.worker[300] = function (t, e, i) { (reg = this.processor.regions[e]) && (reg.CQT = new Int16Array(i)) }, this.worker[2300] = function (t, e, i, r) { (reg = this.processor.regions[e]) && (console.log(i, r), reg.smap = new ge.webgl.texture(void 0, void 0, void 0, new Uint8Array(r), void 0, i, i), reg.smap.enable_clamp_to_edge()) }, this.worker[1550] = function (t, e, i) { this.processor.query_heights[e] = i }, this.query_height = function (t, e, i) { reg_x = Math.floor(e / this.region_size + .5), reg_z = Math.floor(i / this.region_size + .5), reg_key = reg_z * this.world_size + reg_x, reg = this.regions[reg_key], this.query_heights[t] = -1 / 0, reg && this.worker.postMessage([1550, reg.key, t, e, i]) }, worker.request_region = function () { var t = new fin.queue, e = [new ArrayBuffer(1), new ArrayBuffer(1), new ArrayBuffer(1)], i = []; console.log("reg_data_buffers", e); var r = 0; function n() { for (r = 0; r < e.length;) { if (e[r].byteLength > 0) return r; r++ } return -1 } var s = 0; worker[2e3] = function (r, n, s, a, o, _, l, u) { (reg = this.processor.regions[n]).minh = a, reg.maxh = o, this.processor.update_reg_bounds(reg), this.processor.hosts[i[l]].on_region_data(reg, new Float32Array(u), _, s), e[l] = u, t.size() > 0 && this.region_parked_request(t.dequeue()) }, worker[2010] = function (i, r, n, s, a, o, _, l) { e[_] = l, t.size() > 0 && this.region_parked_request(t.dequeue()) }, worker[3e3] = function (r, n, s, a, o, _, l, u) { this.processor.hosts[i[l]].on_region_qt(this.processor.regions[n], new Float32Array(u), _, a, o, s), e[l] = u, t.size() > 0 && this.region_parked_request(t.dequeue()) }, worker[3500] = function (r, n, s, a, o, _, l, u) { this.processor.hosts[i[l]].on_region_cqt(this.processor.regions[n], new Float32Array(u), _, a, o, s), e[l] = u, t.size() > 0 && this.region_parked_request(t.dequeue()) }; var a = new fin.object_pooler(function () { return { host_id: 0, param1: [null, null, null, null, null, null, null, null, null, null], param2: [null] } }); return console.log("request_pool", a), worker.region_parked_request = function (r) { (s = n()) > -1 ? (i[s] = r.host_id, r.param1[8] = s, r.param1[9] = e[s], r.param2[0] = e[s], this.postMessage(r.param1, r.param2), r.param1[9] = null, r.param2[0] = null, a.free(r)) : t.enqueue(r) }, function (r, o, _, l, u, h) { if (2 !== o.state) return o; var c = a.get(); return c.param1[0] = r, c.param1[1] = o.terrain_quality || this.processor.terrain_quality, c.param1[2] = o.key, c.param1[3] = o.req_detail, c.param1[4] = _, c.param1[5] = l, c.param1[6] = u, c.param1[7] = h, (s = n()) > -1 ? (i[s] = o.host_id, c.param1[8] = s, c.param1[9] = e[s], c.param2[0] = e[s], this.postMessage(c.param1, c.param2), c.param1[5] = null, c.param2[0] = null, a.free(c)) : (c.host_id = o.host_id, t.enqueue(c)), o } }(), this.worker.onmessage = function (t) { this[t.data[0]].apply(this, t.data) } } }(); var reg, reg_x, reg_z, reg_key, i = 0, render_item = null; function ge_terrain_processor(t) { t = t || {}, this.region_size = t.region_size || 512, this.world_size = t.world_size || 8192, this.region_size_width = this.region_size + 1, this.region_size_half = .5 * this.region_size, this.regions = {}, this.world_size_half = .5 * this.world_size, this.timer = 0, this.last_validate_time = 0, this.last_updated_time = 0, this.terrain_quality = t.terrain_quality || 4, this.sun_direction = t.sun_direction || [.5, .5, .3], this.worker_overloaded = "var worker_overloaded=function(thread){}", t.worker && (this.worker_overloaded = "var worker_overloaded=" + t.worker.toString()), this.setup_mesh_processor(), this.def_regions_from_image_url = t.regions_from_image_url, this.on_initialized = t.on_initialized || null, this.initialized = !1, this.initialize(), this.hosts = {}, this.query_heights = {} } return proto.initialize = function () { if (this.update_terrain_parameters(), this.def_regions_from_image_url) for (i = 0; i < this.def_regions_from_image_url.length; i++)this.regions_from_image_url.apply(this, this.def_regions_from_image_url[i]); null !== this.on_initialized && this.on_initialized(this), this.initialized = !0 }, proto.add_host = function (t) { t.host_id = ge.guidi(), this.hosts[t.host_id] = t }, ge_terrain_processor }); var glsl = ge.webgl.shader.create_chunks_lib("/*chunk-default-material*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nuniform mat4 u_view_projection_rw;\n\nuniform vec4 reg_pos;\nuniform vec3 cam_reg_pos;\n\nuniform vec3 u_terrain_scale;\n\n\n\n\nvarying vec4 v_position_rw;\nvarying vec3 v_normal_rw;\nvarying vec2 v_uv_rw;\nvarying mat3 v_tbn_matrix;\n\n\n<?=chunk('mat3-transpose')?>\n\nvoid vertex(void){\n  v_position_rw.z=floor(a_position_rw.x/cam_reg_pos.z);\n  v_position_rw.x=floor(mod(a_position_rw.x,cam_reg_pos.z));\n  v_position_rw.y=a_position_rw.y;  \n\n\n  v_normal_rw.x = fract(a_position_rw.z);\n  v_normal_rw.y = fract(a_position_rw.z* 256.0);  \n  v_normal_rw.z = fract(a_position_rw.z * 65536.0);  \n\n\n   v_normal_rw.x = (v_normal_rw.x * 2.0) - 1.0;\n  v_normal_rw.y = (v_normal_rw.y * 2.0) - 1.0;\n  v_normal_rw.z = (v_normal_rw.z * 2.0) - 1.0;  \n\n\n  v_position_rw.w=1.0; \n  \n  //v_position_rw.xyz+=(v_normal_rw*u_terrain_scale);\n\n  v_uv_rw=v_position_rw.xz/cam_reg_pos.z;        \n  \n  //v_uv_rw+=0.5;\n\n  v_position_rw.xyz*=u_terrain_scale;\n  \n //  v_position_rw.xz-=((cam_reg_pos.z)*0.5);\n  // v_position_rw.xz*=reg_pos.w;\n\n  //v_position_rw.xz*=0.99;\n  v_position_rw.xz+=reg_pos.xz;   \n // v_position_rw.y=0.0;\n\n \n\n  gl_Position = u_view_projection_rw *v_position_rw;\n\n // v_uv_rw=v_position_rw.xz;        \n // v_uv_rw/=(cam_reg_pos.z);    \n  v_normal_rw=normalize(v_normal_rw);\n\n}\n\n<?=chunk('precision')?>\n\nuniform mat4 u_object_material_rw;\nuniform vec4 u_eye_position_rw;\nuniform vec4 reg_pos;\nuniform vec3 cam_reg_pos;\n\nvarying vec4 v_position_rw;\nvarying vec3 v_normal_rw;\nvarying vec2 v_uv_rw;\nvarying mat3 v_tbn_matrix;\n\n<?=chunk('global-render-system-lighting')?>\n\n<?=chunk('global-render-system-fog-effect')?>\n\n\nuniform vec4 land_color;\n\nuniform sampler2D u_texture_tiles_rw;\nuniform sampler2D u_normalmap_tiles_rw;\nuniform sampler2D u_shadow_map_rw;\n\nuniform vec2 u_tile_size_rw;\nuniform vec4 u_texture_repeat_rw;\nuniform vec4 u_normalmap_repeat_rw;\n\nfloat tile_size;\nvec2 tile_uv;\nvec2 uv=vec2(0);\nfloat tile_offset;\n\nvec4 mix_texture_tiles(vec4 tile1,vec4 tile2,vec4 tile3,vec4 tile4,vec3 normal);\nvec3 mix_normal_tiles(vec3 tile1,vec3 tile2,vec3 tile3,vec3 tile4,vec3 normal);\n\nvec4 read_tile(sampler2D texture,float tile_repeat, float tx,float ty);\n\nvec3 mix_normal_tiles(vec3 tile1,vec3 tile2,vec3 tile3,vec3 tile4,vec3 normal){\n\n\n\treturn mix(tile1,tile4,abs(normal.x));\n}\n\nvec4 mix_texture_tiles(vec4 tile1,vec4 tile2,vec4 tile3,vec4 tile4,vec3 normal){\n\treturn mix(tile4,tile2,0.5);\n}\n\n\nvec4 read_tile(sampler2D texture,float tile_repeat, float tx,float ty){\n\n    uv.x=mod(v_uv_rw.x*tile_repeat,tile_size-(tile_offset*2.0));\n    uv.y=mod(v_uv_rw.y*tile_repeat,tile_size-(tile_offset*2.0));\n    uv.x+=tx*tile_size+tile_offset;\n    uv.y+=ty*tile_size+tile_offset;\n    return texture2D(texture, uv);\n}\n\n\n\nvec2 texelSize=vec2(1.0/128.0,1.0/128.0);\nfloat sample_smap(vec2 coords){\t\n\tvec2 pixelPos = coords / texelSize + vec2(0.5);\n\tvec2 fracPart = fract(pixelPos);\n\tvec2 startTexel = (pixelPos - fracPart) * texelSize;\n\tfloat blTexel = texture2D(u_shadow_map_rw, startTexel).r;\n\tfloat brTexel = texture2D(u_shadow_map_rw, startTexel + vec2(texelSize.x, 0.0)).r;\n\tfloat tlTexel = texture2D(u_shadow_map_rw, startTexel + vec2(0.0, texelSize.y)).r;\n\tfloat trTexel = texture2D(u_shadow_map_rw, startTexel + texelSize).r;\n\tfloat mixA = mix(blTexel, tlTexel, fracPart.y);\n\tfloat mixB = mix(brTexel, trTexel, fracPart.y);\n\treturn mix(mixA, mixB, fracPart.x);\n}\n\n\n\nfloat sample_smap_pcf(vec2 coords)\n{\n\tconst float NUM_SAMPLES = 3.0;\n\tconst float SAMPLES_START = (NUM_SAMPLES - 1.0) / 2.0;\n\tconst float NUM_SAMPLES_SQUARED = NUM_SAMPLES * NUM_SAMPLES;\n\tfloat result = 0.0;\n\tfor (float y = -SAMPLES_START; y <= SAMPLES_START; y += 1.0)\n\t{\n\t\tfor (float x = -SAMPLES_START; x <= SAMPLES_START; x += 1.0)\n\t\t{\n\t\t\tvec2 coordsOffset = vec2(x, y) * texelSize;\n\t\t\tresult += sample_smap(coords + coordsOffset);\n\t\t}\n\t}\n\treturn result / NUM_SAMPLES_SQUARED;\n}\n\n\n\n\nvoid fragment(void) {\t\n\ntile_size=u_tile_size_rw.x;\ntile_offset=u_tile_size_rw.y;\n\n\n\n\n  \n\tvec4 tile1=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.x, 0.0,0.0);\n\tvec4 tile2=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.y, 1.0,0.0);\n\tvec4 tile3=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.z, 0.0,1.0);\n\tvec4 tile4=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.w, 1.0,1.0);\n\n\tvec3 norm1=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.x, 0.0,0.0).xyz - 1.0);\n\tvec3 norm2=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.y, 1.0,0.0).xyz - 1.0);\n\tvec3 norm3=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.z, 0.0,1.0).xyz - 1.0);\n\tvec3 norm4=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.w, 1.0,1.0).xyz - 1.0);\n\n\n\n\t\n\tvec3 normal= mix_normal_tiles(norm1,norm2,norm3,norm4,v_normal_rw);\n\tnormal=normalize(v_normal_rw+normal);\n\n\t vec3 fws_direction_to_eye = normalize(u_eye_position_rw.xyz - v_position_rw.xyz);\t\t\n\tvec3 total_light=get_render_system_lighting(u_object_material_rw,v_position_rw.xyz,\n\tnormal,\n\tfws_direction_to_eye);\n\t\n\t//*texture2D(u_shadow_map_rw, v_uv_rw).r;\t\n\n\t\n\n\n\tgl_FragColor = vec4((total_light)*(land_color.xyz), u_object_material_rw[0].w)*\t\n\tmix_texture_tiles(tile1,tile2,tile3,tile4,normal);\n\n\tgl_FragColor*=sample_smap_pcf(v_uv_rw);\n\t//gl_FragColor = texture2D(u_shadow_map_rw, v_uv_rw);\n\n\t//gl_FragColor=mix_fog_color(gl_FragColor);\n\t//gl_FragColor=texture2D(u_texture_tiles_rw, v_uv_rw);\n\t//gl_FragColor=vec4(1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*chunk-default-patch-material*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nuniform mat4 u_view_projection_rw;\n\nvarying vec4 v_position_rw;\nvarying vec3 v_normal_rw;\nvarying vec2 v_uv_rw;\nvarying mat3 v_tbn_matrix;\n\n\n<?=chunk('mat3-transpose')?>\n\nvoid vertex(void){\n  v_position_rw.z=floor(a_position_rw.x/cam_reg_pos.z);\n  v_position_rw.x=floor(mod(a_position_rw.x,cam_reg_pos.z));\n  v_position_rw.y=a_position_rw.y;  \n\n\n  v_normal_rw.x = fract(a_position_rw.z);\n  v_normal_rw.y = fract(a_position_rw.z* 256.0);  \n  v_normal_rw.z = fract(a_position_rw.z * 65536.0);  \n\n\n   v_normal_rw.x = (v_normal_rw.x * 2.0) - 1.0;\n  v_normal_rw.y = (v_normal_rw.y * 2.0) - 1.0;\n  v_normal_rw.z = (v_normal_rw.z * 2.0) - 1.0;  \n\n\n  v_position_rw.w=1.0; \n  \n  //v_position_rw.xyz+=(v_normal_rw*u_terrain_scale);\n\n  v_uv_rw=v_position_rw.xz/cam_reg_pos.z;        \n  \n  //v_uv_rw+=0.5;\n\n  v_position_rw.xyz*=u_terrain_scale;\n  \n //  v_position_rw.xz-=((cam_reg_pos.z)*0.5);\n  // v_position_rw.xz*=reg_pos.w;\n\n  //v_position_rw.xz*=0.99;\n  v_position_rw.xz+=reg_pos.xz;   \n // v_position_rw.y=0.0;\n\n \n\n  gl_Position = u_view_projection_rw *v_position_rw;\n\n // v_uv_rw=v_position_rw.xz;        \n // v_uv_rw/=(cam_reg_pos.z);    \n  v_normal_rw=normalize(v_normal_rw);\n\n}\n\n<?=chunk('precision')?>\n\nuniform mat4 u_object_material_rw;\nuniform vec4 u_eye_position_rw;\nuniform vec4 reg_pos;\nuniform vec3 cam_reg_pos;\n\nvarying vec4 v_position_rw;\nvarying vec3 v_normal_rw;\nvarying vec2 v_uv_rw;\nvarying mat3 v_tbn_matrix;\n\n<?=chunk('global-render-system-lighting')?>\n\n<?=chunk('global-render-system-fog-effect')?>\n\n\nuniform vec4 land_color;\n\nuniform sampler2D u_texture_tiles_rw;\nuniform sampler2D u_normalmap_tiles_rw;\nuniform sampler2D u_shadow_map_rw;\n\nuniform vec2 u_tile_size_rw;\nuniform vec4 u_texture_repeat_rw;\nuniform vec4 u_normalmap_repeat_rw;\n\nfloat tile_size;\nvec2 tile_uv;\nvec2 uv=vec2(0);\nfloat tile_offset;\n\nvec4 mix_texture_tiles(vec4 tile1,vec4 tile2,vec4 tile3,vec4 tile4,vec3 normal);\nvec3 mix_normal_tiles(vec3 tile1,vec3 tile2,vec3 tile3,vec3 tile4,vec3 normal);\n\nvec4 read_tile(sampler2D texture,float tile_repeat, float tx,float ty);\n\nvec3 mix_normal_tiles(vec3 tile1,vec3 tile2,vec3 tile3,vec3 tile4,vec3 normal){\n\n\n\treturn mix(tile1,tile4,abs(normal.x));\n}\n\nvec4 mix_texture_tiles(vec4 tile1,vec4 tile2,vec4 tile3,vec4 tile4,vec3 normal){\n\treturn mix(tile4,tile2,0.5);\n}\n\n\nvec4 read_tile(sampler2D texture,float tile_repeat, float tx,float ty){\n\n    uv.x=mod(v_uv_rw.x*tile_repeat,tile_size-(tile_offset*2.0));\n    uv.y=mod(v_uv_rw.y*tile_repeat,tile_size-(tile_offset*2.0));\n    uv.x+=tx*tile_size+tile_offset;\n    uv.y+=ty*tile_size+tile_offset;\n    return texture2D(texture, uv);\n}\n\n\n\nvec2 texelSize=vec2(1.0/128.0,1.0/128.0);\nfloat sample_smap(vec2 coords){\t\n\tvec2 pixelPos = coords / texelSize + vec2(0.5);\n\tvec2 fracPart = fract(pixelPos);\n\tvec2 startTexel = (pixelPos - fracPart) * texelSize;\n\tfloat blTexel = texture2D(u_shadow_map_rw, startTexel).r;\n\tfloat brTexel = texture2D(u_shadow_map_rw, startTexel + vec2(texelSize.x, 0.0)).r;\n\tfloat tlTexel = texture2D(u_shadow_map_rw, startTexel + vec2(0.0, texelSize.y)).r;\n\tfloat trTexel = texture2D(u_shadow_map_rw, startTexel + texelSize).r;\n\tfloat mixA = mix(blTexel, tlTexel, fracPart.y);\n\tfloat mixB = mix(brTexel, trTexel, fracPart.y);\n\treturn mix(mixA, mixB, fracPart.x);\n}\n\n\n\nfloat sample_smap_pcf(vec2 coords)\n{\n\tconst float NUM_SAMPLES = 3.0;\n\tconst float SAMPLES_START = (NUM_SAMPLES - 1.0) / 2.0;\n\tconst float NUM_SAMPLES_SQUARED = NUM_SAMPLES * NUM_SAMPLES;\n\tfloat result = 0.0;\n\tfor (float y = -SAMPLES_START; y <= SAMPLES_START; y += 1.0)\n\t{\n\t\tfor (float x = -SAMPLES_START; x <= SAMPLES_START; x += 1.0)\n\t\t{\n\t\t\tvec2 coordsOffset = vec2(x, y) * texelSize;\n\t\t\tresult += sample_smap(coords + coordsOffset);\n\t\t}\n\t}\n\treturn result / NUM_SAMPLES_SQUARED;\n}\n\n\n\n\nvoid fragment(void) {\t\n\ntile_size=u_tile_size_rw.x;\ntile_offset=u_tile_size_rw.y;\n\n\n\n\n  \n\tvec4 tile1=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.x, 0.0,0.0);\n\tvec4 tile2=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.y, 1.0,0.0);\n\tvec4 tile3=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.z, 0.0,1.0);\n\tvec4 tile4=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.w, 1.0,1.0);\n\n\tvec3 norm1=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.x, 0.0,0.0).xyz - 1.0);\n\tvec3 norm2=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.y, 1.0,0.0).xyz - 1.0);\n\tvec3 norm3=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.z, 0.0,1.0).xyz - 1.0);\n\tvec3 norm4=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.w, 1.0,1.0).xyz - 1.0);\n\n\n\n\t\n\tvec3 normal= mix_normal_tiles(norm1,norm2,norm3,norm4,v_normal_rw);\n\tnormal=normalize(v_normal_rw+normal);\n\n\t vec3 fws_direction_to_eye = normalize(u_eye_position_rw.xyz - v_position_rw.xyz);\t\t\n\tvec3 total_light=get_render_system_lighting(u_object_material_rw,v_position_rw.xyz,\n\tnormal,\n\tfws_direction_to_eye);\n\t\n\t//*texture2D(u_shadow_map_rw, v_uv_rw).r;\t\n\n\t\n\n\n\tgl_FragColor = vec4((total_light)*(land_color.xyz), u_object_material_rw[0].w)*\t\n\tmix_texture_tiles(tile1,tile2,tile3,tile4,normal);\n\n\tgl_FragColor*=sample_smap_pcf(v_uv_rw);\n\t//gl_FragColor = texture2D(u_shadow_map_rw, v_uv_rw);\n\n\t//gl_FragColor=mix_fog_color(gl_FragColor);\n\t//gl_FragColor=texture2D(u_texture_tiles_rw, v_uv_rw);\n\t//gl_FragColor=vec4(1.0);\n}\n\n\n\n\n\n\n\n\n\n\n/*chunk-oclusion*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nuniform mat4 u_view_projection_rw;\nuniform vec3 reg_pos;\nuniform vec3 cam_reg_pos;\n\nvoid vertex(void){\n  gl_Position.z=floor(a_position_rw.x/cam_reg_pos.z);\n  gl_Position.x=floor(mod(a_position_rw.x,cam_reg_pos.z));\n  gl_Position.y=a_position_rw.y; \n  gl_Position.w=1.0;     \n  gl_Position.xz+=reg_pos.xz;    \n  gl_Position = u_view_projection_rw *gl_Position;\n}\n\n<?=chunk('precision')?>\nuniform vec4 land_color;\nvoid fragment(void) {\t\n\tgl_FragColor=land_color/255.0;\n\n}\n\n\n\n\n\n\n\n\n"); ge.terrain.material = ge.define(function (t, e) { function i(t) { t = t || {}, e.apply(this, [t]), math.vec3.set(this.ambient, .5, .5, .5), math.vec3.set(this.specular, 0, 0, 0), this.flags += 32, this.texture_tiles = null, this.normalmap_tiles = null, this.tile_size = math.vec2(512, 0), this.texture_repeat = math.vec4(t.tile_repeat || [8, 8, 8, 8]), this.normalmap_repeat = math.vec4(1, 1, 1, 1), this.shader = i.shader, t.normalmap_tiles ? this.normalmap_tiles = ge.webgl.texture.create_tiled_texture(t.normalmap_tiles, t.material.tile_size || 512, t.material.texture_size || 1024, t.material.texture_size || 1024) : this.normalmap_tiles = new ge.webgl.texture, t.texture_tiles ? (this.texture_tiles = ge.webgl.texture.create_tiled_texture(t.texture_tiles, t.tile_size || 512, t.texture_size || 1024, t.texture_size || 1024), this.texture_tiles.enable_clamp_to_edge()) : (this.texture_tiles = new ge.webgl.texture, this.texture_tiles.tile_sizef = 1, this.texture_tiles.tile_offsetf = 1), void 0 !== t.transparent && this.set_tansparency(t.transparent), t.shader && (this.shader = this.shader.extend(t.shader)) } return t.render_mesh = function (t, e, i) { i.renderer ? (1024 & this.flags ? t.gl_disable(2929) : t.gl_enable(2929), 0 != (2048 & this.flags) ? t.gl_disable(2884) : t.gl_enable(2884), e.set_uniform("u_object_material_rw", this.object_material), this.tile_size[0] = this.texture_tiles.tile_sizef, this.tile_size[1] = this.texture_tiles.tile_offsetf, e.set_uniform("u_tile_size_rw", this.tile_size), e.set_uniform("u_texture_repeat_rw", this.texture_repeat), e.set_uniform("u_normalmap_repeat_rw", this.normalmap_repeat), t.use_texture(this.texture_tiles, 0), t.use_texture(this.normalmap_tiles, 1), e.set_uniform("u_normalmap_tiles_rw", 1), i.render_terrain(t, e)) : i.renderer = t }, i.shader = ge.webgl.shader.parse(glsl["default-material"]), i }, ge.shading.shaded_material), ge.terrain.material.oclusion = ge.define(function (t, e) { function i(t) { t = t || {}, e.apply(this, [t]), this.shader = i.shader, t.shader && (this.shader = this.shader.extend(t.shader)), this.flags += 2 } return t.render_mesh = function (t, e, i) { i.renderer ? (1024 & this.flags ? t.gl_disable(2929) : t.gl_enable(2929), 0 != (2048 & this.flags) ? t.gl_disable(2884) : t.gl_enable(2884), i.render_terrain(t, e)) : i.renderer = t }, i.shader = ge.webgl.shader.parse(glsl.oclusion), i }, ge.shading.material), ge.terrain.mesh = ge.define(function (t, e) { return t.update = function () { var e, r; t.validate_regions = function () { if (!(this.timer - this.last_validate_time < 5)) for (e in this.last_validate_time = this.timer, this.regions) (r = this.regions[e]).state > 0 && this.timer - r.last_time > 2 && (r.last_time = this.timer, r.buffer && (ge.renderer.gl_buffers.free(r.buffer), r.buffer = void 0, r.detail = -1, this.on_region_dispose(r))) }, t.request_region = function (t, e) { t.detail !== e && 2 !== t.state && (t.req_detail = e, t.state = 2, this.requested_regions[this.rqi++] = t), t.buffer && (this.on_region_activated(t), this.regions_to_render[this.ri++] = t), t.last_time = this.timer }, t.update_terrain_frustum = function () { var t, e, i, r, n, s, a, o, _ = 0; return function (l, u, h) { if (a = this.processor, o = a.region_size, reg_x = (this.cam_reg_x + (l + .5)) * o, reg_z = (this.cam_reg_z + (u + .5)) * o, h > .5) { if (r = h * o, t = Math.min(reg_x - r, reg_x + r), e = -400, i = Math.min(reg_z - r, reg_z + r), fmaxx = Math.max(reg_x - r, reg_x + r), fmaxy = this.draw_distance, fmaxz = Math.max(reg_z - r, reg_z + r), this.camera._frustum_aabb(t, e, i, fmaxx, fmaxy, fmaxz)) return h *= .5, this.update_terrain_frustum(l - h, u - h, h), this.update_terrain_frustum(l + h, u - h, h), this.update_terrain_frustum(l - h, u + h, h), void this.update_terrain_frustum(l + h, u + h, h) } else if (reg_x = this.cam_reg_x + (l + .5), reg_z = this.cam_reg_z + (u + .5), reg_key = reg_z * a.world_size + reg_x, (s = a.regions[reg_key]) && (n = this.regions[reg_key], this.camera._frustum_aabb(s.a_minx, s.a_miny, s.a_minz, s.a_maxx, s.a_maxy, s.a_maxz))) { if (_ = function (t, e, i) { return Math.abs(Math.sqrt(t * t + e * e + i * i)) }(this.camera.world_position[0] - s.x, this.camera.world_position[1] - s.y, this.camera.world_position[2] - s.z), n.distance = _, _ - a.region_size_half > this.draw_distance) return; if (this.region_margin > 1 && (0 !== Math.abs(s.reg_x % this.region_margin) || 0 !== Math.abs(s.reg_z % this.region_margin))) return; -1 !== this.fixed_detail ? this.request_region(n, this.fixed_detail) : n.distance < a.region_size ? this.request_region(n, this.detail_levels[0]) : (_ = Math.min(_ / this.quality_distance, 1), this.request_region(n, this.detail_levels[Math.floor((this.detail_levels.length - 1) * _)])) } } }(); var n = function (t, e) { return t.distance - e.distance }, s = 0; return function (t, e) { this.camera = t, this.timer = e; var r = this.processor; if (!((s = e - this.last_updated_time) < this.time_step_size)) { if (this.last_updated_time = e - s % this.time_step_size, this.camera_version = this.camera.version, this.cam_reg_x = Math.floor(this.camera.world_position[0] / r.region_size + .5), this.cam_reg_z = Math.floor(this.camera.world_position[2] / r.region_size + .5), this.cam_reg = this.regions[this.cam_reg_z * this.processor.world_size + this.cam_reg_x], this.cam_reg && (r.query_heights[-1024] > -1 / 0 && (0 === this.camera_pos_y ? this.camera_pos_y = r.query_heights[-1024] : this.camera_pos_y += (r.query_heights[-1024] - this.height_on_camera) % 42, this.height_on_camera = r.query_heights[-1024], r.query_heights[-1024] = -1 / 0, this.camera_pos_y = Math.max(this.height_on_camera, this.camera_pos_y)), this.camera_pos_x === this.camera.world_position[0] && this.camera_pos_z === this.camera.world_position[2] || (this.camera_pos_x = this.camera.world_position[0], this.camera_pos_z = this.camera.world_position[2], r.query_height(-1024, this.camera_pos_x, this.camera_pos_z)), this.camera_vel_y -= .1 * this.camera_vel_y, this.camera_vel_y = Math.max(0, this.camera_vel_y)), this.update_requested = !1, this.last_updated_time = e, this.ri = 0, this.rqi = 0, this.er = 0, this.update_terrain_frustum(0, 0, this.region_distance * this.region_margin), this.rqi > 0) if (this.requested_regions = fin.merge_sort(this.requested_regions, this.rqi, n), i = 0, this.region_margin > 1) for (; i < this.rqi;)r.worker.request_region(5e3, this.requested_regions[i++], this.region_margin, this.region_offset, this.cam_reg_z, this.cam_reg_x).last_time = e; else for (; i < this.rqi;)r.worker.request_region(2e3, this.requested_regions[i++], this.cam_reg_x, this.cam_reg_z, this.reg_req_flags).last_time = e; i = 0, this.validate_regions() } } }(), t.on_new_region = function (t) { return this.regions[t.key] ? (this.regions[t.key].reg_detail = 0, this.regions[t.key].detail = 0) : this.regions[t.key] = { key: t.key, host_id: this.host_id, req_detail: 0, terrain_quality: this.terrain_quality, last_time: 0 }, this.regions[t.key] }, t.on_region_dispose = function (t) { }, t.on_region_activated = function (t) { }, t.on_region_data = function (t, e, i, r) { var n = this.regions[t.key]; if (n.state = 1, this.renderer) { if (n.ds = 0, n.di = i / 3, n.detail = r, n.buffer = n.buffer || ge.renderer.gl_buffers.get(this.renderer.gl), this.renderer.gl.bindBuffer(34962, n.buffer), this.renderer.gl.bufferData(34962, e, 35048, 0, i), this.on_region_activated(n), this.region_margin > 1) { var s = this.processor.region_size_half * this.region_margin; t.a_minx = Math.min(t.x - s, t.x + s), t.a_minz = Math.min(t.z - s, t.z + s), t.a_maxx = Math.max(t.x - s, t.x + s), t.a_maxz = Math.max(t.z - s, t.z + s) } return n } }, t.on_region_render = function (t, e, i) { }, t.render_terrain = function () { var t, e, i, r = math.vec4(), n = math.vec3(), s = (new Float32Array(4), new Uint32Array(1)), a = (new Uint8Array(s.buffer), 0); return function (s, o) { for (n[0] = this.cam_reg_x * this.processor.region_size, n[1] = this.cam_reg_z * this.processor.region_size, (i = o.uniforms.cam_reg_pos).params[i.params_length] = n, i.func.apply(o.gl, i.params), n[2] = this.processor.region_size + 1, s.use_texture(s.default_texture, 2), (i = o.uniforms.u_shadow_map_rw) && (i.params[i.params_length] = 2, i.func.apply(o.gl, i.params)), (i = o.uniforms.u_terrain_scale) && (i.params[i.params_length] = this.terrian_scale, i.func.apply(o.gl, i.params)), this.time_start = Date.now(), s.bind_default_wireframe_indices(), this.tri_count = 0, a = 0, this.region_max_tris = 0, this.rendered_regions = 0; a < this.ri;)t = this.regions_to_render[a++], e = this.processor.regions[t.key], t.last_time = this.timer, this.region_offset > 0 && Math.floor(Math.abs(this.cam_reg_x - e.reg_x) + Math.abs(this.cam_reg_z - e.reg_z)) < this.region_offset || t.buffer && (this.tri_count += t.di, this.region_max_tris = Math.max(this.region_max_tris, t.di), this.region_margin > 1 ? (r[0] = e.x - this.processor.region_size_half * this.region_margin, r[2] = e.z - this.processor.region_size_half * this.region_margin) : (r[0] = e.x - this.processor.region_size_half, r[2] = e.z - this.processor.region_size_half), r[1] = 0, r[3] = this.region_margin, s.gl.bindBuffer(34962, t.buffer), s.gl.vertexAttribPointer(0, 3, 5126, !1, 12, 0), (i = o.uniforms.reg_pos).params[i.params_length] = r, i.func.apply(o.gl, i.params), this.on_region_render(t, s, o), this.wireframe && ((i = o.uniforms.land_color) && (i.params[i.params_length] = this.wire_color, i.func.apply(o.gl, i.params)), s.gl.drawElements(1, 2 * t.di, 5125, 2 * t.ds * 4)), this.shaded && (e.smap ? s.use_texture(e.smap, 2) : s.use_texture(s.default_texture, 2), (i = o.uniforms.land_color) && (i.params[i.params_length] = this.shaded_color, i.func.apply(o.gl, i.params)), s.gl.drawArrays(4, t.ds, t.di)), this.rendered_regions++); this.render_time = Date.now() - this.time_start } }(), function (t) { t = t || {}, e.apply(this, [t]), this.geometry = ge.geometry.geometry_data.create({ vertices: new Float32Array(0) }), this.material = t.material || new ge.terrain.material, this.processor = t.processor, this.regions = {}, this.processor.add_host(this), this.camera_version = -121, this.terrian_scale = math.vec3(t.terrian_scale), this.ri = 0, this.rqi = 0, this.regions = {}, this.region_max_tris = 0, this.camera_pos_x = 1 / 0, this.camera_pos_z = 1 / 0, this.camera_pos_y = 0, this.camera_vel_y = 0, this.timer = 0, this.terrain_quality = t.terrain_quality || 4, this.last_validate_time = 0, this.last_updated_time = 0, this.fixed_detail = -1, this.region_offset = t.region_offset || 0, this.region_margin = t.region_margin || 1, this.rendered_regions = 0, void 0 !== t.fixed_detail && (this.fixed_detail = t.fixed_detail), this.region_distance = t.region_distance || 4, this.draw_distance = t.draw_distance || 2e3, this.quality_distance = t.quality_distance || 1500, this.detail_levels = t.detail_levels || [1, 2, 6, 12, 20], this.height_on_camera = 0, this.time_step_size = t.time_step_size || 1 / 15, this.shaded_color = math.vec4(t.shaded_color || [1, 1, 1, 1]), this.wire_color = math.vec4(t.wire_color || [2, 2, 2, 1]), this.wireframe = t.wireframe || !1, this.shaded = !0, void 0 !== t.shaded && (this.shaded = t.shaded), this.regions_to_render = [], this.requested_regions = [], this.reg_req_flags = 0 } }, ge.geometry.mesh), ge.terrain.collision_mesh = ge.define(function (t, e) { var i, r, n, s; return t.on_new_patch = function (t) { }, t.on_region_data = (t.on_region_data, function (t, e, a, o) { var _ = this.regions[t.key]; if (!_.patches) { for (_.patches = [], i = t.x - this.processor.region_size_half, r = t.z - this.processor.region_size_half, n = 0; n < a; n += 3)s = e[n + 2], _.patches[s] || (_.patches[s] = []), _.patches[s].push(Math.floor(e[n] % (this.processor.region_size + 1)) * this.mesh_scale, e[n + 1] * this.mesh_scale, Math.floor(e[n] / (this.processor.region_size + 1)) * this.mesh_scale); for (n = 0; n < _.patches.length; n++)this.on_new_patch(_.patches[n], i, r) } }), function (t) { t = t || {}, e.apply(this, [t]), this.reg_req_flags = 2, this.mesh_scale = .9965 } }, ge.terrain.mesh), ge.terrain.land_mesh = ge.define(function (t, e) { var i, r; return t.update = (i = t.update, r = [null, null], function (t, e) { r[0] = t, r[1] = e, i.apply(this, r), this.cm.update(t, e) }), function (t) { (t = t || {}).terrian_scale = [1, 1, 1], t.processor = new ge.terrain.processor(t), e.apply(this, [t]), this.cm = new ge.terrain.collision_mesh({ processor: t.processor, quality_distance: 2e3, draw_distance: 7e3, fixed_detail: 32, region_distance: 8, terrain_quality: 8, wireframe: !1, shaded: !1, time_step_size: .2 }) } }, ge.terrain.mesh), ge.terrain.patch_mesh = ge.define(function (t, e) { ge.terrain.patch_material = ge.define(function (t, e) { return function (t) { t = t || {}, e.apply(this, [t]), this.flags += 2 } }, ge.shading.shaded_material); var i, r = 1200, n = new Uint8Array(0), s = new Float32Array(0), a = {}, o = r / 2, _ = 0; function l(t, e) { return _ = n[(e + o) * r + (t + o)] } for (var u = 1; u <= 1024;)a[u] = { i: 0, list: [] }, u *= 2; o = (r = 2056) / 2, i = r * r, n.length < i && (n = new Uint8Array(i), s = new Float32Array(4 * i)); var h, c, d, m, f, g, v, w, y = new Float32Array(6e5), b = 0, E = 0, A = 4, T = 16, M = 4; function L(t, e) { return g[e * v + t] } var I = function () { var t, e, s, a, l = 0, u = [-1, 1, -.75, 1, -.5, 1, -.25, 1, 0, 1, .25, 1, .5, 1, .75, 1, 1, 1, 1, .75, 1, .5, 1, .25, 1, 0, 1, -.25, 1, -.5, 1, -.75, 1, -1, .75, -1, .5, -1, .25, -1, 0, -1, -.25, -1, -.5, -1, -.75, -1, -1, -1, -1, -.75, -1, -.5, -1, -.25, -1, 0, -1, .25, -1, .5, -1, .75, -1, 1], h = []; h[16] = !0, h[32] = !0, h[48] = !0, h[64] = !0; var c = u.length; return function (d, m, p, f) { for (t = u[0], e = u[1], l = f; l < c;)_ = n[(m + (a = u[l + 1]) * p + o) * r + (d + (s = u[l]) * p + o)], (h[l] || _ < p) && (n[i = (m + o) * r + (d + o)] = Math.min(n[i], p), y[b] = d, y[b + 2] = m, y[b + 3] = G, b += 6, n[i = (m + e * p + o) * r + (d + t * p + o)] = Math.min(n[i], p), y[b] = d + t * p, y[b + 2] = m + e * p, y[b + 3] = G, b += 6, n[i = (m + a * p + o) * r + (d + s * p + o)] = Math.min(n[i], p), y[b] = d + s * p, y[b + 2] = m + a * p, y[b + 3] = G, b += 6, t = s, e = a), l += f } }(); var S = new Float32Array(1024), R = 0, F = 0, k = 0; var G = 0, N = !0, C = !1; function P() { for (u = A, C = !1, G = 0; u <= T;) { for (p = a[u], F = 0, j = p.i; F < j;)x = p.list[F++], z = p.list[F++], fd = 16, N && u >= A && (C = !1, l(x - u, z) < u ? C = !0 : l(x + u, z) < u ? C = !0 : l(x, z - u) < u ? C = !0 : l(x, z + u) < u && (C = !0), C && (fd = u / _, fd < 16 ? fd = Math.max(2, 8 / fd) : fd = 2, fd = Math.min(M, fd))), N ? I(x, z, u, fd) : (i = (z - u + o) * r + (x - u + o), n[i] = Math.min(n[i], u), y[b] = x - u, y[b + 2] = z - u, y[b + 3] = G, b += 6, i = (z - u + o) * r + (x + u + o), n[i] = Math.min(n[i], u), y[b] = x + u, y[b + 2] = z - u, y[b + 3] = G, b += 6, i = (z + u + o) * r + (x + u + o), n[i] = Math.min(n[i], u), y[b] = x + u, y[b + 2] = z + u, y[b + 3] = G, b += 6, i = (z - u + o) * r + (x - u + o), n[i] = Math.min(n[i], u), y[b] = x - u, y[b + 2] = z - u, y[b + 3] = G, b += 6, i = (z + u + o) * r + (x + u + o), n[i] = Math.min(n[i], u), y[b] = x + u, y[b + 2] = z + u, y[b + 3] = G, b += 6, i = (z + u + o) * r + (x - u + o), n[i] = Math.min(n[i], u), y[b] = x - u, y[b + 2] = z + u, y[b + 3] = G, b += 6), G++; u *= 2 } } function q(t, e, a, _, l) { for (F = t, u = T; F < e;)x = y[F], z = y[F + 2], _xx = x * l + a, _zz = z * l + _, i = (_zz + o) * r + (_xx + o), 222 !== n[i] ? (n[i] = 222, s[i *= 4] = L(x, z), nx = L(x - u, z) - L(x + u, z), ny = 2 * u, nz = L(x, z - u) - L(x, z + u), _fp = nx * nx + ny * ny + nz * nz, _fp > 0 && (_fp = 1 / Math.sqrt(_fp)), nx *= _fp, ny *= _fp, nz *= _fp, s[i + 1] = nx, s[i + 2] = ny, s[i + 3] = nz) : i *= 4, y[F + 1] = s[i], y[F + 3] = s[i + 1], y[F + 4] = s[i + 2], y[F + 5] = s[i + 3], y[F] = _xx, y[F + 2] = _zz, F += 6 } return function (t) { t = t || {}, e.apply(this, [t]), this.geometry = new ge.geometry.geometry_data, this.position = this.geometry.add_attribute("a_position_rw", { item_size: 3, data: new Float32Array(0), stride: 32 }), this.geometry.add_attribute("a_normal_rw", { item_size: 3, stride: 32, offset: 12 }), this.geometry.add_attribute("a_uv_rw", { item_size: 2, stride: 32, offset: 24 }), this.material = t.material || new ge.terrain.patch_material; var i = this, r = t.divisor || 1; ge.load_working_image_data(t.url, function (e, s, o) { i.hdata = new Float32Array((t.size + 1) * (t.size + 1)); for (var _ = 0; _ < e.length / 4; _++)i.hdata[_] = e[4 * _] / r; for (i.data_size = t.size, g = i.hdata, v = i.data_size, E = 0, function t(e, i, r, n, s) { h = L(e, i), c = L(e - r, i - r), d = L(e + r, i - r), m = L(e + r, i + r), f = L(e - r, i + r); var a = E; return y[a] = Math.max(Math.abs(.5 * (c + d) - h), Math.abs(.5 * (f + m) - h), Math.abs(.5 * (c + f) - h), Math.abs(.5 * (d + m) - h)), n > -1 && (y[n + s] = a), r > A && (E += 5, r *= .5, y[a] = Math.max(y[a], t(e - r, i - r, r, a, 1), t(e + r, i - r, r, a, 2), t(e - r, i + r, r, a, 3), t(e + r, i + r, r, a, 4))), y[a] }(w = v / 2, w, w, -1, 0), i.QT = new Float32Array(E), _ = 0; _ < E;)i.QT[_] = y[_++]; b = 0, n.fill(255), y.fill(0), function (t, e, i, r, n) { var s = 0; for (S[R = 0] = t, S[R + 1] = e, S[R + 2] = i, S[R + 3] = s, R += 4; R > 0;)t = S[R -= 4], e = S[R + 1], i = S[R + 2], s = S[R + 3], k = r, i > T || i > A && n[s] > k ? (i *= .5, S[R] = t + i, S[R + 1] = e + i, S[R + 2] = i, S[R + 3] = n[s + 4], S[R += 4] = t - i, S[R + 1] = e + i, S[R + 2] = i, S[R + 3] = n[s + 3], S[R += 4] = t + i, S[R + 1] = e - i, S[R + 2] = i, S[R + 3] = n[s + 2], S[R += 4] = t - i, S[R + 1] = e - i, S[R + 2] = i, S[R + 3] = n[s + 1], R += 4) : (p = a[i], p.list[p.i++] = t, p.list[p.i++] = e) }(w, w, w, t.details, i.QT), P(), q(0, b, 0, 0, 1), i.position.data = new Float32Array(b / 6 * 8); var l = 0; for (_ = 0; _ < b; _ += 6)i.position.data[l] = y[_], i.position.data[l + 1] = y[_ + 1], i.position.data[l + 2] = y[_ + 2], i.position.data[l + 3] = y[_ + 3], i.position.data[l + 4] = y[_ + 4], i.position.data[l + 5] = y[_ + 5], i.position.data[l + 6] = i.position.data[l] / v, i.position.data[l + 7] = i.position.data[l + 2] / v, l += 8; i.draw_count = l / 8, i.position.data_length = l, i.position.needs_update = !0, console.log(y), console.log(i) }, t.size, t.size) } }, ge.geometry.mesh) } }()(_FM.ecs, _FM.ge, _FM.math), function (t, e, i, r) { i.register_component("ge_renderable", t.define(function (t, e) { function i(t, e, i, r) { this.entity = e, this.items = t.items || [], this.version = 0, this.layers = 0, this.set_layer(t.layer || 1) } return t.set_layer = function (t) { return t = Math.pow(2, t), this.layers & t || (this.layers |= t), this }, t.unset_layer = function (t) { return t = Math.pow(2, t), 0 != (this.layers & t) && (this.layers &= ~t), this }, t.update_bounds = function (t) { }, i.validate = function (t) { t.app.use_system("ge_render_system") }, i }, i.component)), i.register_component("ge_update", t.define(function (t, e) { function i(t, e, i, r) { this.before_update = t.before_update, this.after_update = t.after_update } return i.validate = function (t) { t.app.use_system("ge_render_system") }, i }, i.component)), i.register_system("ge_render_system", t.define(function (i, n) { function s(t, e) { return t.view_position[2] + t.transparent_layer - (e.view_position[2] + e.transparent_layer) } function a(t, e) { return t.suid = t.material.shader.uuid, e.suid = e.material.shader.uuid, t.material.shader.uuid - e.material.shader.uuid } var o, _, l, u = { mesh: null, material: null }; return i.step = function () { this.app.timer - this.fps_timer > 1 && (this.fps = this.fps_counter, this.fps_timer = this.app.timer - (this.app.timer - this.fps_timer) % this.step_size, this.fps_counter = 0), this.fps_counter++; var e, i, n, o, _ = 0, l = this.camera.ge_camera, h = !1; (this.camera_version !== l.version || this.app.timer - this.list_refereshed_timer > 4 * this.step_size) && (h = !0, this.meshes.length = 0, this.lights.length = 0, this.list_refereshed_timer = this.app.timer, this.camera_version = l.version); var c = 0, d = 0, m = 0, p = 0; if (h) { for (p = 0; p < this.multi_material_meshes.length; p++)this.multi_material_meshes.pool.free(this.multi_material_meshes.data[p]); this.multi_material_meshes.clear() } for (; null !== (e = this.app.iterate_entities("ge_update"));)e.ge_update.before_update && e.ge_update.before_update(this.app.timer); for (; null !== (e = this.app.iterate_entities("ge_renderable"));)for (i = e.ge_transform, o = e.ge_renderable, _ = 0; _ < o.items.length; _++) { if (n = o.items[_], 0 === i.require_update && 0 === n.require_update || (n.update_world_transform(i.position_world, i.scale_world, i.rotation_world), n.version = (1 + (0 | n.version)) % 99999, n.update_bounds(n.matrix_world, i), 1024 === n.item_type && n.initialize_item(), n.require_update = 0), h) if (n.render_list && n.render_list(), 4 === n.item_type && (2 & n.flags || 2 & n.material.flags)) if (n.has_multi_materials) for (p = 0; p < n.material.length; p++)u.mesh = n, u.material = n.material[p], this.meshes[d++] = this.multi_material_meshes.pool.get(u); else this.meshes[d++] = n; else if (8 === n.item_type && 2 & n.flags) n.enabled && (this.lights[c++] = n); else if (n.bounds && l.aabb_aabb(n.bounds) && l.frustum_aabb(n.bounds)) if (r.vec3.transform_mat4(n.view_position, n.world_position, l.view_inverse), 4 === n.item_type) if (n.has_multi_materials) for (p = 0; p < n.material.length; p++)u.mesh = n, u.material = n.material[p], this.meshes[d++] = this.multi_material_meshes.pool.get(u); else this.meshes[d++] = n; else 8 === n.item_type && n.enabled && (this.lights[c++] = n); o.version = (1 + (0 | o.version)) % 99999 } for (; null !== (e = this.app.iterate_entities("ge_update"));)e.ge_update.after_update && e.ge_update.after_update(this.app.timer); if (this.renderer_ready) { if (h) { for (this.meshes.length > 0 && t.merge_sort(this.meshes, this.meshes.length, a), this.flat_meshes.length = 0, this.opuque_meshes.length = 0, this.transparent_meshes.length = 0, c = 0, d = 0, m = 0, this.pickable_meshes.length = 0, _ = this.meshes.length; --_ > -1;)128 & (n = this.meshes[_]).material.flags ? (n.transparent_layer = 1e5 * n.material.transparent_layer, this.transparent_meshes[m++] = n) : 2 & n.material.flags ? this.flat_meshes[c++] = n : this.opuque_meshes[d++] = n, this.picking_mouse_x > -1 && 2048 & n.flags && (this.pickable_meshes[this.pickable_meshes.length] = n); this.transparent_meshes.length > 0 && t.merge_sort(this.transparent_meshes, this.transparent_meshes.length, s) } _ = this.meshes.length, this.renderer.timer = this.app.timer, this.renderer.render_scene(l, this.flat_meshes, this.opuque_meshes, this.transparent_meshes, this.lights), this.pickable_meshes.length > 0 && this.process_pickable_meshes() } }, i.resize = function () { var t = this.host.getBoundingClientRect(); this.renderer.set_canvas_size(t.width, t.height), this.camera.ge_camera.update_aspect(t.width / t.height) }, i.setup_host = function (t) { this.host = t, this.host.appendChild(this.renderer.canvas), setTimeout(function (t) { t.resize(), t.renderer_ready = !0 }, 50, this) }, i.process_pickable_meshes = (o = new Uint32Array(1), _ = new Uint8Array(o.buffer), l = new Float32Array(4), i.new_pick_color_id = function () { return o[0] = this.picking_color_id, _[3] = 255, l[0] = _[0], l[1] = _[1], l[2] = _[2], l[3] = _[3], uni = shader.uniforms.u_color_id_rw, uni.params[uni.params_length] = l, uni.func.apply(shader.gl, uni.params), this.picking_color_id += 32, o[0] }, function () { var t, e, i, r = this.renderer, n = 0, s = r.active_camera; for (r.render_target2.bind() && r.gl.clear(16384), r.gl_depthFunc(514), n = 0; n < this.pickable_meshes.length; n++)(e = this.pickable_meshes[n]).material.shader.pickable || (e.material.shader.pickable = e.material.shader.extend("<?=chunk('precision')?>\nuniform vec4 u_color_id_rw;\nvoid fragment(void) {\ngl_FragColor=u_color_id_rw/255.0;\n}", { fragment: !1 })), r.use_shader(e.material.shader.pickable) && (t = r.active_shader).camera_version !== s.version && (t.camera_version = s.version, (i = t.uniforms.u_view_projection_rw) && (i.params[i.params_length] = s.view_projection, i.func.apply(t.gl, i.params)), (i = t.uniforms.u_view_rw) && (i.params[i.params_length] = s.view_inverse, i.func.apply(t.gl, i.params)), (i = t.uniforms.u_view_fw) && (i.params[i.params_length] = s.fw_vector, i.func.apply(t.gl, i.params)), (i = t.uniforms.u_view_sd) && (i.params[i.params_length] = s.sd_vector, i.func.apply(t.gl, i.params)), (i = t.uniforms.u_view_up) && (i.params[i.params_length] = s.up_vector, i.func.apply(t.gl, i.params))), e.picking_color_id ? (o[0] = e.picking_color_id, _[3] = 255, l[0] = _[0], l[1] = _[1], l[2] = _[2], l[3] = _[3], (i = t.uniforms.u_color_id_rw).params[i.params_length] = l, i.func.apply(t.gl, i.params), e.picking_color_id = o[0]) : (o[0] = this.picking_color_id, _[3] = 255, l[0] = _[0], l[1] = _[1], l[2] = _[2], l[3] = _[3], (i = t.uniforms.u_color_id_rw).params[i.params_length] = l, i.func.apply(t.gl, i.params), e.picking_color_id = o[0], this.picking_color_id += 32), (i = t.uniforms.u_model_rw).params[i.params_length] = e.matrix_world, i.func.apply(t.gl, i.params), r.use_geometry(e.geometry), e.material.render_mesh(r, t, e); if (r.gl_depthFunc(513), this.picking_mouse_x > -1) { this.picking_mouse_x *= r.pixel_ratio, this.picking_mouse_y *= r.pixel_ratio, this.picking_mouse_y = r.render_height - this.picking_mouse_y, r.gl.readPixels(this.picking_mouse_x, this.picking_mouse_y, 1, 1, 6408, 5121, _); var a = o[0]; for (this.picking_mouse_x = -1, this.picking_mouse_y = -1, this.picked_mesh = null, n = 0; n < this.pickable_meshes.length; n++)if ((e = this.pickable_meshes[n]).is_picked = !1, this.picked_mesh = e, e.picking_color_id === a) { this.on_mesh_picked.params[0] = e, e.is_picked = !0, this.on_mesh_picked.trigger_params(); break } } }), function (i) { n.apply(this, arguments), this.priority = 1e4, this.renderer = new e.renderer(i.renderer), this.renderer_ready = !1, console.log("ge_render_system", this), this.lights = [], this.meshes = [], this.flat_meshes = [], this.opuque_meshes = [], this.transparent_meshes = [], this.camera_version = -1, this.list_refereshed_timer = 0, this.fps_counter = 0, this.fps_timer = 0, this.fps = 0, this.pickable_meshes = [], this.picking_color_id = 4096, this.picking_mouse_x = -1, this.picking_mouse_y = -1, this.on_mesh_picked = new e.event(this, [null]); var r = this; r.multi_material_meshes = new e.array, r.multi_material_meshes.pool = new t.object_pooler_ext(function () { return {} }, function (t, e) { return t.material = e.material, t.matrix_world = e.mesh.matrix_world, t.world_position = e.mesh.world_position, t.bounds_sphere = e.mesh.bounds_sphere, t.flags = e.mesh.flags, t.geometry = e.mesh.geometry, t.view_position = e.mesh.view_position, t.draw_offset = e.mesh.draw_offset, t.draw_count = e.mesh.draw_count, r.multi_material_meshes.push(t), t }), this.multi_material_meshes.pool.on_free = function (t) { t.material = void 0, t.matrix_world = void 0, t.world_position = void 0, t.bounds_sphere = 0, t.flags = 0, t.geometry = void 0, t.view_position = void 0, t.draw_offset = void 0, t.draw_count = void 0 }, this.camera = i.camera || this.app.create_entity({ components: { ge_transform: {}, ge_transform_controller: {}, ge_camera: {} } }), this.setup_host(i.host) } }, i.system)) }(_FM.fin, _FM.ge, _FM.ecs, _FM.math), function (t, e, i, r) { i.register_component("skeleton_item", t.define(function (t, e) { var i = []; function n(t, e, i, r) { this.entity = e, this.app = i, this.skinned_joints = [], this.joints = [], this.joints_names = [], this.display = t.display; var n = this; this.on_joint_display = t.on_joint_display, t.joints.forEach(function (e, i) { n.add_joint(e, i, t.all_skin_joints) }) } return t.add_joint = function (t, e, n) { var s = this.app.create_entity({ components: { ge_transform: { position: t.position || t.pos, rotation: t.rotation || t.rot, scale: t.scale } } }); return t.eular && s.ge_transform.rotate_eular(t.eular[0], t.eular[1], t.eular[2]), Object.assign(s, { name: t.name || "joint" + e, length: 0, parent: null, skin_index: n ? e : t.skin_index }), void 0 !== t.skin_index && (s.skin_index = t.skin_index), void 0 === s.skin_index && (s.skin_index = -1), s.skin_index > -1 && (s.bind_transform = s.bind_transform || r.dquat(), s.joint_transform = s.joint_transform || r.dquat(), t.bind_pos && 16 === t.bind_pos.length ? (s.set_bind_pos = !1, r.mat4.copy(i, t.bind_pos), def.pre_scale && (i[12] *= def.pre_scale[0], i[13] *= def.pre_scale[1], i[14] *= def.pre_scale[2]), r.dquat.from_mat4(s.bind_transform, i)) : s.set_bind_pos = !0), s.ge_transform.bind_pos = r.vec3(), s.ge_transform.bind_rot = r.quat(), void 0 !== t.pn && (t.pr = this[t.pn].index), void 0 === t.pr && e > 0 ? (s.ge_transform.parent = this.joints[e - 1].ge_transform, s.parent = this.joints[e - 1]) : t.pr > -1 && (s.ge_transform.parent = this.joints[t.pr].ge_transform, s.parent = this.joints[t.pr]), s.index = this.joints.length, this[s.name] = s, this.joints[this.joints.length] = s, s.skin_index > -1 && (this.skinned_joints[s.skin_index] = s), s }, n.validate = function (t) { t.app.use_system("skeleton_system") }, n }, i.component)), i.register_system("skeleton_system", t.define(function (t, i) { var n, s, a, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y, b, E = r.dquat(); t.step = function () { var t, e, i, r = 0; for (this.skeletons_count = 0; null !== (t = this.app.iterate_entities("skeleton_item"));)for (e = t.skeleton_item, t.ge_transform, this.skeletons[this.skeletons_count++] = e, e.initialized || this.initialize_skeleton(e), r = 0; r < e.skinned_joints.length; r++)(i = e.skinned_joints[r]) && 0 !== i.ge_transform.require_update && ((n = E)[0] = i.ge_transform.rotation_world[0], n[1] = i.ge_transform.rotation_world[1], n[2] = i.ge_transform.rotation_world[2], n[3] = i.ge_transform.rotation_world[3], s = .5 * i.ge_transform.position_world[0], a = .5 * i.ge_transform.position_world[1], o = .5 * i.ge_transform.position_world[2], _ = n[0], l = n[1], u = n[2], h = n[3], n[4] = s * h + a * u - o * l, n[5] = a * h + o * _ - s * u, n[6] = o * h + s * l - a * _, n[7] = -s * _ - a * l - o * u, n = i.joint_transform, c = E, d = i.bind_transform, s = c[0], a = c[1], o = c[2], m = c[3], p = c[4], f = c[5], g = c[6], v = c[7], _ = d[0], l = d[1], u = d[2], h = d[3], w = d[4], x = d[5], y = d[6], b = d[7], n[0] = s * h + m * _ + a * u - o * l, n[1] = a * h + m * l + o * _ - s * u, n[2] = o * h + m * u + s * l - a * _, n[3] = m * h - s * _ - a * l - o * u, n[4] = s * b + m * w + a * y - o * x + p * h + v * _ + f * u - g * l, n[5] = a * b + m * x + o * w - s * y + f * h + v * l + g * _ - p * u, n[6] = o * b + m * y + s * x - a * w + g * h + v * u + p * l - f * _, n[7] = m * b - s * w - a * x - o * y + v * h - p * _ - f * l - g * u) }, t.setup_skeleton_display = function (t) { var i = new e.shading.shaded_material({ ambient: [.25, .25, .25], wireframe: !1 }); i.shader = i.shader.extend("\n\nuniform vec4 u_joint_qr;\nuniform vec3 u_bone_start;\nuniform vec3 u_bone_end;\n<?=chunk('quat-dquat')?>\n\nvoid vertex(){\n  super_vertex();\n   v_position_rw=vec4(a_position_rw,1.0);\n  float len=length((u_bone_end-u_bone_start));\n  v_position_rw.xz*=min(len,1.0);\n  v_position_rw.y*=len;\n  v_position_rw.xyz=quat_transform(u_joint_qr,v_position_rw.xyz);\n  v_position_rw.xyz+=u_bone_start;\n  gl_Position=u_view_projection_rw*v_position_rw;\n\n}\n\n"), i.complete_render_mesh = function (t, e, i) { var r, n, s, a; for (r = 0; r < i.sk_system.skeletons_count; r++)if ((a = i.sk_system.skeletons[r]).display) for (n = 0; n < a.joints.length; n++)(s = a.joints[n]) && s.ge_transform.parent && (e.set_uniform("u_bone_end", s.ge_transform.position_world), e.set_uniform("u_bone_start", s.ge_transform.parent.position_world), e.set_uniform("u_joint_qr", s.ge_transform.parent.rotation_world), a.on_joint_display && a.on_joint_display(s, e, this), t.gl.drawElements(this.final_draw_type, this.final_draw_count, 5125, 0)) }, i.flags += 16; var r = e.geometry.shapes.cube({ width: 3, depth: 3 }); for (A = 0; A < r.attributes.a_position_rw.data.length; A += 3)r.attributes.a_position_rw.data[A + 1] > .3 && (r.attributes.a_position_rw.data[A] *= .15, r.attributes.a_position_rw.data[A + 2] *= .15); r.scale_position_rotation(.1, 1, .1, 0, .5, 0, 0, 0, 0); var n = new e.geometry.mesh({ material: i, geometry: r, flags: 2 }); n.sk_system = this, t.root.ge_renderable.items.push(n) }, t.initialize_skeleton = function (t) { t.initialized || (this.set_bind_pos(t), t.initialized = !0) }; var A = 0, z = r.vec3(); function T(t) { i.apply(this, arguments), this.skeletons = [], this.skeletons_count = 0 } return t.set_bind_pos = function (t) { for (A = 0; A < t.joints.length; A++)joint = t.joints[A], joint.skin_index > -1 && joint.set_bind_pos && (r.dquat.from_quat_pos(joint.bind_transform, joint.ge_transform.rotation_world, joint.ge_transform.position_world), r.dquat.invert(joint.bind_transform, joint.bind_transform)), void 0 !== joint.ge_transform.parent ? (r.vec3.subtract(z, joint.ge_transform.position_world, joint.ge_transform.parent.position_world), joint.length = r.vec3.get_length(z)) : joint.length = r.vec3.get_length(joint.ge_transform.position_world) }, t.set_zero_pos = function (t) { for (A = 0; A < t.joints.length; A++)joint = t.joints[A], joint.set_bind_pos = !0, void 0 !== joint.ge_transform.parent && (joint.transform.position[0] = joint.transform.position_world[0] - joint.transform.parent.position_world[0], joint.transform.position[1] = joint.transform.position_world[1] - joint.transform.parent.position_world[1], joint.transform.position[2] = joint.transform.position_world[2] - joint.transform.parent.position_world[2], joint.ge_transform.rotation[0] = 0, joint.ge_transform.rotation[1] = 0, joint.ge_transform.rotation[2] = 0, joint.ge_transform.rotation[3] = 1) }, t.validate = function (t) { this.priority = t.use_system("ge_transform_system").priority + 100, this.setup_skeleton_display(t) }, T.mesh = e.define(function (t, e) { var i, n, s, a, o, _, l = (i = r.quat(), n = r.quat(), s = null, a = null, o = null, _ = 0, function (t, e, r) { for (a = r.skeleton_item, _ = 0; _ < a.skinned_joints.length; _++)o = a.skinned_joints[_], s = o.joint_transform, i[0] = s[0], i[1] = s[1], i[2] = s[2], i[3] = s[3], n[0] = s[4], n[1] = s[5], n[2] = s[6], n[3] = s[7], e.set_uniform("joint_qr[" + _ + "]", i), e.set_uniform("joint_qd[" + _ + "]", n) }); return t.initialize_item = function () { var t; this.item_type = 4, this.geometry.attributes.a_joints_indices || console.log(skin_geometry), (t = this.material).shader.skin_shader || (t.shader = t.shader.extend(glsl["skinned-mesh"]), t.on_before_render.add(l), t.shader.skin_shader = !0) }, function (t) { t = t || {}, e.apply(this, [t]), this.skeleton_item = t.skeleton_item } }, e.renderable), T.skin_material = function (t) { t.shader = t.shader.extend("\nattribute vec4 a_joints_indices;\nattribute vec4 a_joints_weights;\n\nuniform vec4 joint_qr[60];\nuniform vec4 joint_qd[60];\n\nvec3 dquat_transform(vec4 qr, vec4 qd, vec3 v)\n{\n   return (v + cross(2.0 * qr.xyz, cross(qr.xyz, v) + qr.w * v))+\n\t  (2.0 * (qr.w * qd.xyz - qd.w * qr.xyz + cross(qr.xyz, qd.xyz)));\n}\nvec3 dquat_transform2(vec4 qr, vec4 qd, vec3 v)\n{\n   return (v + cross(2.0 * qr.xyz, cross(qr.xyz, v) + qr.w * v));\n}\n\nvec4 _qr;\nvec4 _qd;\nvec4 att_position(void){\nvec4 pos=super_att_position();\nvec4 w=a_joints_weights;\nint i0=int(a_joints_indices.x);\nint i1=int(a_joints_indices.y);\nint i2=int(a_joints_indices.z);\nint i3=int(a_joints_indices.w);\n\n\nvec4 dqr0 = joint_qr[i0];\nvec4 dqr1 = joint_qr[i1];\nvec4 dqr2 = joint_qr[i2];\nvec4 dqr3 = joint_qr[i3];\nif (dot(dqr0, dqr1) < 0.0) w.y *= -1.0;\nif (dot(dqr0, dqr2) < 0.0) w.z *= -1.0;\nif (dot(dqr0, dqr3) < 0.0) w.w *= -1.0;\n\n_qr=w.x*dqr0+w.y*dqr1+w.z*dqr2+w.w*dqr3;\n_qd=w.x*joint_qd[i0]+w.y*joint_qd[i1]+w.z*joint_qd[i2]+w.w*joint_qd[i3];\nfloat len =1.0/ length(_qr);\n_qr *= len;\n_qd *= len;\n\npos.xyz=dquat_transform(_qr,_qd,pos.xyz);\n\nreturn pos;\n\n}\nvec4 att_normal(void){\n    return vec4(dquat_transform2(_qr,_qd,a_normal_rw),0.0);\n}\n\nvoid vertex(){\nsuper_vertex();\n\nv_uv_rw=a_position_rw.xy;\n}\n\n\n"); var e = r.quat(), i = r.quat(), n = null, s = null, a = null, o = 0; return t.on_before_render.add(function (t, r, _) { for (s = _.skeleton_item, o = 0; o < s.skinned_joints.length; o++)a = s.skinned_joints[o], n = a.joint_transform, e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], i[0] = n[4], i[1] = n[5], i[2] = n[6], i[3] = n[7], r.set_uniform("joint_qr[" + o + "]", e), r.set_uniform("joint_qd[" + o + "]", i) }), t }, T }, i.system)) }(_FM.fin, _FM.ge, _FM.ecs, _FM.math), function (t, e, i, r) { i.register_component("animations_player", t.define(function (t, e) { function i(t, e, i, r) { this.entity = e, this.clock = 0, this.animations = t.animations || [], this.anim_data = new Float32Array(1024) } return i.validate = function (t) { t.app.use_system("animation_system") }, i }, i.component)), i.register_system("animation_system", t.define(function (t, e) { var i, n, s, a, o, _, l, u, h, c, d, m, p, f = new Float32Array(4); return t.run_animation = function (t, e, g) { for (f.fill(0), i = 0; i < t.blocks.length; i++)if (e >= (n = t.blocks[i]).time && e <= n.time + n.length) { if (a = (e - n.time) / n.length, c = n.frames, s = n.fr_size || 1, n.flat) d = Math.floor(c.length / s) - 1, m = 1 / d, u = Math.floor(d * a), h = (u + 1) * s, p = m * u, u *= s, _ = (a - p) / (p + m - p), s++, u -= 1, h -= 1; else { for (s++, o = 0; o <= c.length; o += s) { if (o > 0 && a >= _ && a <= c[o] + 1e-6) { l = o; break } _ = c[o] } h = l, _ = (a - c[u = l - s]) / (c[h] - c[u]) } for (2 === s ? f[0] = c[u + 1] + (c[h + 1] - c[u + 1]) * _ : 3 === s ? (f[0] = c[u + 1] + (c[h + 1] - c[u + 1]) * _, f[1] = c[u + 2] + (c[h + 2] - c[u + 2]) * _) : 4 === s ? (f[0] = c[u + 1] + (c[h + 1] - c[u + 1]) * _, f[1] = c[u + 2] + (c[h + 2] - c[u + 2]) * _, f[2] = c[u + 3] + (c[h + 3] - c[u + 3]) * _) : 5 === s && r.quat.slerp_flat(f, c[u + 1], c[u + 2], c[u + 3], c[u + 4], c[h + 1], c[h + 2], c[h + 3], c[h + 4], _), o = 0; o < s - 1; o++)g[n.oi + o] += f[o] } }, t.compile_animation = function (t) { }, t.step = function () { for (var t, e, i, r = 0; null !== (t = this.app.iterate_entities("animations_player"));) { for (t.ge_transform, (e = t.animations_player).anim_data.fill(0), r = 0; r < e.animations.length; r++)(i = e.animations[r]).duration = i.duration || 1, this.run_animation(i, e.clock % i.duration / i.duration, e.anim_data); e.clock += this.app.current_time_delta } }, t.validate = function (t) { this.priority = t.use_system("ge_transform_system").priority - 50 }, function (t) { e.apply(this, arguments) } }, i.system)) }(_FM.fin, _FM.ge, _FM.ecs, _FM.math), function (t, e, i, r) { i.register_system("particles_system", t.define(function (e, i) { function r(t) { i.apply(this, arguments), this.emitters = {}, this.base_emitter = r.emitter, this.clock = 0 } return e.step = function () { for (var t in this.emitters) this.emitters[t].update(this.app.timer, this.app.current_time_delta) }, e.validate = function (t) { this.priority = t.use_system("ge_transform_system").priority - 50 }, e.add_emitter = function (t, e) { return e.is_emitter || (e = new r.emitter(e)), this.emitters[t] = e, e }, r.emitter = t.define(function (e) { var i, r, n, s, a, o, _; return e.create_instance = function (t) { var e = this.use_instance(this.instances.get()); return t && Object.assign(e, t), this.active_instances.enqueue(e), e }, e.update_particle = function (t, e) { }, e.use_particle = function (t, e) { return t[0] = 1, t[1] = .1, t }, e.update = (a = [], o = 0, _ = 0, function (t, e) { for (this.pi = 0, (s = this.active_instances.size()) < this.active_instances._oldestIndex && this.active_instances.realign(); s > 0;) { if (r = this.active_instances.dequeue(), o = r.pi, i = r.rate, r.life > 0) { if (t - r.last_clock > r.emit_delay) { if (i > 1) for (; i > 0 && o < r.max_particles;)(n = this.use_particle(this.particles.get(), r))[0] = t, r.active_particles[o++] = n, i--; else o < r.max_particles && ((n = this.use_particle(this.particles.get(), r))[0] = t, r.active_particles[o++] = n); r.last_clock = t } r.life -= r.life_decay * e, this.active_instances.enqueue(r) } else this.instances.free(r); for (_ = 0; o > 0;)(n = r.active_particles[--o])[1] < 0 || t - n[0] < n[1] ? (a[_++] = n, this.active_particles[this.pi++] = n, this.update_particle(n, r, e)) : this.particles.free(n); for (o = 0; _ > 0;)r.active_particles[o++] = a[--_]; r.pi = o, s-- } }), e.create_particle = function () { return new Float32Array(this.particle_size) }, e.use_instance = function (t) { return t }, function (e) { var i = this; this.is_emitter = !0, this.instances = new t.object_pooler(function () { return { max_particles: 10, last_clock: 0, emit_delay: .2, life: 1, life_decay: 0, active_particles: [], pi: 0, rate: 1 } }), this.active_instances = new t.queue, this.active_particles = [], this.pi = 0, this.particle_size = 2, this.particles = new t.object_pooler(function () { return i.create_particle() }), e && Object.assign(this, e), this.particles.refs = {} } }), r }, i.system)), i.register_system("worker_particles_system", t.define(function (i, r) { i.step = function () { for (var t in this.emitters) this.emitters[t].update(this.app.timer, this.app.current_time_delta) }; var n = { init: function (t) { t.is_function = function (t) { return !!(t && t.constructor && t.call && t.apply) }, t.define = function (t, e) { e = e || Object; var i = {}; Object.assign(i, e.prototype); var r = t(i, e); return r.super_class = e, r.prototype = Object.create(e.prototype), Object.assign(r.prototype, i), r }, t.rg = function (t, e) { null !== t && t.forEach(e) }, t.parse_args_from_func = function (e) { var i; return t.rg(e.match(/function.*\(.*\)/), function (t) { (i = t.replace(/function.*\(/, "").replace(")", "").split(",")).forEach(function (t, e) { i[e] = t.trim() }) }), i || [] }, t.prep_worker = function () { var e, i = []; for (var r in t) this.is_function(t[r]) && (e = t[r].toString()).indexOf("[native code]") < 0 && (console.log(r, t.parse_args_from_func(e)), i.push(e)); t.postMessage(["prep_worker", [i]]) }, t.onmessage = function (t) { this[t.data[0]].apply(this, t.data[1]) } }, queue: function (t) { t.queue = t.define(function (t) { return t.size = function () { return this._newestIndex - this._oldestIndex }, t.enqueue = function (t) { this._storage[this._newestIndex] = t, this._newestIndex++ }, t.realign = function () { let t = this.size(), e = 0; for (e = 0; e < t; e++)this._storage[e + 1] = this._storage[this._oldestIndex + e]; for (e = this._oldestIndex; e < this._newestIndex; e++)this._storage[e] = void 0; this._oldestIndex = 1, this._newestIndex = this._oldestIndex + t }, t.dequeue = function () { if (this._oldestIndex !== this._newestIndex) { var t = this._storage[this._oldestIndex]; return this._storage[this._oldestIndex] = void 0, this._oldestIndex++, t } }, t.peek = function () { return this._storage[this._oldestIndex] }, function () { this._oldestIndex = 1, this._newestIndex = 1, this._storage = {} } }) }, object_pooler: function (t) { t.object_pooler = t.define(function (t) { return t.get = function (t) { return this.freed > 0 ? this.reuse ? this.reuse(this.free_objects[--this.freed], t) : this.free_objects[--this.freed] : this.allocated >= this.pool_size ? null : (this.allocated++, this.creator(t)) }, t.free = function (t) { this.free_objects[this.freed++] = t }, function (t, e, i) { this.creator = t, this.reuse = e, this.allocated = 0, this.freed = 0, this.pool_size = i || 1 / 0, this.free_objects = [] } }) }, ping_pong_array: function (t) { t.ping_pong_array = t.define(function (t) { var e; return t.swap = function () { e = this[this.ping_name], this[this.ping_name] = this[this.pong_name], this[this.pong_name] = e, e = void 0 }, function (t, e) { this.ping_name = t, this.pong_name = e, this[t] = [], this[e] = [] } }) } }; function a(e, i, r) { return r ? i.forEach(function (i) { i && (t.is_function(i) ? e.push("(" + r(i.toString()) + ")(self)") : e.push("(" + r(n[i].toString()) + ")(self)")) }) : i.forEach(function (i) { i && (t.is_function(i) ? e.push("(" + i.toString() + ")(self)") : e.push("(" + n[i].toString() + ")(self)")) }), e } return n.init_emitter = function (t) { t.def = { particle_size: 4 }; var e, i, r = 0, n = 0, s = 0, a = 0, o = 0, _ = 0, l = 1; t.particles_pool = new t.object_pooler(function (t) { return new Float32Array(t) }), t.instances_pool = new t.object_pooler(function () { return e = { last_emit_time: 0, emit_delay: .2, life: 0, life_start: 0, id: l++ }, t.instances_pool.ref[e.id] = e, e }), t.instances_pool.ref = {}, t.active_particles = new t.ping_pong_array("queue", "updates"), t.active_instances = new t.ping_pong_array("queue", "updates"); var u, h = 0, c = 0, d = 0, m = 0; t.run_command = function (t, e, i) { }, t.trigger_emitter = function (t) { }, t.use_instance = function (t, e, i) { return t }, t.use_particle = function (t, e) { return t }, t.queue_particle = function (t, e, n) { return (i = this.particles_pool.get(this.def.particle_size))[0] = e, i[1] = r + t, i[2] = n, this.active_particles.queue[this.pi++] = i, i }, t.pi = 0, t.ii = 0, t.time = 0, t.time_delta = 0, t.onmessage = function (t) { for (h = 0, this.data = new Float32Array(t.data[0]), u = this.data, d = u[h++]; h < d;)c = u[h++], 100 === (m = u[h++]) ? (r = u[h], this.time = r, s = r - n, this.time_delta = s, n = r) : 200 === m ? ((e = this.instances_pool.get()).type = u[h], e.life = u[h + 1], e.emit_delay = u[h + 2], e.life_start = r, e.last_emit_time = r - 2 * e.emit_delay, this.use_instance(e, u, h + 3), this.active_instances.queue[this.ii++] = e) : this.run_command(m, u, h), h += c; for (a = 0; this.ii > 0;)e = this.active_instances.queue[--this.ii], this.active_instances.queue[this.ii] = void 0, e.life < 0 || r - e.life_start < e.life ? (r - e.last_emit_time > e.emit_delay && (e.last_emit_time = r, this.trigger_emitter(e)), this.active_instances.updates[a++] = e) : this.instances_pool.free(e); this.ii = a, this.active_instances.swap(), _ = 0; for (var o = this.active_particles; this.pi > 0;)i = o.queue[--this.pi], o.queue[this.pi] = void 0, r - i[1] > 0 ? i[2] < 0 || r - i[1] < i[2] ? (e = this.instances_pool.ref[i[0]], this.update_particle(i, e, s), o.updates[_++] = i) : this.particles_pool.free(i) : (r - i[1] > 0 && (i[1] = r), o.updates[_++] = i); this.pi = _, o.swap(), this.submit_data(u) }, t.submit_data = function (t) { for (h = 2, o = this.def.particle_size, _ = this.pi; _ > 0;)for (i = this.active_particles.queue[--_], t[h++] = this.instances_pool.ref[i[0]].type, t[h++] = (r - i[1]) / i[2], a = 2; a < o; a++)t[h++] = i[a]; t[0] = h, t[1] = o, this.postMessage([this.data.buffer], [this.data.buffer]) } }, n.generic_emitter = function (t) { var e; t.def.particle_size = 10, t.on_particle_update = function (t, e, i) { }, t.update_particle = function (t, e, i) { t[3] += t[6] * i, t[4] += t[7] * i, t[5] += t[8] * i, t[7] -= t[8] * i, this.on_particle_update(t, e, i) }, t.use_instance = function (t, e, i) { t.x = e[i], t.y = e[i + 1], t.z = e[i + 2], t.particle_life = e[i + 3] }, t.trigger_emitter = function (t) { (e = this.queue_particle(0, t.id, t.particle_life))[3] = t.x, e[4] = t.y, e[5] = t.z, e[6] = 3 * (Math.random() - .5), e[7] = 2 * Math.random() + 1, e[8] = 3 * (Math.random() - .5), e[9] = -.8 }, console.log(t) }, i.define_emitter = function (t, e, i) { e = e || {}; var r = a([], ["init", "queue", "object_pooler", "ping_pong_array", "init_emitter"], function (t) { return t.replace("//[em_def]", "Object.assign(em.def," + JSON.stringify(e) + ");") }); a(r, i); var n = function (t) { return new Worker(window.URL.createObjectURL(new Blob([t.join(";")]))) }(r); e.data_size = e.data_size || 102400, Object.assign(n, e), n.is_working = !0, n.data = new Float32Array(e.data_size), n.command_data = new Float32Array(5120), n.ci = 0, n.system = this, n.data_callback = !1, n.on_data = e.on_data || function (t, e, i) { }, n.onmessage = function (t) { this.data = new Float32Array(t.data[0]), this.data_callback = !0, this.on_data(this.data, 2, this.data[0]), this.data_callback = !1 }; var s = 0; return n.push_command = function (t) { for (this.command_data[this.ci++] = t.length - 1, s = 0; s < t.length; s++)this.command_data[this.ci++] = t[s] }, n.update = function (t, e) { if (!this.data_callback && this.data.buffer.byteLength > 0) { for (this.data[1] = 1, this.data[2] = 100, this.data[3] = t, this.data[4] = e, s = 0, this.data[0] = this.ci + 4; s < this.ci;)this.data[s + 4] = this.command_data[s++]; this.postMessage([this.data.buffer], [this.data.buffer]), this.ci = 0 } }, this.emitters[t] = n, n }, i.validate = function (t) { this.priority = t.use_system("ge_transform_system").priority - 50 }, i.create_quad_particle_emitter = function () { var t, i = new e.shading.material({ shader: e.shading.material.shader.extend("\nattribute vec4 a_particle_pos_rw;\nvarying vec4 v_particle_pos_rw;\nvec4 att_position(void){\n    return vec4(((a_position_rw.xyz)+a_particle_pos_rw.xyz),1.0);\n}\nvoid vertex(){\n\tsuper_vertex();\nv_particle_pos_rw=a_particle_pos_rw;\n\n}\nvarying vec4 v_particle_pos_rw;\nvoid fragment(){\n\tsuper_fragment();\n}\n") }); i.complete_render_mesh = (t = i.complete_render_mesh, function (e, i, r) { r.emitter.renderer = e, this.instances_count = r.geometry.instances_count, this.instances_count > 0 && t.apply(this, [e, i, r]) }); var r = e.geometry.geometry_data.create({ vertices: new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, -.5, 0, .5, .5, 0, -.5, .5, 0]), attr: { a_particle_pos_rw: { item_size: 4, buffer_type: 35048, divisor: 1 } } }); return r.instances_count = -1, r.create_emitter = function (t) { this.emitter = t.define_emitter("quad_particle_emitter", {}, ["generic_emitter", function (t) { t.submit_data = function (t) { for (var e = 0, i = this.pi; i > 0;)par = this.active_particles.queue[--i], t[e++] = par[3], t[e++] = par[4], t[e++] = par[5], t[e++] = 1; t[t.length - 1] = e, this.postMessage([this.data.buffer], [this.data.buffer]) } }]), this.emitter.on_data = function (t) { this.renderer && (null === this.geo.attributes.a_particle_pos_rw.buffer && (this.geo.attributes.a_particle_pos_rw.buffer = this.renderer.gl.createBuffer()), this.renderer.gl.bindBuffer(34962, this.geo.attributes.a_particle_pos_rw.buffer), this.renderer.gl.bufferData(34962, t, 35048, 0, t[t.length - 1]), this.geo.instances_count = t[t.length - 1] / 4) }, this.emitter.geo = this }, function (t) { r.emitter || r.create_emitter(this); var n = new e.geometry.mesh({ geometry: r, material: i }); return n.emitter = r.emitter, n } }(), i.create_point_particle_emitter = function () { var t = new e.shading.material({ shader: e.webgl.shader.parse("\n<?=chunk('precision')?>\n\nattribute vec4 a_position_rw;\n\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\n\nvoid vertex(void){\n\n  gl_Position=u_view_projection_rw*vec4(a_position_rw.xyz,1.0);\n  gl_PointSize =5.0;\n\n\n\n\n}\n<?=chunk('precision')?>\n\nvoid fragment(void) {\n    gl_FragColor =vec4(1.0);\n}\n\n\n") }); t.render_mesh = function (t, e, i) { i.emitter.renderer = t, i.geometry.instances_count > 0 && (t.gl.enable(3042), t.gl.blendFunc(770, 771), t.gl.depthMask(!1), t.use_texture(this.texture, 0), t.gl.bindBuffer(34962, i.emitter.a_particle_pos_buffer), t.gl.vertexAttribPointer(0, 4, 5126, !1, 16, 0), t.gl.drawArrays(0, 0, i.geometry.instances_count), t.gl.disable(3042), t.gl.depthMask(!0)) }; var i = e.geometry.geometry_data.create({ vertices: new Float32Array(0), vertex_size: 4 }); return i.instances_count = -1, i.create_emitter = function (t) { this.emitter = t.define_emitter("quad_particle_emitter", {}, ["generic_emitter", function (t) { t.submit_data = function (t) { for (var e = 0, i = this.pi; i > 0;)par = this.active_particles.queue[--i], t[e++] = par[3], t[e++] = par[4], t[e++] = par[5], t[e++] = 1; t[t.length - 1] = e, this.postMessage([this.data.buffer], [this.data.buffer]) } }]), this.emitter.on_data = function (t) { this.renderer && (this.a_particle_pos_buffer || (this.a_particle_pos_buffer = this.renderer.gl.createBuffer()), this.renderer.gl.bindBuffer(34962, this.a_particle_pos_buffer), this.renderer.gl.bufferData(34962, t, 35048, 0, t[t.length - 1]), this.geo.instances_count = t[t.length - 1] / 4) }, this.emitter.geo = this }, function (r) { i.emitter || i.create_emitter(this); var n = new e.geometry.mesh({ geometry: i, material: t }); return n.emitter = i.emitter, n } }(), i.create_point_particle_emitter = function () { var t = new e.shading.material({ shader: e.webgl.shader.parse("\n<?=chunk('precision')?>\n\nattribute vec4 a_position_rw;\n\nuniform vec4 u_texture_sets_rw[10];\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\n\nvarying float v_life_rw;\nvarying float v_life_blend;\nvarying vec4 v_texture_set_rw;\nvarying vec2 v_texture_coord1_rw;\nvarying vec2 v_texture_coord2_rw;\n\nvoid vertex(void){\n\nv_life_rw= fract(a_position_rw.w);\n\n  int texture_set =int(fract(a_position_rw.w * 256.0)*255.0);\n  float size = (fract(a_position_rw.w * 65536.0)*255.0)*50.0;\n\n  v_texture_set_rw=u_texture_sets_rw[texture_set];\n\n  gl_Position=u_view_projection_rw*vec4(a_position_rw.xyz,1.0);\n\n \n\n\n\n    float d=v_texture_set_rw.z/v_texture_set_rw.w;\n\n    float lf=((1.0-v_life_rw)/(1.0/d));\ngl_PointSize =size/gl_Position.w;\n\n    v_life_blend=fract(lf);\n\n    v_texture_coord1_rw=vec2(floor(lf)*v_texture_set_rw.w,0.0);\n    v_texture_coord2_rw=vec2(v_texture_coord1_rw.x+v_texture_set_rw.w,v_texture_coord1_rw.y);\n\n    v_texture_coord2_rw=v_texture_coord1_rw;\n\n\n\n\n}\n<?=chunk('precision')?>\nuniform sampler2D u_texture_rw;\n\nvarying float v_life_rw;\nvarying float v_life_blend;\nvarying vec4 v_texture_set_rw;\nvarying vec2 v_texture_coord1_rw;\nvarying vec2 v_texture_coord2_rw;\n\nvec2 rotcoord(vec2 c,vec2 p,float r){\n\n\nreturn vec2((cos(r) * (p.x-c.x)  + sin(r) * (p.y-c.y))+c.x,               (cos(r) * (p.y-c.y)  - sin(r) * (p.x-c.x))+c.y );\n\n return vec2(cos(r) * (p.x)  + sin(r) * (p.y),               cos(r) * (p.y)  - sin(r) * (p.x) );\n\n\n//return p;\n \n}\nvoid fragment(void) {\n     vec2 coords =gl_PointCoord*v_texture_set_rw.w+v_texture_set_rw.xy;\n\ngl_FragColor =mix( texture2D(u_texture_rw, coords+v_texture_coord1_rw),\n    texture2D(u_texture_rw, coords+v_texture_coord2_rw),v_life_blend);\ngl_FragColor= texture2D(u_texture_rw, coords+v_texture_coord1_rw);\n//gl_FragColor.g=gl_FragColor.r;\n//gl_FragColor.b=gl_FragColor.r;\n\n//gl_FragColor.rgb*=vec3(8.0);\n\n//gl_FragColor.rgb = vec3(1.0 - gl_FragColor.r,1.0 -gl_FragColor.g,1.0 -gl_FragColor.b);\ngl_FragColor.w*=0.099;\n\n}\n\n\n"), transparent_layer: 100 }); t.render_mesh = function (t, e, i) { if (i.emitter.renderer = t, i.emitter.instances_count > 0) { for (t.gl_enable(3042), t.gl_blendFunc(770, 771), t.gl_depthMask(!1), t.use_texture(this.texture, 0), t.gl.bindBuffer(34962, i.emitter.a_particle_pos_buffer), t.gl.vertexAttribPointer(0, 4, 5126, !1, 16, 0), t.use_texture(i.texture, 0), s = 0; s < i.texture_sets.length; s++)e.set_uniform("u_texture_sets_rw[" + s + "]", i.texture_sets[s]); t.gl.drawArrays(i.draw_type, 0, i.emitter.instances_count), t.gl_disable(3042), t.gl_depthMask(!0) } }; var i = e.geometry.geometry_data.create({ vertices: new Float32Array(0), vertex_size: 4 }); return function (r) { var n = new e.geometry.mesh({ geometry: i, material: t }); if (n.emitter = this.define_emitter("point_particle_emitter", { on_data: function (t) { this.renderer && (this.a_particle_pos_buffer || (this.a_particle_pos_buffer = this.renderer.gl.createBuffer()), this.renderer.gl.bindBuffer(34962, this.a_particle_pos_buffer), this.renderer.gl.bufferData(34962, t, 35048, 0, t[t.length - 1]), this.instances_count = t[t.length - 1] / 4) } }, ["generic_emitter", function (t) { var e, i, r = new Uint32Array(1), n = new Uint8Array(4); t.pack_life_texture_size = function (t, e) { }, t.submit_data = function (t) { for (e = 0, i = this.pi; i > 0;)par = this.active_particles.queue[--i], t[e++] = par[3], t[e++] = par[4], t[e++] = par[5], n[0] = (this.time - par[1]) / par[2] * 255, n[1] = 0, n[2] = 10, this.pack_life_texture_size(n, par), r[0] = n[0] << 16 | n[1] << 8 | n[2], t[e++] = r[0] / (1 << 24); t[t.length - 1] = e, this.postMessage([this.data.buffer], [this.data.buffer]) } }, r.emitter]), n.texture = r.texture, n.texture_sets = [], r.texture && (this.texture = r.texture, r.texture_sets)) { var s = r.texture.width, a = r.texture.height; r.texture_sets.forEach(function (t, e) { (t = new Float32Array(t))[0] /= s, t[1] /= a, t[2] /= s, t[3] /= a, n.texture_sets.push(t) }) } return n.emitter.emit_intance = function () { }, n.draw_type = 0, console.log(n), n } }(), function (t) { r.apply(this, arguments), this.emitters = {} } }, i.system)) }(_FM.fin, _FM.ge, _FM.ecs, _FM.math), function (t, e) { t.active_mesh = t.define(function (t, i) { var r = e.quat(), n = e.vec3(); return t.update_world_transform = function (t, i, s) { e.quat.mult(r, s, this.rotation), e.mat4.from_quat(this.matrix_world, r), n[0] = i[0] * this.scale[0], n[1] = i[1] * this.scale[1], n[2] = i[2] * this.scale[2], e.mat4.scale(this.matrix_world, n), this.matrix_world[12] = t[0] + this.position[0], this.matrix_world[13] = t[1] + this.position[1], this.matrix_world[14] = t[2] + this.position[2] }, function (t) { t = t || {}, i.apply(this, [t]), this.position = e.vec3(t.position), this.scale = e.vec3(t.scale || [1, 1, 1]), this.rotation = e.quat(t.rotation), t.rotate && e.quat.rotate_eular(this.rotation, t.rotate[0], t.rotate[1], t.rotate[2]) } }, t.geometry.mesh) }(_FM.ge, _FM.math), function (t, e) { t.effects = {}; var r = t.webgl.shader.create_chunks_lib("/*chunk-pp-default*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nconst vec2 madd=vec2(0.5,0.5);\nvarying vec2 v_uv_rw;\nvoid vertex()\n{\n    gl_Position = vec4(a_position_rw.xy,0.0,1.0);\t\n\tv_uv_rw = a_position_rw.xy*madd+madd;  \n}\n<?=chunk('precision')?>\nuniform sampler2D u_texture_input_rw;\nvarying vec2 v_uv_rw;\nvoid fragment(void){\t\ngl_FragColor = texture2D(u_texture_input_rw, v_uv_rw) ;\t\n\n\n}\n\n\n\n/*chunk-pp-picture-adjustment*/\n\nuniform mat3 u_pa_params;\n\nvoid fragment(){\t\n\tvec4 c = texture2D(u_texture_input_rw, v_uv_rw);\n    if (c.a > 0.0) {\n\n\t\t\n    }\n        float gamma=u_pa_params[0].x;\n\t\tfloat contrast=u_pa_params[0].y;\n\t\tfloat saturation=u_pa_params[0].z;\n\t\tfloat brightness=u_pa_params[1].x;\n\t\tfloat red=u_pa_params[1].y;\n\t\tfloat green=u_pa_params[1].z;\n\t\tfloat blue=u_pa_params[2].x;\n\t\t\n        //c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1.0 / gamma));\n        rgb = mix(vec3(0.5), mix(vec3(dot(vec3(0.2125, 0.7154, 0.0721), rgb)), rgb, saturation), contrast);\n        rgb.r *= red;\n        rgb.g *= green;\n        rgb.b *= blue;\n\n        c.rgb = rgb * brightness;        \n     //   c.rgb *= c.a;\n\n\n\tfloat alpha=u_pa_params[2].y;\n    gl_FragColor = c * alpha;\n}\n\n\n/*chunk-pp-fxaa*/\n\nuniform vec3 u_inverse_filter_texture_size;\nuniform vec3 u_fxaa_params;\n\nvoid fragment(void){\t\n\tfloat R_fxaaSpanMax=u_fxaa_params.x;\n\tfloat R_fxaaReduceMin=u_fxaa_params.y;\n\tfloat R_fxaaReduceMul=u_fxaa_params.z;\t\n\tvec2 texCoordOffset = u_inverse_filter_texture_size.xy;\n\tvec3 luma = vec3(0.299, 0.587, 0.114);\t\n\tfloat lumaTL = dot(luma, texture2D(u_texture_input_rw, v_uv_rw.xy + (vec2(-1.0, -1.0) * texCoordOffset)).xyz);\n\tfloat lumaTR = dot(luma, texture2D(u_texture_input_rw, v_uv_rw.xy + (vec2(1.0, -1.0) * texCoordOffset)).xyz);\n\tfloat lumaBL = dot(luma, texture2D(u_texture_input_rw, v_uv_rw.xy + (vec2(-1.0, 1.0) * texCoordOffset)).xyz);\n\tfloat lumaBR = dot(luma, texture2D(u_texture_input_rw, v_uv_rw.xy + (vec2(1.0, 1.0) * texCoordOffset)).xyz);\n\tfloat lumaM  = dot(luma, texture2D(u_texture_input_rw, v_uv_rw.xy).xyz);\n\n\tvec2 dir;\n\tdir.x = -((lumaTL + lumaTR) - (lumaBL + lumaBR));\n\tdir.y = ((lumaTL + lumaBL) - (lumaTR + lumaBR));\n\t\n\tfloat dirReduce = max((lumaTL + lumaTR + lumaBL + lumaBR) * (R_fxaaReduceMul * 0.25), R_fxaaReduceMin);\n\tfloat inverseDirAdjustment = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n\t\n\tdir = min(vec2(R_fxaaSpanMax, R_fxaaSpanMax), \n\t\tmax(vec2(-R_fxaaSpanMax, -R_fxaaSpanMax), dir * inverseDirAdjustment)) * texCoordOffset;\n\n\tvec3 result1 = (1.0/2.0) * (\n\t\ttexture2D(u_texture_input_rw, v_uv_rw.xy + (dir * vec2(1.0/3.0 - 0.5))).xyz +\n\t\ttexture2D(u_texture_input_rw, v_uv_rw.xy + (dir * vec2(2.0/3.0 - 0.5))).xyz);\n\n\tvec3 result2 = result1 * (1.0/2.0) + (1.0/4.0) * (\n\t\ttexture2D(u_texture_input_rw, v_uv_rw.xy + (dir * vec2(0.0/3.0 - 0.5))).xyz +\n\t\ttexture2D(u_texture_input_rw, v_uv_rw.xy + (dir * vec2(3.0/3.0 - 0.5))).xyz);\n\n\tfloat lumaMin = min(lumaM, min(min(lumaTL, lumaTR), min(lumaBL, lumaBR)));\n\tfloat lumaMax = max(lumaM, max(max(lumaTL, lumaTR), max(lumaBL, lumaBR)));\n\tfloat lumaResult2 = dot(luma, result2);\n\t\n\nif(lumaResult2 < lumaMin || lumaResult2 > lumaMax)\n\t\tgl_FragColor = vec4(result1, 1.0);\n\telse\n\t\tgl_FragColor = vec4(result2, 1.0);\n\nif(v_uv_rw.x<0.5){\n    gl_FragColor=texture2D(u_texture_input_rw, v_uv_rw);\n}\nelse {\n\t\ngl_FragColor.rgb*=0.75;\n}\n\n}\n\n\n\n/*chunk-pp-glow*/\nuniform sampler2D u_glow_emission_rw;\nuniform vec3 u_glow_params_rw;\n\nvoid fragment(void){\t\n\nvec4 cBase = texture2D(u_texture_input_rw, v_uv_rw);\n\tvec4 cOver = texture2D(u_glow_emission_rw, v_uv_rw);\t\t\t\n\tvec4 blend = cBase + cOver * u_glow_params_rw.z;\n    blend = vec4(1.0) - exp(-blend * u_glow_params_rw.x);\n    blend = pow(blend, vec4(1.0 / u_glow_params_rw.y));\n\tgl_FragColor =blend;\n\n}\n\n/*chunk-pp-blur*/\n\nuniform vec2 u_offset_rw;\nuniform vec3 u_blurKernel_rw;\nvoid fragment(){\t\n\tvec3 A = u_blurKernel_rw.x* texture2D(u_texture_input_rw, v_uv_rw - u_offset_rw).xyz;\n\tvec3 B = u_blurKernel_rw.y* texture2D(u_texture_input_rw, v_uv_rw).xyz;\n\tvec3 C = u_blurKernel_rw.z* texture2D(u_texture_input_rw, v_uv_rw + u_offset_rw).xyz;\n\tvec3 color = A + B + C;\n\tgl_FragColor = vec4(color, 1);\t\n\t\n}\n\n\n\n/*chunk-pp-emission*/\nuniform vec4 u_bright_threshold_rw;\nvoid fragment(){\t\n\t vec4 color = texture2D(u_texture_input_rw, v_uv_rw);        \t\t\n\t float luminance = dot(color.rgb, u_bright_threshold_rw.xyz );\n\t luminance+=(color.a+u_bright_threshold_rw.w);\t\t \n\t gl_FragColor = luminance* color;\n}\n\n\n\n\n\n\n\n\n/*chunk-pp-bloom*/\nuniform sampler2D u_glow_emission_rw;\nuniform vec3 u_glow_params_rw;\n\nvoid fragment(void){\t\n\nvec4 cBase = texture2D(u_texture_input_rw, v_uv_rw);\n\tvec4 cOver = texture2D(u_glow_emission_rw, v_uv_rw);\t\t\t\n\tvec4 blend = cBase + cOver * u_glow_params_rw.z;\n    blend = vec4(1.0) - exp(-blend * u_glow_params_rw.x);\n    blend = pow(blend, vec4(1.0 / u_glow_params_rw.y));\n\tgl_FragColor =blend;\n\n}\n\n/*chunk-pp-bloom-blur*/\n\nuniform vec2 u_offset_rw;\nuniform vec3 u_blurKernel_rw;\nvoid fragment(){\t\n\tvec3 A = u_blurKernel_rw.x* texture2D(u_texture_input_rw, v_uv_rw - u_offset_rw).xyz;\n\tvec3 B = u_blurKernel_rw.y* texture2D(u_texture_input_rw, v_uv_rw).xyz;\n\tvec3 C = u_blurKernel_rw.z* texture2D(u_texture_input_rw, v_uv_rw + u_offset_rw).xyz;\n\tvec3 color = A + B + C;\n\tgl_FragColor = vec4(color, 1);\t\n\t\n}\n\n\n\n/*chunk-pp-bloom-emission*/\nuniform vec4 u_bright_threshold_rw;\nvoid fragment(){\t\n\t vec4 color = texture2D(u_texture_input_rw, v_uv_rw);        \t\t\n\t float luminance = dot(color.rgb, u_bright_threshold_rw.xyz );\n\t luminance+=(color.a+u_bright_threshold_rw.w);\t\t \n\t gl_FragColor =  color*luminance;\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*chunk-glow-material*/\nvoid vertex(void){\nsuper_vertex();\n}\n\nvoid fragment(void) {\nsuper_fragment();\n\ngl_FragColor.rgb*=1.1;\n}\n\n\n\n\n\n/*chunk-skybox*/\n<?=chunk('precision')?>\nattribute vec4 a_position_rw;\nvarying vec4 v_position_rw;\n\nvoid vertex(){\n  v_position_rw = a_position_rw;\n  gl_Position = a_position_rw;\n  gl_Position.z = 1.0;\n}\n\n\n<?=chunk('precision')?>\nuniform mat4 u_view_projection_matrix_rw;\nuniform vec4 u_sun_params_rw;\nvarying vec4 v_position_rw;\nvec3 fragPosition;\n\nconst float turbidity = 10.0;\nconst float reileigh = 2.0;\nconst float mieCoefficient = 0.005;\nconst float mieDirectionalG = 0.8;\n\nconst float e = 2.71828182845904523536028747135266249775724709369995957;\nconst float pi = 3.141592653589793238462643383279502884197169;\n\nconst float n = 1.0003;// refractive index of air\nconst float N = 2.545E25; // number of molecules per unit volume for air at\n\t\t\t\t\t\t\t\t\t\t\t\nconst float pn = 0.035;\n// wavelength of used primaries, according to preetham\nconst vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\n\nconst vec3 K = vec3(0.686, 0.678, 0.666);\nconst float v = 4.0;\n\nconst float rayleighZenithLength = 8.4E3;\nconst float mieZenithLength = 1.25E3;\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\nconst float EE = 1000.0;\n\nfloat sunAngularDiameterCos =u_sun_params_rw.w; // 0.999956;\n\nconst float cutoffAngle = pi/1.95;\nconst float steepness = 1.5;\n\nvec3 simplifiedRayleigh() {\n\treturn 0.0005 / vec3(94, 40, 18);\n}\n\nfloat rayleighPhase(float cosTheta) {\n\treturn (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));\n}\n\nvec3 totalMie(vec3 lambda, vec3 K, float T) {\n\tfloat c = (0.2 * T ) * 10E-18;\n\treturn 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;\n}\n\nfloat hgPhase(float cosTheta, float g) {\n\treturn (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\n}\n\nfloat sunIntensity(float zenithAngleCos) {\t\n\treturn EE * max(0.0, 1.0 - pow(e, -((cutoffAngle - acos(zenithAngleCos))/steepness)));\n}\n\nfloat A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\nfloat W = 1000.0;\n\nvec3 Uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\n<?=chunk('global-render-system-fog-effect')?>\n\nvoid fragment(void) {\n\t\n   fragPosition=(u_view_projection_matrix_rw * v_position_rw).xyz;\n\tvec3 sunPosition=u_sun_params_rw.xyz;\n\tfloat sunfade = 1.0 - clamp(1.0 - exp(sunPosition.y), 0.0, 1.0);\n\tfloat reileighCoefficient = reileigh - (1.0 * (1.0-sunfade));\n\tvec3 sunDirection = normalize(sunPosition);\n\tfloat sunE = sunIntensity(dot(sunDirection, up));\n\tvec3 betaR = simplifiedRayleigh() * reileighCoefficient;\n\n\t// mie coefficients\n\tvec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\n\n\t// optical length\n\t// cutoff angle at 90 to avoid singularity in next formula.\n\tfloat zenithAngle = acos(max(0.0, dot(up, normalize(fragPosition))));\n\tfloat sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\n\tfloat sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\n\n\t// combined extinction factor\n\tvec3 Fex = exp(-(betaR * sR + betaM * sM));\n\n\t// in scattering\n\tfloat cosTheta = dot(normalize(fragPosition), sunDirection);\n\n\tfloat rPhase = rayleighPhase(cosTheta * 0.5+0.5);\n\tvec3 betaRTheta = betaR * rPhase;\n\n\tfloat mPhase = hgPhase(cosTheta, mieDirectionalG);\n\tvec3 betaMTheta = betaM * mPhase;\n\n\tvec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));\n\tLin *= mix(vec3(1.0),pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, sunDirection),5.0),0.0,1.0));\n\n\t//nightsky\n\tvec3 direction = normalize(fragPosition);\n\tfloat theta = acos(direction.y); // elevation --\x3e y-axis, [-pi/2, pi/2]\n\tfloat phi = atan(direction.z, direction.x); // azimuth --\x3e x-axis [-pi/2, pi/2]\n\tvec2 uv = vec2(phi, theta) / vec2(2.0*pi, pi) + vec2(0.5, 0.0);\n\tvec3 L0 = vec3(0.1) * Fex;\n\n\t// composition + solar disc\n\tfloat sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);\n\tL0 += (sunE * 19000.0 * Fex)*sundisk;\n\n\tvec3 whiteScale = 1.0/Uncharted2Tonemap(vec3(W));\n\n\tvec3 texColor = (Lin+L0);\n\ttexColor *= 0.04 ;\n\ttexColor += vec3(0.0,0.001,0.0025)*0.3;\n\n\tvec3 curr = Uncharted2Tonemap(texColor);\n\tvec3 color = curr*whiteScale;\n\n\tvec3 retColor = pow(color,vec3(1.0/(1.2+(1.2*sunfade))));\n\n\tgl_FragColor = vec4(retColor, 1.0);\n\tgl_FragColor=mix_fog_color(gl_FragColor);\n\t\n}\n\n\n\n\n\n/*chunk-skybox2*/\n<?=chunk('precision')?>\nattribute vec4 a_position_rw;\nvarying vec4 v_position_rw;\n\nvoid vertex(){\n  v_position_rw = a_position_rw;\n  gl_Position = a_position_rw;\n  gl_Position.z = 1.0;\n}\n\n\n<?=chunk('precision')?>\nuniform mat4 u_view_projection_matrix_rw;\nuniform vec4 u_sun_params_rw;\nvarying vec4 v_position_rw;\n\n\nconst float depolarizationFactor=0.067;\nconst float luminance=1.0;\nconst float mieCoefficient=0.00335;\nconst float mieDirectionalG=0.787;\nconst vec3 mieKCoefficient=vec3(0.686,0.678,0.666);\nconst float mieV=4.012;\nconst float mieZenithLength=500.0;\nconst float numMolecules=2.542e+25;\nconst vec3 primaries=vec3(6.8e-7,5.5e-7,4.5e-7);\nconst float rayleigh=1.0;\nconst float rayleighZenithLength=615.0;\nconst float refractiveIndex=1.000317;\nconst float sunAngularDiameterDegrees=0.00758;\nconst float sunIntensityFactor=1111.0;\nconst float sunIntensityFalloffSteepness=0.98;\nconst float tonemapWeighting=9.50;\nconst float turbidity=1.25;\n\nconst float PI = 3.141592653589793238462643383279502884197169;\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\n\nvec3 totalRayleigh(vec3 lambda)\n{\n\treturn (8.0 * pow(PI, 3.0) * pow(pow(refractiveIndex, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * depolarizationFactor)) / (3.0 * numMolecules * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * depolarizationFactor));\n}\n\nvec3 totalMie(vec3 lambda, vec3 K, float T)\n{\n\tfloat c = 0.2 * T * 10e-18;\n\treturn 0.434 * c * PI * pow((2.0 * PI) / lambda, vec3(mieV - 2.0)) * K;\n}\n\nfloat rayleighPhase(float cosTheta)\n{\n\treturn (3.0 / (16.0 * PI)) * (1.0 + pow(cosTheta, 2.0));\n}\n\nfloat henyeyGreensteinPhase(float cosTheta, float g)\n{\n\treturn (1.0 / (4.0 * PI)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0 * g * cosTheta + pow(g, 2.0), 1.5));\n}\n\nfloat sunIntensity(float zenithAngleCos)\n{\n\tfloat cutoffAngle = PI / 1.95; // Earth shadow hack\n\treturn sunIntensityFactor * max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos)) / sunIntensityFalloffSteepness)));\n}\n\n// Whitescale tonemapping calculation, see http://filmicgames.com/archives/75\n// Also see http://blenderartists.org/forum/showthread.php?321110-Shaders-and-Skybox-madness\nconst float A = 0.15; // Shoulder strength\nconst float B = 0.50; // Linear strength\nconst float C = 0.10; // Linear angle\nconst float D = 0.20; // Toe strength\nconst float E = 0.02; // Toe numerator\nconst float F = 0.30; // Toe denominator\nvec3 Uncharted2Tonemap(vec3 W)\n{\n\treturn ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n}\n\n\n\nvoid fragment(void) {\n\t\n  vec3 fragPosition=normalize((u_view_projection_matrix_rw * v_position_rw).xyz);\n  // In-scattering\t\n\tvec3 sunDirection=u_sun_params_rw.xyz;\n\n\n  //float sunfade = 1.0 - clamp(1.0 - exp(((sunDirection*4500000.0).y / 450000.0)), 0.0, 1.0);\n\n  float sunfade = 1.0 - clamp(1.0 - exp(sunDirection.y), 0.0, 1.0);\n\tfloat rayleighCoefficient = rayleigh - (1.0 * (1.0 - sunfade));\n\tvec3 betaR = totalRayleigh(primaries) * rayleighCoefficient;\n\t\n\t// Mie coefficient\n\tvec3 betaM = totalMie(primaries, mieKCoefficient, turbidity) * mieCoefficient;\n\t\n\t// Optical length, cutoff angle at 90 to avoid singularity\n\tfloat zenithAngle = acos(max(0.0, dot(UP, fragPosition)));\n\tfloat denom = cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253);\n\tfloat sR = rayleighZenithLength / denom;\n\tfloat sM = mieZenithLength / denom;\n\t\n\t// Combined extinction factor\n\tvec3 Fex = exp(-(betaR * sR + betaM * sM));\n\t\n\t\n\tfloat cosTheta = dot(fragPosition, sunDirection);\n\tvec3 betaRTheta = betaR * rayleighPhase(cosTheta * 0.5 + 0.5);\n\tvec3 betaMTheta = betaM * henyeyGreensteinPhase(cosTheta, mieDirectionalG);\n\tfloat sunE = sunIntensity(dot(sunDirection, UP));\n\tvec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex), vec3(1.5));\n\tLin *= mix(vec3(1.0), pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex, vec3(0.5)), clamp(pow(1.0 - dot(UP, sunDirection), 5.0), 0.0, 1.0));\n\t\n\t// Composition + solar disc\n\tfloat sunAngularDiameterCos = cos(sunAngularDiameterDegrees);\n\tfloat sundisk = smoothstep(sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta);\n\tvec3 L0 = vec3(0.1) * Fex;\n\tL0 += sunE * 19000.0 * Fex * sundisk;\n\tvec3 texColor = Lin + L0;\n\ttexColor *= 0.04;\n\ttexColor += vec3(0.0, 0.001, 0.0025) * 0.3;\n\t\n\t// Tonemapping\n\tvec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(tonemapWeighting));\n\tvec3 curr = Uncharted2Tonemap((log2(2.0 / pow(luminance, 4.0))) * texColor);\n\tvec3 color = curr * whiteScale;\n\tvec3 retColor = pow(color, vec3(1.0 / (1.2 + (1.2 * sunfade))));\n\n\tgl_FragColor = vec4(retColor, 1.0);\n}\n}"); t.effects.post_process = t.define(function (e) { function i(e) { this.guid = fin.guidi(), this.shader = e || t.effects.post_process.shader, this.on_apply || (this.on_apply = null), this.enabled = !0, this.post_shading = !1 } i.shader = t.webgl.shader.parse(r["pp-default"]), e.resize = function (t, e) { }, e.bind_output = function (t, e) { null === e ? (t.gl.bindFramebuffer(36160, null), t.gl.viewport(0, 0, t.render_width, t.render_height)) : e.bind() }; var n = [null, null, null]; return e.apply = function (t, e, i) { t.use_shader(this.shader), this.bind_output(t, i), null !== this.on_apply && (n[0] = t, n[1] = e, n[2] = i, e = this.on_apply.apply(this, n)), t.use_direct_texture(e, 0), t.draw_full_quad() }, e.on_apply = function (t, e, i) { return e }, i }), t.effects.post_process.fxaa = t.define(function (i, n) { function s(e) { e = e || {}, n.apply(this), this.shader = t.effects.post_process.fxaa.shader, this.span_max = 16, this.reduce_min = 1 / 256, this.reduce_mul = 1 / 8, this.enabled = !0, void 0 !== e.enabled && (this.enabled = e.enabled), fin.merge_object(e, this) } s.shader = t.effects.post_process.shader.extend(r["pp-fxaa"]); var a = e.vec3(), o = e.vec3(); return i.on_apply = function (t, e, i) { return a[0] = 1 / e.width, a[1] = 1 / e.height, this.shader.set_uniform("u_inverse_filter_texture_size", a), o[0] = this.span_max, o[1] = this.reduce_min, o[2] = this.reduce_mul, this.shader.set_uniform("u_fxaa_params", o), e }, s }, t.effects.post_process), t.effects.post_process.picture_adjustment = t.define(function (i, n) { function s(e) { e = e || {}, n.apply(this), this.shader = t.effects.post_process.picture_adjustment.shader, this.gamma = 1, this.contrast = 1, this.saturation = 1, this.brightness = 1, this.red = 1, this.green = 1, this.blue = 1, this.alpha = 1, fin.merge_object(e, this) } s.shader = t.effects.post_process.shader.extend(r["pp-picture-adjustment"]); var a = e.mat3(); return i.on_apply = function (t, e, i) { return a[0] = this.gamma, a[1] = this.contrast, a[2] = this.saturation, a[3] = this.brightness, a[4] = this.red, a[5] = this.green, a[6] = this.blue, a[7] = this.alpha, this.shader.set_uniform("u_pa_params", a), e }, s }, t.effects.post_process), t.effects.post_process.blank = t.define(function (t, e) { return t.on_apply = function (t, e, i) { return e }, function (t) { t = t || {}, e.apply(this), Object.assign(this, t), t.on_init && t.on_init.apply(this) } }, t.effects.post_process), t.effects.post_process.bloom = t.define(function (n, s) { function a(t) { t = t || {}, s.apply(this), fin.merge_object(t, this), this.resolution = t.resolution || .5, this.resolution_last = this.resolution, this.blur_quality = t.blur_quality || 9, this.u_bright_threshold_rw = e.vec4(t.bright_threshold || [.2627, .678, .0593, -.95]), this.blend_exposure = t.blend_exposure || 3, this.blend_gamma = t.blend_gamma || .5, this.blend_factor = t.blend_factor || 3, this.u_offset_rw = e.vec2(), this.blur_kernel = e.vec3(5 / 16, .375, 5 / 16) } var o = e.vec3(); return n.apply = function (e, r, n) { this.targets || (this.targets = [new t.webgl.render_target(e, e.render_width * this.resolution, e.render_height * this.resolution), new t.webgl.render_target(e, e.render_width * this.resolution, e.render_height * this.resolution)], this.targets[0].attach_color().color_texture.enable_linear_interpolation(), this.targets[1].attach_color().color_texture.enable_linear_interpolation()), this.targets[0].bind(), e.use_shader(t.effects.post_process.bloom.emission), e.use_direct_texture(r, 0), e.active_shader.set_uniform("u_bright_threshold_rw", this.u_bright_threshold_rw), e.draw_full_quad(), e.use_shader(t.effects.post_process.bloom.blur_shader), e.active_shader.set_uniform("u_blurKernel_rw", this.blur_kernel); for (var s = 0; i < this.blur_quality; i++)s = i % 2, this.targets[s].bind(), e.use_direct_texture(this.targets[0 === s ? 1 : 0].color_texture, 0), 0 === s ? (this.u_offset_rw[0] = 1 / (r.width / i), this.u_offset_rw[1] = 0) : (this.u_offset_rw[1] = 1 / (r.height / i), this.u_offset_rw[0] = 0), e.active_shader.set_uniform("u_offset_rw", this.u_offset_rw), e.draw_full_quad(); this.bind_output(e, n), e.use_direct_texture(r, 0), e.use_shader(t.effects.post_process.bloom.shader), e.active_shader.set_uniform("u_glow_emission_rw", 5), o[0] = this.blend_exposure, o[1] = this.blend_gamma, o[2] = this.blend_factor, e.active_shader.set_uniform("u_glow_params_rw", o), e.use_direct_texture(this.targets[s].color_texture, 5), e.draw_full_quad() }, a.shader = t.effects.post_process.shader.extend(r["pp-bloom"]), a.blur_shader = t.effects.post_process.shader.extend(r["pp-bloom-blur"]), a.emission = t.effects.post_process.shader.extend(r["pp-bloom-emission"]), a }, t.effects.post_process) }(_FM.ge, _FM.math), function (t, e, i, r) { var n = i.webgl.shader.create_chunks_lib("/*chunk-points*/\n<?=chunk('precision')?>\nattribute vec3 a_point_position_rw;\nattribute vec4 a_point_color_rw;\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\n\nvarying vec3 point_color_v;\n\nvoid vertex(){\t    \n    gl_Position = u_view_projection_rw*u_model_rw* vec4(a_point_position_rw,1.0);\t\n    point_color_v=a_point_color_rw.xyz;  \n    gl_PointSize =a_point_color_rw.w;\n}\n<?=chunk('precision')?>\n\nvarying vec3 point_color_v;\nvoid fragment(void) {\t        \ngl_FragColor.xyz=point_color_v;\ngl_FragColor.w=1.0;\n}\n\n\n\n/*chunk-lines*/\n\n<?=chunk('precision')?>\nattribute vec3 a_line_position_rw;\nattribute vec3 a_line_color_rw;\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\n\nvarying vec3 line_color_v;\n\nvoid vertex(){\t    \n    gl_Position = u_view_projection_rw*u_model_rw* vec4(a_line_position_rw,1.0);\t\n    line_color_v=a_line_color_rw.xyz;  \n}\n<?=chunk('precision')?>\n\nvarying vec3 line_color_v;\nvoid fragment(void) {\t        \ngl_FragColor.xyz=line_color_v;\ngl_FragColor.w=1.0;\n}\n\n\n\n/*chunk-triangles*/\n\n<?=chunk('precision')?>\nattribute vec3 a_triangle_position_rw;\nattribute vec3 a_triangle_color_rw;\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\n\nvarying vec3 triangle_color_v;\n\nvoid vertex(){\t    \n    gl_Position = u_view_projection_rw*u_model_rw* vec4(a_triangle_position_rw,1.0);\t\n    triangle_color_v=a_triangle_color_rw.xyz;  \n}\n<?=chunk('precision')?>\n\nvarying vec3 triangle_color_v;\nvoid fragment(void) {\t        \ngl_FragColor.xyz=triangle_color_v;\ngl_FragColor.w=1.0;\n}\n\n\n\n/*chunk-aabbs*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nattribute vec3 a_box_position_rw;\nattribute vec3 a_box_size_rw;\nattribute vec3 a_box_color_rw;\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\nvarying vec3 v_box_color_rw;\nvoid vertex(){\n    vec4 pos;\n    pos.xyz=a_position_rw*a_box_size_rw;    \n    pos.xyz+=a_box_position_rw;\n    pos.w=1.0;    \n    v_box_color_rw=a_box_color_rw;\n    gl_Position = u_view_projection_rw*u_model_rw*pos;\t\n\n}\n<?=chunk('precision')?>\nvarying vec3 v_box_color_rw;\nvoid fragment(void) {\t\ngl_FragColor=vec4(v_box_color_rw,0.5);\n}\n\n\n\n\n\n\n\n/*chunk-aabbs-solid*/\n\n<?=chunk('precision')?>\nattribute vec4 a_position_rw;\nattribute vec3 a_box_position_rw;\nattribute vec3 a_box_size_rw;\nattribute vec3 a_box_color_rw;\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\nvarying vec3 v_box_color_rw;\n\n\nvoid vertex(){\n    vec4 p;\n    p.xyz=a_position_rw.xyz*a_box_size_rw;    \n    p.xyz+=a_box_position_rw;\n    p.w=1.0;        \n    v_box_color_rw=a_box_color_rw;\n    gl_Position = u_view_projection_rw*u_model_rw*p;\t\n}\n<?=chunk('precision')?>\nvarying vec3 v_box_color_rw;\nvoid fragment(void) {\t\ngl_FragColor=vec4(v_box_color_rw,1.0);\n}\n"); i.debug = {}, i.debug.points = i.define(function (t, e) { var r, s, a, o, _, l = new i.shading.material; return l.shader = i.webgl.shader.parse(n.points), l.render_mesh = function (t, e, i) { i.points_count < 1 || t.gl.drawArrays(0, 0, i.points_count) }, t.clear = function () { this.points_position.i = 0, this.points_count = 0 }, t.add = (r = 0, s = 1, a = 1, o = 1, _ = 10, t.add_vec3 = function (t, e, i, r, n) { s = e, a = i, o = r, _ = n, this.add(t[0], t[1], t[2], s, a, o, _) }, function (t, e, i, n, l, u, h) { s = n, a = l, o = u, _ = h, r = this.points_position.i, this.points_position.data[r] = t, this.points_position.data[r + 1] = e, this.points_position.data[r + 2] = i, this.points_position.data[r + 3] = n, this.points_position.data[r + 4] = l, this.points_position.data[r + 5] = u, this.points_position.data[r + 6] = h, this.points_position.i += 7, this.points_position.data_length = this.points_position.i, this.points_position.needs_update = !0, this.points_count = this.points_position.i / 7, this.draw_count = this.points_count }), t.update_bounds = function (t) { }, function (t) { t = t || {}, e.apply(this, [t]), t.max_points = t.max_points || 1e3, this.geometry = new i.geometry.geometry_data, this.points_position = this.geometry.add_attribute("a_point_position_rw", { item_size: 3, data: new Float32Array(3 * t.max_points), stride: 28 }), this.points_color = this.geometry.add_attribute("a_point_color_rw", { item_size: 4, stride: 28, offset: 12 }), this.points_position.i = 0, this.points_count = 0, this.material = new i.shading.material, this.material.shader = l.shader, this.material.render_mesh = l.render_mesh, this.draw_offset = 0, this.draw_count = this.geometry.num_items, this.flags += 2 } }, i.geometry.mesh), i.debug.lines = i.define(function (t, e) { var r, s = new i.shading.material; return s.shader = i.webgl.shader.parse(n.lines), s.render_mesh = function (t, e, i) { i.line_count < 1 || t.gl.drawArrays(1, 0, i.line_count) }, t.clear = function () { this.line_position.i = 0, this.line_count = 0 }, t._add = (r = 0, t.set_color = function (t, e, i) { return this.color[0] = t, this.color[1] = e, this.color[2] = i, this }, t.add_vec3 = function (t, e) { return this._add(t[0], t[1], t[2], this.color[0], this.color[1], this.color[2], e[0], e[1], e[2], this.color[0], this.color[1], this.color[2]), this }, t.add2 = function (t, e, i, r, n, s) { this._add(t, e, i, this.color[0], this.color[1], this.color[2], r, n, s, this.color[0], this.color[1], this.color[2]) }, t.addtri = function (t, e, i, r, n, s, a, o, _) { this.add2(t, e, i, r, n, s), this.add2(r, n, s, a, o, _), this.add2(a, o, _, t, e, i) }, function (t, e, i, n, s, a, o, _, l, u, h, c) { r = this.line_position.i, this.line_position.data[r] = t, this.line_position.data[r + 1] = e, this.line_position.data[r + 2] = i, this.line_position.data[r + 3] = n, this.line_position.data[r + 4] = s, this.line_position.data[r + 5] = a, this.line_position.data[r + 6] = o, this.line_position.data[r + 7] = _, this.line_position.data[r + 8] = l, this.line_position.data[r + 9] = u, this.line_position.data[r + 10] = h, this.line_position.data[r + 11] = c, this.line_position.i += 12, this.line_position.data_length = this.line_position.i, this.line_position.needs_update = !0, this.line_count = this.line_position.i / 6, this.draw_count = this.line_count }), t.update_bounds = function (t) { }, function (t) { t = t || {}, e.apply(this, [t]), t.max_lines = t.max_lines || 8e3, this.geometry = new i.geometry.geometry_data, this.line_position = this.geometry.add_attribute("a_line_position_rw", { item_size: 3, data: new Float32Array(3 * t.max_lines * 2), stride: 24 }), this.line_color = this.geometry.add_attribute("a_line_color_rw", { item_size: 3, stride: 24, offset: 12 }), this.line_position.i = 0, this.line_count = 0, this.material = s, this.draw_offset = 0, this.draw_count = this.geometry.num_items, this.color = [1, 1, 1], this.flags = 2 } }, i.geometry.mesh), i.debug.triangles = i.define(function (t, e) { var r, s = new i.shading.material({ transparent: .5 }); return s.shader = i.webgl.shader.parse(n.triangles), s.render_mesh = function (t, e, i) { i.triangle_count < 1 || (t.gl_disable(2884), t.gl.drawArrays(4, 0, 3 * i.triangle_count), t.gl_enable(2884)) }, t.clear = function () { this.triangle_position.i = 0, this.triangle_count = 0 }, t._add = (r = 0, t.set_color = function (t, e, i) { return this.color[0] = t, this.color[1] = e, this.color[2] = i, this }, t.add_vec3 = function (t, e, i) { return this._add(t[0], t[1], t[2], this.color[0], this.color[1], this.color[2], e[0], e[1], e[2], this.color[0], this.color[1], this.color[2], i[0], i[1], i[2], this.color[0], this.color[1], this.color[2]), this }, t.add2 = function (t, e, i, r, n, s, a, o, _) { this._add(t, e, i, this.color[0], this.color[1], this.color[2], r, n, s, this.color[0], this.color[1], this.color[2], a, o, _, this.color[0], this.color[1], this.color[2]) }, function (t, e, i, n, s, a, o, _, l, u, h, c, d, m, p, f, g, v) { r = this.triangle_position.i, this.triangle_position.data[r] = t, this.triangle_position.data[r + 1] = e, this.triangle_position.data[r + 2] = i, this.triangle_position.data[r + 3] = n, this.triangle_position.data[r + 4] = s, this.triangle_position.data[r + 5] = a, this.triangle_position.data[r + 6] = o, this.triangle_position.data[r + 7] = _, this.triangle_position.data[r + 8] = l, this.triangle_position.data[r + 9] = u, this.triangle_position.data[r + 10] = h, this.triangle_position.data[r + 11] = c, this.triangle_position.data[r + 12] = d, this.triangle_position.data[r + 13] = m, this.triangle_position.data[r + 14] = p, this.triangle_position.data[r + 15] = f, this.triangle_position.data[r + 16] = g, this.triangle_position.data[r + 17] = v, this.triangle_position.i += 18, this.triangle_position.data_length = this.triangle_position.i, this.triangle_position.needs_update = !0, this.triangle_count = this.triangle_position.i / 9, this.triangle_count = this.triangle_count }), t.update_bounds = function (t) { }, function (t) { t = t || {}, e.apply(this, [t]), t.max_triangles = t.max_triangles || 3e3, this.geometry = new i.geometry.geometry_data, this.triangle_position = this.geometry.add_attribute("a_triangle_position_rw", { item_size: 3, data: new Float32Array(3 * t.max_triangles * 3), stride: 24 }), this.triangle_color = this.geometry.add_attribute("a_triangle_color_rw", { item_size: 3, stride: 24, offset: 12 }), this.triangle_position.i = 0, this.triangle_count = 0, this.material = new i.shading.material, this.material.shader = s.shader, this.material.render_mesh = s.render_mesh, this.draw_offset = 0, this.draw_count = this.geometry.num_items, this.color = [1, 1, 1], this.flags = 2 } }, i.geometry.mesh), i.debug.aabbs = i.define(function (t, e) { var r, s, a, o, _, l, u = new i.shading.material({ transparent: .5 }); function h(t) { t = t || {}, e.apply(this, [t]), t.max_boxes = t.max_boxes || 1e4; var i = h.get_lines_geometry(); return this.boxes_position = i.add_attribute("a_box_position_rw", { item_size: 3, data: new Float32Array(3 * t.max_boxes), divisor: 1 }), this.boxes_size = i.add_attribute("a_box_size_rw", { item_size: 3, data: new Float32Array(3 * t.max_boxes), divisor: 1 }), this.boxes_color = i.add_attribute("a_box_color_rw", { item_size: 3, data: new Float32Array(3 * t.max_boxes), divisor: 1 }), this.geometry = i, this.material = u, this.max_boxes = 0, this.di = 0, this.box_color = [.5, .5, .5], this.flags = 2, this } return u.shader = i.webgl.shader.parse(n.aabbs), u.render_mesh = function (t, e, i) { i.boxes_count < 1 || (t.gl_enable(2929), t.gl.ANGLE_instanced_arrays.drawArraysInstancedANGLE(1, 0, i.geometry.num_items, i.boxes_count)) }, t.update_bounds = function (t) { }, t.clear = function () { this.di = 0, this.boxes_count = 0 }, t.add_aabb = (t.add_aabb2 = function (t, e, i, n, u, h) { r = t + .5 * (o = n - t), s = e + .5 * (_ = u - e), a = i + .5 * (l = h - i), this.add(r, s, a, o, _, l) }, function (t) { o = t[3] - t[0], _ = t[4] - t[1], l = t[5] - t[2], r = t[0] + .5 * o, s = t[1] + .5 * _, a = t[2] + .5 * l, this.add(r, s, a, o, _, l) }), t.add = function (t, e, i, r, n, s) { var a = this.di; this.boxes_position.data[a] = t, this.boxes_position.data[a + 1] = e, this.boxes_position.data[a + 2] = i, this.boxes_size.data[a] = r, this.boxes_size.data[a + 1] = n, this.boxes_size.data[a + 2] = s, this.boxes_color.data[a] = 1, this.boxes_color.data[a + 1] = 0, this.boxes_color.data[a + 2] = 0, this.di += 3, this.boxes_position.data_length = this.di, this.boxes_position.needs_update = !0, this.boxes_size.data_length = this.di, this.boxes_size.needs_update = !0, this.boxes_color.data_length = this.di, this.boxes_color.needs_update = !0, this.boxes_count = this.di / 3 }, h.get_lines_geometry = function () { var t = i.geometry.geometry_data.lines_builder; return t.clear(), t.move_to(-.5, -.5, -.5).add_to(.5, -.5, -.5).add_to(.5, .5, -.5).add_to(-.5, .5, -.5).add_to(-.5, -.5, -.5), t.move_to(-.5, -.5, -.5).add_to(-.5, -.5, .5), t.move_to(.5, -.5, -.5).add_to(.5, -.5, .5), t.move_to(-.5, .5, -.5).add_to(-.5, .5, .5), t.move_to(.5, .5, -.5).add_to(.5, .5, .5), t.move_to(-.5, -.5, .5).add_to(.5, -.5, .5).add_to(.5, .5, .5).add_to(-.5, .5, .5).add_to(-.5, -.5, .5), t.build() }, h }, i.geometry.mesh), i.debug.aabbs_solid = i.define(function (t, e) { var r, s, a, o, _, l; t.update_bounds = function (t) { }, t.clear = function () { this.di = 0, this.boxes_count = 0 }, t.add_aabb = (t.add_aabb2 = function (t, e, i, n, u, h) { r = t + .5 * (o = n - t), s = e + .5 * (_ = u - e), a = i + .5 * (l = h - i), this.add(r, s, a, o, _, l) }, function (t) { o = t[3] - t[0], _ = t[4] - t[1], l = t[5] - t[2], r = t[0] + .5 * o, s = t[1] + .5 * _, a = t[2] + .5 * l, this.add(r, s, a, o, _, l) }), t.add = function (t, e, i, r, n, s) { var a = this.di; this.boxes_position.data[a] = t, this.boxes_position.data[a + 1] = e, this.boxes_position.data[a + 2] = i, this.boxes_size.data[a] = r, this.boxes_size.data[a + 1] = n, this.boxes_size.data[a + 2] = s, this.boxes_color.data[a] = this.box_color[0], this.boxes_color.data[a + 1] = this.box_color[1], this.boxes_color.data[a + 2] = this.box_color[2], this.di += 3, this.boxes_position.data_length = this.di, this.boxes_position.needs_update = !0, this.boxes_size.data_length = this.di, this.boxes_size.needs_update = !0, this.boxes_color.data_length = this.di, this.boxes_color.needs_update = !0, this.boxes_count = this.di / 3 }, t.set_color = function (t, e, i) { return this.box_color[0] = t, this.box_color[1] = e, this.box_color[2] = i, this }; var u = i.webgl.shader.parse(n["aabbs-solid"]); return function (t) { t = t || {}, e.apply(this, [t]), t.max_boxes = t.max_boxes || 1e3; var r = i.geometry.shapes.cube(); return this.boxes_position = r.add_attribute("a_box_position_rw", { item_size: 3, data: new Float32Array(3 * t.max_boxes), divisor: 1 }), this.boxes_size = r.add_attribute("a_box_size_rw", { item_size: 3, data: new Float32Array(3 * t.max_boxes), divisor: 1 }), this.boxes_color = r.add_attribute("a_box_color_rw", { item_size: 3, data: new Float32Array(3 * t.max_boxes), divisor: 1 }), this.geometry = r, this.material = new i.shading.material, this.material.shader = u, this.draw_count = this.geometry.num_items, this.di = 0, this.box_color = [.5, .5, .5], this.flags = 2, this } }, i.geometry.mesh) }(_FM.fin, _FM.ecs, _FM.ge, _FM.math), _FM.myapp = new Object, function (t, e, i) { var r = new e.app({ renderer: { pixel_ratio: 1 } }); function n(t) { return .017453292519943295 * t } r.create_renderable(new e.shading.light({ intensity: 1, ambient: [.8, .8, .8] }), function (t, e) { e.ge_transform.rotate_eular(n(-90), n(170), 0), e.ge_transform.rotate_eular(n(-70), n(-30), 0), t.enable_shadows({ shadow_intensity: .2, shadow_map_size: 2048, shadow_camera_distance: 15 }) }); var s = r.create_renderable(new e.shading.light({ intensity: .5, ambient: [.5, .5, .5], specular: [1, 1, 1] }), function (t, e) { e.ge_transform.rotate_eular(n(193), n(-15), n(0)), t.enabled = !1, e.rx = 0, e.ry = 0, e.rz = 0 }), a = r.render_system.camera; a.ge_transform_controller.set_position(10.129446029663086, 13.004027366638184, 15.977799415588379).set_rotate(-.33500027656555176, .05499744415283203, 0), r.attach_component(a, "ge_mouse_camera_controller", { element: r.render_system.renderer.canvas, wheel_delta: .01, on_mouse_down: function (t, e, i) { r.render_system.picking_mouse_x = t, r.render_system.picking_mouse_y = e }, on_mouse_up: function (t, e, i) { a.ge_camera.is_locked = !1 }, on_mouse_drage: function (t, e, i) { if (i.ctrlKey) return s.rx += t, s.ry += e, s.ge_transform.rotate_eular(n(s.rx), n(s.ry), n(s.rz)), console.log(`RD(${s.rx}),RD(${s.ry}),RD(${s.rz})`), !1 } }), window.onresize = function () { r.render_system.resize() }; var o = r.use_system("worker_particles_system", {}); console.log(o), r.root.ge_transform.set_position(0, 1, 0), t.urls_loader([["res/duct-system.obj"], ["res/duct-system.mtl"]], function (t) { var n = e.geometry.shapes.obj.parse(t[0], t[1]); n.scale_position_rotation(.003, .003, .003, 0, 0, 0, -1.5707963267948966, 0, 0), console.log(n); var s = {}, a = {}, _ = { beds: { cast_shadows: !0 }, box: { transparent: .35, specular1: [2, 2, 2], ambient: [.82, .82, .82], transparent_layer: 10, diffuse: [0, 0, 0] }, flloor: { receive_shadows: !0, ambient: [112 / 255, 123 / 255, 124 / 255], diffuse: [.5, .5, .5], specular: [0, 0, 0] }, ventwalls: { specular: [0, 0, 0], ambient: [33 / 256, 47 / 256, 60 / 256], diffuse1: [0, 0, 0] }, ventceil1: { specular: [0, 0, 0], ambient: [33 / 256, 47 / 256, 60 / 256] } }; n.obj_meta.materials.forEach(function (t) { t.ambient = t.diffuse, t.diffuse = [.5, .5, .5], _[t.name] && Object.assign(t, _[t.name]), s[t.name] = new e.shading.shaded_material(t), t.diffuseMap && (a[t.diffuseMap] || (a[t.diffuseMap] = e.webgl.texture.from_url("res/" + t.diffuseMap, !0)), s[t.name].texture = a[t.diffuseMap]) }), console.log(s); var l = []; n.obj_meta.meshes.forEach(function (t) { l.push(new e.geometry.mesh({ geometry: n, material: s[t.mat] || new e.shading.shaded_material({}), draw_offset: t.draw_offset, draw_count: t.draw_count })) }), r.create_renderables(l, function (t, e) { i.mat3.translate_rotate_scale(t.material.texture_matrix, 0, 0, 1, -1, 0) }).ge_transform.parent = r.root.ge_transform, r.create_renderable(o.create_point_particle_emitter({ texture: e.webgl.texture.create_texture_atlas({ width: 2048, height: 2048, inputs: [{ src: "res/point-particle-sheet.png", tiles_in_row: 5, dest_x: 0, dest_y: 0, dest_size: 64 }, { src: "res/smok1.png", tiles_in_row: 4, dest_x: 0, dest_y: 64, dest_size: 64 }, { src: "res/smok2.png", tiles_in_row: 4, dest_x: 0, dest_y: 128, dest_size: 64 }] }), texture_sets: [[0, 0, 1920, 64], [0, 64, 1024, 64], [0, 128, 1024, 64]], emitter: function (t) { var e; function i(t, i) { (e = i[0] * i[0] + i[1] * i[1] + i[2] * i[2]) > 0 && (e = 1 / Math.sqrt(e)), t[0] = i[0] * e, t[1] = i[1] * e, t[2] = i[2] * e } var r = [0, 0, 0], n = [0, 0, 0]; t.update_particle = function (t, e, s) { t[4] < 2 && (t[7] = 0, t[3] < 9 ? t[6] = -15 : t[6] = 15, t[8] = 0), t[3] > 18.4 ? (t[3] = 18.4, 0 === t[9] && (t[9] = 1, r[0] = 0, r[1] = t[4] - e.y - 5, r[2] = t[5] + 6.9, i(n, r), t[6] = 2 * -n[0], t[7] = 15 * -n[1], t[8] = 19 * -n[2])) : t[3] < .07 && (t[3] = .07, 0 === t[9] && (t[9] = 1, t[6] = 0, r[0] = 0, r[1] = t[4] - e.y - 5, r[2] = t[5] + 6.9, i(n, r), t[7] = 15 * -n[1], t[8] = 19 * -n[2])), t[3] += t[6] * s, t[4] += t[7] * s, t[5] += t[8] * s }, t.pack_life_texture_size = function (t, e) { t[2] = Math.max(2, t[0] / 255 * 10), t[2] = 6, t[1] = 1 }; for (var s, a = [], o = 0; o < 13; o += 1.5)for (var _ = 0; _ < 17; _ += 1.5)a.push([_, o]); var l = 0; t.trigger_emitter = function (t) { for (l = 0; l < 30; l++)par = this.queue_particle(0, t.id, 1.2), s = a[Math.floor(Math.random() * a.length)], par[3] = t.x + s[0], par[4] = t.y, par[5] = t.z + s[1], par[7] = -15, par[6] = 2 * (Math.random() - .5), par[8] = 2 * (Math.random() - .5), par[9] = 0 } } }), function (t, e) { e.ge_transform.parent = r.root.ge_transform, t.emitter.push_command([200, 1, -1, .01, .8999999999999363, 9.1, -13.05000000000011, 1]) }) }), r.start(function () { }, 1 / 60) }.apply(_FM.myapp, [_FM.fin, _FM.ge, _FM.math]), _FM }();