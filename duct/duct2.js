!function () { var fin = { macro_scope: function (t, e) { return t(), t }, macro: function (t, e, i) { return t }, modules: {} }; !function (t) { var e, i; t.$A = function () { for (var t = "", e = 0; e < arguments.length; e++)t += arguments[e]; return t }, t.guidi = (e = 0, function () { return Date.now() + e++ }), t.define = function (t, e) { e = e || Object; var i = {}; Object.assign(i, e.prototype); var r = t(i, e); return r.super_class = e, r.prototype = Object.create(e.prototype), Object.assign(r.prototype, i), r }, t.queue = t.define(function (t) { return t.size = function () { return this._newestIndex - this._oldestIndex }, t.enqueue = function (t) { return this._storage[this._newestIndex] = t, this._newestIndex++, t }, t.realign = function () { let t = this.size(), e = 0; for (e = 0; e < t; e++)this._storage[e + 1] = this._storage[this._oldestIndex + e]; for (e = this._oldestIndex; e < this._newestIndex; e++)this._storage[e] = void 0; this._oldestIndex = 1, this._newestIndex = this._oldestIndex + t }, t.dequeue = function () { if (this._oldestIndex !== this._newestIndex) { var t = this._storage[this._oldestIndex]; return this._storage[this._oldestIndex] = void 0, this._oldestIndex++, t } }, t.peek = function () { return this._storage[this._oldestIndex] }, function () { this._oldestIndex = 1, this._newestIndex = 1, this._storage = {} } }), t.merge_sort = function (t, e) { var i, r, n; function a(t, e, a, s, o, _) { for (i = a, r = s + 1, n = a; ;)if (_(t[i], t[r]) <= 0) { if (e[n++] = t[i++], i > s) { do { e[n++] = t[r++] } while (r <= o); break } } else if (e[n++] = t[r++], r > o) { do { e[n++] = t[i++] } while (i <= s); break } } function s(t, e, i, r, n) { if (!(r < i)) if (r != i) { var s = Math.floor(i + .5 * (r - i)); o(t, e, i, s, n), o(t, e, s + 1, r, n), a(t, e, i, s, r, n) } else e[i] = t[i] } function o(t, e, i, r, n) { if (!(r <= i)) { var o = Math.floor(i + .5 * (r - i)); s(t, e, i, o, n), s(t, e, o + 1, r, n), a(e, t, i, o, r, n) } } var _ = [], l = 0; return function (t, e, r) { for (l = 0, i = 0; i < e; i++)_[l++] = t[i]; return o(t, _, 0, e - 1, r), t } }(), t.url_loader = function () { var e = new t.queue, i = new XMLHttpRequest; return console.log("parking", e), function t(r, n, a, s) { i.isBusy ? e.enqueue([r, n, a, s]) : (i.onload = function () { n && n(this.response, s), this.abort(), this.isBusy = !1, e.size() > 0 && t.apply(this, e.dequeue()) }, i.responseType = a || "text", i.isBusy = !0, i.open("GET", r, !0), i.send()) } }(), t.urls_loader = function () { var e = new t.queue; return function i(r, n, a) { if (e.isBusy) e.enqueue([r, n, a]); else { var s = []; t.each_index(function (o, _) { e.isBusy = !0, t.url_loader(r[o][0], function (t) { s.push(t), o < r.length - 1 ? _(o + 1) : (n && n(s, a), e.size() > 0 && (e.isBusy = !1, i.apply(this, e.dequeue()))) }, r[o][1]) }) } } }(), t.array = t.define(function (t) { return t.push = function (t) { this.data[this.length++] = t }, t.peek = function () { return this.data[this.length - 1] }, t.pop = function () { return 0 === this.length ? null : this.data[--this.length] }, t.clear = function () { this.length = 0 }, t.for_each = function (t, e) { for (this.index = 0; this.index < this.length;)t(this.data[this.index], this.index++, e); this.index = 0 }, t.next = function () { return this.index < this.length ? this.data[this.index++] : null }, function () { this.data = [], this.length = 0, this.index = 0 } }), t.object_pooler = t.define(function (t) { return t.get = function (t) { return this.freed > 0 ? this.reuse ? this.reuse(this.free_objects[--this.freed], t) : this.free_objects[--this.freed] : this.allocated >= this.pool_size ? null : (this.allocated++, this.creator(t)) }, t.free = function (t) { this.free_objects[this.freed++] = t }, function (t, e, i) { this.creator = t, this.reuse = e, this.allocated = 0, this.freed = 0, this.pool_size = i || 1 / 0, this.free_objects = [] } }), t.object_pooler_ext = t.define(function (t, e) { return t.free = function (t) { this.free_objects[this.freed++] = t, null !== this.on_free && this.on_free(t) }, t.get = function (t) { return this.freed > 0 ? this.reuse ? this.reuse(this.free_objects[--this.freed], t) : this.free_objects[--this.freed] : this.allocated >= this.pool_size ? null : (this.allocated++, this.reuse(this.creator(), t)) }, function (t, i, r) { e.apply(this, arguments), this.on_free = null } }, t.object_pooler), t.event = t.define(function (t) { return t.add = function (t, e) { e = e || this.owner, this.handlers[this.handlers.length] = [t, e] }, t.trigger = function (t) { for (var e = 0; e < this.handlers.length; e++)if (!1 === this.handlers[e][0].apply(this.handlers[e][1], t)) return !1 }, t.trigger_params = function () { for (var t = 0; t < this.handlers.length; t++)if (!1 === this.handlers[t][0].apply(this.handlers[t][1], this.params)) return !1 }, function (t, e) { this.owner = t, this.handlers = [], this.params = e } }), t.each_index = function (t, e) { var i = function (e) { t(e, i) }; i(e || 0) }, t.rg = function (t, e) { null !== t && t.forEach(e) }, t.merge_object = i = function (t, e, r) { for (var n in t) "[object object]" === Object.prototype.toString.call(t[n]).toLocaleLowerCase() ? void 0 !== e[n] ? i(t[n], e[n], r) : r && (e[n] = {}, i(t[n], e[n], r)) : r ? void 0 === e[n] && (e[n] = t[n]) : e[n] = t[n]; return e }, t.create_float32 = function (t, e) { e = e || function (t) { return t }; var i = 0; return function () { var r = e(new Float32Array(t)); if (void 0 === arguments[0]) return r; if (1 === arguments.length && arguments[0].length > 0) for (i = 0; i < arguments[0].length; i++)i < t && (r[i] = arguments[0][i]); else for (i = 0; i < arguments.length; i++)i < t && (r[i] = arguments[i]); return r } }, t.is_function = function (t) { return !!(t && t.constructor && t.call && t.apply) }, t.traverse_object = function () { let e; return function i(r, n, a) { for (e in a = (a = a || "").length > 0 ? a + "." : a, r) "[object object]" === Object.prototype.toString.call(r[e]).toLocaleLowerCase() || t.is_function(r[e]) ? i(r[e], n, a + e) : n(a + e, r[e], r, e) } }(), t.parse_args_from_func = function (e) { var i; return t.rg(e.match(/function.*\(.*\)/), function (t) { (i = t.replace(/function.*\(/, "").replace(")", "").split(",")).forEach(function (t, e) { i[e] = t.trim() }) }), i || [] }, t.trace_brackets = function (t, e, i, r) { var n = 1; for (i = i || "{", r = r || "}"; 0 !== n && e < t.length;)t[e] === i ? n++ : t[e] === r && n--, e++; return e }, t.worker = function () { } }(fin); const _FM = fin.modules; var ge, ecs, math; _FM.fin = fin, _FM.ecs = new Object, function (t) { var e = this; e.systems = {}, e.components = {}, e.app = t.define(function (i) { i.sort_systems = function () { this._systems = t.merge_sort(this._systems, this._systems.length, function (t, e) { return t.priority - e.priority }) }, i.iterate_entities = function () { var t = null; return function (e) { return void 0 === (t = this.components[e]) ? null : (-1 === t.ei && (t.ei = 0), t.ei < t.entities.length ? this.entities[t.entities[t.ei++]] : (t.ei = -1, null)) } }(), i.use_system = function (t, i) { var r = this.systems[t]; return r || ((r = new e.systems[t](i, this)).name_id = t, this.systems[t] = r, this._systems[this._systems.length] = r, r.validate(this), this.sort_systems(), this.required_validation = !0), r }, i.validate = function () { if (!0 === this.required_validation) { for (this.required_validation = !1, s = 0; s < this._systems.length; s++)this._systems[s].validate(this); this.sort_systems() } }; var r, n, a, s = 0; return i.use_component = function (i) { return this.components[i] || (n = e.components[i], this.components[i] = { priority: n.priority, name_id: i, set_instance: null, creator: n, app: this, entities: [], ei: 0 }, void 0 !== n.super_class.name_id && (this.components[i].parent = this.use_component(n.super_class.name_id)), n.validate && n.validate(this.components[i]), this._components.push(this.components[i]), this._components = t.merge_sort(this._components, this._components.length, function (t, e) { return t.priority - e.priority }), this.required_validation = !0), this.components[i] }, i.map_component_entity = function (t, e, i) { e.entities[e.entities.length] = t.uuid, t[e.name_id] = i, e.parent && this.map_component_entity(t, e.parent, i) }, i.attach_component = function (t, e, i) { if (t[(n = this.use_component(e)).name_id]) return t[n.name_id]; var r = new n.creator(i, t, this, n); return n = this.components[e], this.map_component_entity(t, this.components[e], r), t[n.name_id] }, i.create_entity = function (e) { var i = { uuid: (e = e || {}).uuid || t.guidi() }; if (this.entities[i.uuid] = i, e.components) { for (r in e.components) this.use_component(r); for (var a = 0; a < this._components.length; a++)n = this._components[a], e.components[n.name_id] && this.attach_component(i, n.name_id, e.components[n.name_id]) } return i }, i.step = function (t) { if (this.timer = .001 * performance.now(), this.current_time_delta = this.timer - this.last_timer, !(this.current_time_delta < this.req_time_delta)) { this.current_time_delta = Math.max(this.req_time_delta, this.current_time_delta), this.current_time_delta = Math.min(2 * this.req_time_delta, this.current_time_delta), this.last_timer = this.timer - this.current_time_delta % this.req_time_delta, this.validate(); var e = 0, i = 0, r = this._systems.length; for (this._app_cb.apply(this), e = 0; e < r; e++)!0 === (a = this._systems[e]).enabled && (a.time_delta = this.timer - a.last_step_time, a.time_delta > a.step_size && a.step_start()); for (e = 0; e < r; e++)!0 === (a = this._systems[e]).enabled && a.time_delta > a.step_size && (i = Date.now(), a.step(), a.on_frame.trigger(), a.frame_time = Date.now() - i); for (e = 0; e < r; e++)!0 === (a = this._systems[e]).enabled && a.time_delta > a.step_size && (a.step_end(), a.last_step_time = this.timer - a.time_delta % a.step_size) } }, i.start = function (t, e) { var i = this; function r() { i.step(), requestAnimationFrame(n) } function n() { i.step(), requestAnimationFrame(r) } i._app_cb = t || function () { }, i.req_time_delta = e || 1 / 60, this.timer = .001 * performance.now(), this.last_timer = this.timer, i.step(), requestAnimationFrame(r) }, function (t) { if (t = t || {}, this.systems = {}, this.components = {}, this._components = [], this._systems = [], this.entities = {}, t.systems) for (var e in t.systems) this.use_system(e) } }), e.component = t.define(function (t) { return function () { } }), e.system = t.define(function (e) { return e.validate = function (t) { }, e.step_start = function () { }, e.step = function () { }, e.step_end = function () { }, function (e, i) { e = e || {}, this.uuid = e.uuid || t.guidi(), this.state = 1, this.step_size = 1 / 60, this.last_step_time = 0, this.worked_items = 0, this.enabled = !0, this.time_delta = 0, this.app = i, this.on_frame = new t.event(this) } }), e.register_component = function (t, i) { i.name_id = t, this.components[i.name_id] = i, i.priority = e.register_component.priority, e.register_component.priority += 1e3 }, e.register_component.priority = 1e3, e.register_system = function (t, e) { e.name_id = t, this.systems[e.name_id] = e }, console.log("ecs", e) }.apply(_FM.ecs, [_FM.fin]), _FM.math = new Object, function (t) { var e = this; Object.assign(this, { DEGTORAD: .017453292519943295, RADTODEG: 57.29577951308232 }), this.module_export_code = function () { this.byte_code = this.byte_code.replace("/*STR_CONSTANTS*/", "Object.assign(this," + this.str_constants + ");") }, e.vec2 = t.create_float32(2), e.vec3 = t.create_float32(3), e.vec4 = t.create_float32(4), e.utils = {}, e.utils.get_bias = function (t, e) { return t / ((1 / e - 2) * (1 - t) + 1) }, e.utils.get_gain = function (t, e) { return t < .5 ? this.get_bias(2 * t, e) / 2 : this.get_bias(2 * t - 1, 1 - e) / 2 + .5 }, e.vec3.pool = new t.object_pooler(function () { return e.vec3() }), e.mat3 = t.create_float32(9, function (t) { return t[0] = 1, t[4] = 1, t[8] = 1, t }), e.mat4 = t.create_float32(16, function (t) { return t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t }), e.quat = t.create_float32(4, function (t) { return t[3] = 1, t }), e.dquat = t.create_float32(8, function (t) { return t[3] = 1, t }), e.aabb = t.create_float32(6), t.macro_scope(function (i, r, n, a, s, o, _, l, u, h, c, d, m, p, f, g, v, w, x) { e.vec3.set = t.macro(function (t, e, i, r) { t[0] = e, t[1] = i, t[2] = r }, e), e.vec3.zero = t.macro(function (t) { t[0] = 0, t[1] = 0, t[2] = 0 }, e), t.macro(function (t, e, i, r) { t[0], t[1], t[2] }, e), t.macro(function (t) { t[0], t[0], t[1], t[1], t[2], t[2] }, e), t.macro(function (t) { Math.abs(Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2])) }, e), e.vec3.length_sq = function (t) { return t[0] * t[0] + t[1] * t[1] + t[2] * t[2] }, e.vec3.get_length = function (t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]) }, e.vec3.negate = t.macro(function (t) { t[0] = -t[0], t[1] = -t[1], t[2] = -t[2] }, e), e.vec3.calc_distance = function (t, e, i, r, n, a) { return r -= t, n -= e, a -= i, Math.abs(Math.sqrt(r * r + n * n + a * a)) }, e.vec3.normalize = t.macro(function (t, e) { (a = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]) > 0 && (a = 1 / Math.sqrt(a)), t[0] = e[0] * a, t[1] = e[1] * a, t[2] = e[2] * a }, e, i), e.vec3.transform_quat = t.macro(function (t, e, i) { a = e[0], s = e[1], o = e[2], l = i[0], u = i[1], h = i[2], c = i[3], g = u * (f = l * s - u * a) - h * (p = h * a - l * o), v = h * (m = u * o - h * s) - l * f, w = l * p - u * m, m *= d = 2 * c, p *= d, f *= d, g *= 2, v *= 2, w *= 2, t[0] = a + m + g, t[1] = s + p + v, t[2] = o + f + w }, e, i), e.vec3.copy = t.macro(function (t, e) { t[0] = e[0], t[1] = e[1], t[2] = e[2] }, e), e.vec3.scale = t.macro(function (t, e, i) { t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i }, e), e.vec3.scale_add = t.macro(function (t, e, i, r) { t[0] = e[0] + i[0] * r, t[1] = e[1] + i[1] * r, t[2] = e[2] + i[2] * r }, e), e.vec3.cross = t.macro(function (t, e, i) { t[0] = e[1] * i[2] - e[2] * i[1], t[1] = e[2] * i[0] - e[0] * i[2], t[2] = e[0] * i[1] - e[1] * i[0] }, e), e.vec3.transform_mat4 = t.macro(function (t, e, i) { a = e[0], s = e[1], o = e[2], _ = 1 / (i[3] * a + i[7] * s + i[11] * o + i[15]), x = i, t[0] = (x[0] * a + x[4] * s + x[8] * o + x[12]) * _, t[1] = (x[1] * a + x[5] * s + x[9] * o + x[13]) * _, t[2] = (x[2] * a + x[6] * s + x[10] * o + x[14]) * _ }, e, i), e.vec3.transform_mat3 = t.macro(function (t, e, i) { a = e[0], s = e[1], o = e[2], x = i, t[0] = a * x[0] + s * x[3] + o * x[6], t[1] = a * x[1] + s * x[4] + o * x[7], t[2] = a * x[2] + s * x[5] + o * x[8] }, e, i), e.vec3.transform_mat4x = t.macro(function (t, e, i, r, n) { a = e, s = i, o = r, _ = 1 / (n[3] * a + n[7] * s + n[11] * o + n[15]), t[0] = (n[0] * a + n[4] * s + n[8] * o + n[12]) * _, t[1] = (n[1] * a + n[5] * s + n[9] * o + n[13]) * _, t[2] = (n[2] * a + n[6] * s + n[10] * o + n[14]) * _ }, e, i), e.vec3.add = t.macro(function (t, e, i) { t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2] }, e), e.vec3.subtract = t.macro(function (t, e, i) { t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2] }, e), e.vec3.multiply = t.macro(function (t, e, i) { t[0] = e[0] * i[0], t[1] = e[1] * i[1], t[2] = e[2] * i[2] }, e), e.vec3.dot = function (t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] } }, "math.vec3"), t.macro_scope(function (i) { e.vec4.set = t.macro(function (t, e, i, r, n) { t[0] = e, t[1] = i, t[2] = r, t[3] = n }, e), e.vec4.copy = t.macro(function (t, e) { t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3] }, e) }, "math.vec4"), t.macro_scope(function (i, r, n, a, s, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y, b, E, T, A, z) { e.mat3.translate_rotate_scale = t.macro(function (t, e, i, a, s, o) { r = Math.sin(o), n = Math.cos(o), t[0] = (1 * n + 0 * r) * a, t[1] = (0 * n + 1 * r) * a, t[2] = (0 * n + 0 * r) * a, t[3] = (0 * n - 1 * r) * s, t[4] = (1 * n - 0 * r) * s, t[5] = (0 * n - 0 * r) * s, t[6] = e * t[0] + i * t[3], t[7] = e * t[1] + i * t[4], t[8] = e * t[2] + i * t[5] }, e, i), e.mat3.from_quat = t.macro(function (t, e) { _ = e[0], l = e[1], u = e[2], h = e[3], c = _ * (v = _ + _), d = l * v, m = l * (w = l + l), p = u * v, f = u * w, g = u * (x = u + u), y = h * v, b = h * w, b = h * x, t[0] = 1 - m - g, t[3] = d - b, t[6] = p + b, t[1] = d + b, t[4] = 1 - c - g, t[7] = f - y, t[2] = p - b, t[5] = f + y, t[8] = 1 - c - m }, e, i), e.mat3.copy = t.macro(function (t, e) { t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8] }, e, i), e.mat3.set_diagonal = t.macro(function (t, e, i, r) { t[0] = e, t[4] = i, t[8] = r }, e, i), e.mat3.mult = t.macro(function (t, e, i) { a = t, o = i, _ = (s = e)[0], l = s[1], u = s[2], c = s[3], d = s[4], m = s[5], p = s[6], f = s[7], g = s[8], v = o[0], w = o[1], x = o[2], y = o[3], b = o[4], E = o[5], T = o[6], A = o[7], z = o[8], a[0] = v * _ + w * c + x * p, a[1] = v * l + w * d + x * f, a[2] = v * u + w * m + x * g, a[3] = y * _ + b * c + E * p, a[4] = y * l + b * d + E * f, a[5] = y * u + b * m + E * g, a[6] = T * _ + A * c + z * p, a[7] = T * l + A * d + z * f, a[8] = T * u + A * m + z * g }, e, i) }, "math.mat3"), t.macro_scope(function (i, r, n, a, s, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y, b, E, T, A, z, M, L, I, k, S, R, F, N, C, G, P, j, O, D, q, U, B, H) { e.mat4.identity = t.macro(function (t) { t.fill(0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1 }, e, i), e.mat4.perspective = t.macro(function (t, e, i, n, a) { j = t, r = 1 / Math.tan(e / 2), j[0] = r / i, j[1] = 0, j[2] = 0, j[3] = 0, j[4] = 0, j[5] = r, j[6] = 0, j[7] = 0, j[8] = 0, j[9] = 0, j[11] = -1, j[12] = 0, j[13] = 0, j[15] = 0, null != a && a !== 1 / 0 ? (r = 1 / (n - a), j[10] = (a + n) * r, j[14] = 2 * a * n * r) : (j[10] = -1, j[14] = -2 * n) }, e, i), e.mat4.ortho = t.macro(function (t, e, i, s, o, _, l) { r = 1 / (e - i), n = 1 / (s - o), a = 1 / (_ - l), (j = t)[0] = -2 * r, j[1] = 0, j[2] = 0, j[3] = 0, j[4] = 0, j[6] = 0, j[7] = 0, j[8] = 0, j[9] = 0, j[5] = -2 * n, j[10] = 2 * a, j[11] = 0, j[12] = (e + i) * r, j[13] = (o + s) * n, j[14] = (l + _) * a, j[15] = 1 }, e, i), e.mat4.inverse = t.macro(function (t, e) { j = t, r = (O = e)[0], n = O[1], a = O[2], s = O[3], d = O[4], m = O[5], p = O[6], f = O[7], g = O[8], v = O[9], w = O[10], x = O[11], y = O[12], b = O[13], E = O[14], T = O[15], (A = (z = r * m - n * d) * (P = w * T - x * E) - (M = r * p - a * d) * (G = v * T - x * b) + (L = r * f - s * d) * (C = v * E - w * b) + (I = n * p - a * m) * (N = g * T - x * y) - (k = n * f - s * m) * (F = g * E - w * y) + (S = a * f - s * p) * (R = g * b - v * y)) && (A = 1 / A, j[0] = (m * P - p * G + f * C) * A, j[1] = (a * G - n * P - s * C) * A, j[2] = (b * S - E * k + T * I) * A, j[3] = (w * k - v * S - x * I) * A, j[4] = (p * N - d * P - f * F) * A, j[5] = (r * P - a * N + s * F) * A, j[6] = (E * L - y * S - T * M) * A, j[7] = (g * S - w * L + x * M) * A, j[8] = (d * G - m * N + f * R) * A, j[9] = (n * N - r * G - s * R) * A, j[10] = (y * k - b * L + T * z) * A, j[11] = (v * L - g * k - x * z) * A, j[12] = (m * F - d * C - p * R) * A, j[13] = (r * C - n * F + a * R) * A, j[14] = (b * M - y * I - E * z) * A, j[15] = (g * I - v * M + w * z) * A) }, e, i), e.mat4.transpose = t.macro(function (t, e) { t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11] }, e, i), e.mat4.from_quat = t.macro(function (t, e) { j = t, r = (q = e)[0], n = q[1], a = q[2], s = q[3], z = r * (_ = r + r), M = r * (l = n + n), L = r * (u = a + a), I = n * l, k = n * u, S = a * u, R = s * _, F = s * l, N = s * u, j[0] = 1 - (I + S), j[1] = M + N, j[2] = L - F, j[3] = 0, j[4] = M - N, j[5] = 1 - (z + S), j[6] = k + R, j[7] = 0, j[8] = L + F, j[9] = k - R, j[10] = 1 - (z + I), j[11] = 0 }, e, i), e.mat4.scale = t.macro(function (t, e) { q = e, (j = t)[0] *= q[0], j[1] *= q[0], j[2] *= q[0], j[3] *= q[0], j[4] *= q[1], j[5] *= q[1], j[6] *= q[1], j[7] *= q[1], j[8] *= q[2], j[9] *= q[2], j[10] *= q[2], j[11] *= q[2] }, e, i), e.mat4.multiply = t.macro(function (t, e, i) { j = t, D = i, r = (O = e)[0], n = O[1], a = O[2], s = O[3], d = O[4], m = O[5], p = O[6], f = O[7], g = O[8], v = O[9], w = O[10], x = O[11], y = O[12], b = O[13], E = O[14], T = O[15], z = D[0], M = D[1], L = D[2], I = D[3], j[0] = z * r + M * d + L * g + I * y, j[1] = z * n + M * m + L * v + I * b, j[2] = z * a + M * p + L * w + I * E, j[3] = z * s + M * f + L * x + I * T, z = D[4], M = D[5], L = D[6], I = D[7], j[4] = z * r + M * d + L * g + I * y, j[5] = z * n + M * m + L * v + I * b, j[6] = z * a + M * p + L * w + I * E, j[7] = z * s + M * f + L * x + I * T, z = D[8], M = D[9], L = D[10], I = D[11], j[8] = z * r + M * d + L * g + I * y, j[9] = z * n + M * m + L * v + I * b, j[10] = z * a + M * p + L * w + I * E, j[11] = z * s + M * f + L * x + I * T, z = D[12], M = D[13], L = D[14], I = D[15], j[12] = z * r + M * d + L * g + I * y, j[13] = z * n + M * m + L * v + I * b, j[14] = z * a + M * p + L * w + I * E, j[15] = z * s + M * f + L * x + I * T }, e, i), e.mat4.copy = t.macro(function (t, e) { O = e, (j = t)[0] = O[0], j[1] = O[1], j[2] = O[2], j[3] = O[3], j[4] = O[4], j[5] = O[5], j[6] = O[6], j[7] = O[7], j[8] = O[8], j[9] = O[9], j[10] = O[10], j[11] = O[11], j[12] = O[12], j[13] = O[13], j[14] = O[14], j[15] = O[15] }, e, i), e.mat4.sd_vector = function (t, e) { t[0] = e[0], t[1] = e[1], t[2] = e[2] }, e.mat4.up_vector = function (t, e) { t[0] = e[4], t[1] = e[5], t[2] = e[6] }, e.mat4.fw_vector = function (t, e) { t[0] = e[8], t[1] = e[9], t[2] = e[10] }, e.mat4.from_mat3 = t.macro(function (t, e) { O = e, (j = t)[0] = O[0], j[1] = O[1], j[2] = O[2], j[4] = O[3], j[5] = O[4], j[6] = O[5], j[8] = O[6], j[9] = O[7], j[10] = O[8] }, e, i), e.mat4.target_to = t.macro(function (t, e, i, s) { j = t, B = s, H = i, r = (U = e)[0] - H[0], n = U[1] - H[1], a = U[2] - H[2], (A = r * r + n * n + a * a) > 0 && (A = 1 / Math.sqrt(A), r *= A, n *= A, a *= A), z = B[1] * a - B[2] * n, M = B[2] * r - B[0] * a, L = B[0] * n - B[1] * r, (A = z * z + M * M + L * L) > 0 && (A = 1 / Math.sqrt(A), z *= A, M *= A, L *= A), j[0] = z, j[1] = M, j[2] = L, j[3] = 0, j[4] = n * L - a * M, j[5] = a * z - r * L, j[6] = r * M - n * z, j[7] = 0, j[8] = r, j[9] = n, j[10] = a, j[11] = 0, j[12] = U[0], j[13] = U[1], j[14] = U[2], j[15] = 1 }, e, i), e.mat4.get_scaling = function (t, e) { return t[0] = Math.hypot(e[0], e[1], e[2]), t[1] = Math.hypot(e[4], e[5], e[6]), t[2] = Math.hypot(e[8], e[9], e[10]), t }, e.mat4.get_translation = function (t, e) { return t[0] = e[12], t[1] = e[13], t[2] = e[14], t }; var X, K, Z, V, Y, W, Q, $, J, tt, et, it, rt, nt, at = e.vec3(); e.mat4.get_rotation = function (t, e) { return this.get_scaling(at, e), X = 1 / at[0], K = 1 / at[1], Z = 1 / at[2], V = e[0] * X, Y = e[1] * K, W = e[2] * Z, Q = e[4] * X, $ = e[5] * K, J = e[6] * Z, tt = e[8] * X, et = e[9] * K, it = e[10] * Z, nt = 0, (rt = V + $ + it) > 0 ? (nt = 2 * Math.sqrt(rt + 1), t[3] = .25 * nt, t[0] = (J - et) / nt, t[1] = (tt - W) / nt, t[2] = (Y - Q) / nt) : V > $ && V > it ? (nt = 2 * Math.sqrt(1 + V - $ - it), t[3] = (J - et) / nt, t[0] = .25 * nt, t[1] = (Y + Q) / nt, t[2] = (tt + W) / nt) : $ > it ? (nt = 2 * Math.sqrt(1 + $ - V - it), t[3] = (tt - W) / nt, t[0] = (Y + Q) / nt, t[1] = .25 * nt, t[2] = (J + et) / nt) : (nt = 2 * Math.sqrt(1 + it - V - $), t[3] = (Y - Q) / nt, t[0] = (tt + W) / nt, t[1] = (J + et) / nt, t[2] = .25 * nt), t } }, "math.mat4"), t.macro_scope(function (i, r, n, a, s, o) { e.aabb.set = t.macro(function (t, e, i, r, n, a, s) { t[0] = e, t[1] = i, t[2] = r, t[3] = n, t[4] = a, t[5] = s }, e, i), e.aabb.transform_mat4 = t.macro(function (t, e, i) { for (r = 0; r < 3; r++)for (t[r] = i[12 + r], t[r + 3] = i[12 + r], n = 0; n < 3; n++)o = i[3 * n + r + n], a = o * e[n], s = o * e[n + 3], a < s ? (t[r] += a, t[r + 3] += s) : (t[r] += s, t[r + 3] += a) }, e, i), e.aabb.decompose = t.macro(function (t, e, i) { e[0] = t[0], e[1] = t[1], e[2] = t[2], i[0] = t[3], i[1] = t[4], i[2] = t[5] }, e, i) }, "math.aabb"), t.macro_scope(function (i, r, n, a, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y) { e.quat.mult = t.macro(function (t, e, i) { m = t, f = i, r = (p = e)[0], n = p[1], a = p[2], o = p[3], _ = f[0], l = f[1], u = f[2], h = f[3], m[0] = r * h + o * _ + n * u - a * l, m[1] = n * h + o * l + a * _ - r * u, m[2] = a * h + o * u + r * l - n * _, m[3] = o * h - r * _ - n * l - a * u }, e, i), e.quat.copy = t.macro(function (t, e) { t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3] }, e, i), e.quat.normalize = t.macro(function (t, e) { m = t, r = (p = e)[0], n = p[1], a = p[2], o = p[3], (c = r * r + n * n + a * a + o * o) > 0 && (c = 1 / Math.sqrt(c)), m[0] = r * c, m[1] = n * c, m[2] = a * c, m[3] = o * c }, e, i), e.quat.rotate_eular = t.macro(function (t, e, i, s) { m = t, r = Math.sin(.5 * e), n = Math.sin(.5 * i), a = Math.sin(.5 * s), _ = Math.cos(.5 * e), l = Math.cos(.5 * i), u = Math.cos(.5 * s), m[0] = r * l * u - _ * n * a, m[1] = _ * n * u + r * l * a, m[2] = _ * l * a - r * n * u, m[3] = _ * l * u + r * n * a, r = m[0], n = m[1], a = m[2], o = m[3], (c = r * r + n * n + a * a + o * o) > 0 && (c = 1 / Math.sqrt(c)), m[0] = r * c, m[1] = n * c, m[2] = a * c, m[3] = o * c }, e, i), e.quat.invert = t.macro(function (t, e) { m = t, r = (p = e)[0], n = p[1], a = p[2], o = p[3], (c = r * r + n * n + a * a + o * o) > 0 && (c = 1 / Math.sqrt(c)), m[0] = -r * c, m[1] = -n * c, m[2] = -a * c, m[3] = o * c }, e, i), e.quat.ss = function (t, e, i, r, n, a, s, o, _, l) { (g = e * a + i * s + r * o + n * _) < 0 && (g = -g, a = -a, s = -s, o = -o, _ = -_), 1 - g > 1e-6 ? (v = Math.acos(g), w = Math.sin(v), x = Math.sin((1 - l) * v) / w, y = Math.sin(l * v) / w) : (x = 1 - l, y = l), t[0] = x * e + y * a, t[1] = x * i + y * s, t[2] = x * r + y * o, t[3] = x * n + y * _ }, e.quat.slerp_flat = t.macro(function (t, e, i, r, n, a, s, o, _, l) { (g = e * a + i * s + r * o + n * _) < 0 && (g = -g, a = -a, s = -s, o = -o, _ = -_), 1 - g > 1e-6 ? (v = Math.acos(g), w = Math.sin(v), x = Math.sin((1 - l) * v) / w, y = Math.sin(l * v) / w) : (x = 1 - l, y = l), t[0] = x * e + y * a, t[1] = x * i + y * s, t[2] = x * r + y * o, t[3] = x * n + y * _ }, e, i), e.quat.from_vec3_float = t.macro(function (t, e, i) { t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = i }, e), e.quat.from_mat3 = t.macro(function (t, e) { m = t, _ = (d = e)[0], l = d[4], u = d[8], (h = _ + l + u) > 0 ? (h = Math.sqrt(h + 1), quat1$[3] = .5 * h, s = .5 / h, quat1$[0] = (d[7] - d[5]) * h, quat1$[1] = (d[2] - d[6]) * h, quat1$[2] = (d[3] - d[1]) * h) : _ > l ? _ > u ? (h = Math.sqrt(_ - l - u + 1), quat1$[0] = .5 * h, h = .5 / h, quat1$[1] = (d[1] + d[3]) * h, quat1$[2] = (d[2] + d[6]) * h, quat1$[3] = (d[7] - d[5]) * h) : (h = Math.sqrt(e22 - _ - l + 1), quat1$[2] = .5 * h, h = .5 / h, quat1$[0] = (d[2] + d[6]) * h, quat1$[1] = (d[5] + d[7]) * h, quat1$[3] = (d[3] - d[1]) * h) : l > u ? (h = Math.sqrt(l - u - _ + 1), quat1$[1] = .5 * h, h = .5 / h, quat1$[0] = (d[1] + d[3]) * h, quat1$[2] = (d[5] + d[7]) * h, quat1$[3] = (d[2] - d[6]) * h) : (h = Math.sqrt(u - _ - l + 1), quat1$[2] = .5 * h, h = .5 / h, quat1$[0] = (d[2] + d[6]) * h, quat1$[1] = (d[5] + d[7]) * h, quat1$[3] = (d[3] - d[1]) * h) }, e) }, "math.quat"), t.macro_scope(function (i, r, n, a, s, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y, b) { e.dquat.mult = t.macro(function (t, e, i) { r = t, a = i, s = (n = e)[0], o = n[1], _ = n[2], l = n[3], u = n[4], h = n[5], c = n[6], d = n[7], m = a[0], p = a[1], f = a[2], g = a[3], v = a[4], w = a[5], x = a[6], y = a[7], r[0] = s * g + l * m + o * f - _ * p, r[1] = o * g + l * p + _ * m - s * f, r[2] = _ * g + l * f + s * p - o * m, r[3] = l * g - s * m - o * p - _ * f, r[4] = s * y + l * v + o * x - _ * w + u * g + d * m + h * f - c * p, r[5] = o * y + l * w + _ * v - s * x + h * g + d * p + c * m - u * f, r[6] = _ * y + l * x + s * w - o * v + c * g + d * f + u * p - h * m, r[7] = l * y - s * v - o * w - _ * x + d * g - u * m - h * p - c * f }, e, i), e.dquat.from_quat_pos = t.macro(function (t, e, i) { (r = t)[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], s = .5 * i[0], o = .5 * i[1], _ = .5 * i[2], m = r[0], p = r[1], f = r[2], g = r[3], r[4] = s * g + o * f - _ * p, r[5] = o * g + _ * m - s * f, r[6] = _ * g + s * p - o * m, r[7] = -s * m - o * p - _ * f }, e, i), e.dquat.invert = t.macro(function (t, e) { r = t, s = (n = e)[0], o = n[1], _ = n[2], l = n[3], (b = s * s + o * o + _ * _ + l * l) > 0 && (b = 1 / Math.sqrt(b)), r[0] = -s * b, r[1] = -o * b, r[2] = -_ * b, r[3] = l * b }, e, i); var E = e.quat(), T = e.vec3(); e.dquat.from_mat4 = function (t, i) { return e.mat4.get_rotation(E, i), e.mat4.get_translation(T, i), e.dquat.from_quat_pos(t, E, T), t }, e.dquat.get_translation = function (t, e) { return s = e[4], o = e[5], _ = e[6], l = e[7], m = -e[0], p = -e[1], f = -e[2], g = e[3], t[0] = 2 * (s * g + l * m + o * f - _ * p), t[1] = 2 * (o * g + l * p + _ * m - s * f), t[2] = 2 * (_ * g + l * f + s * p - o * m), t } }, "math.dquat"), t.macro_scope(function (t) { e.utils.ray_plane_intersection = function (t, i, r, n, a) { var s = e.vec3.pool.get(); e.vec3.subtract(s, r, i); var o = e.vec3.dot(s, a); if (o <= 1e-6 && o >= -1e-6) return !1; var _ = e.vec3.pool.get(); return e.vec3.subtract(_, n, i), o = e.vec3.dot(_, a) / o, e.vec3.pool.free(s), e.vec3.pool.free(_), o >= 0 && (e.vec3.scale_add(t, i, s, o), !0) }, e.utils.mat4_into_up_fw_sd = function (t) { return { up: new Float32Array(t.buffer, 16, 3), fw: new Float32Array(t.buffer, 32, 3), sd: new Float32Array(t.buffer, 0, 3) } } }, "math.utils") }.apply(_FM.math, [_FM.fin]), _FM.ge = new Object, function (t, e) { Object.assign(this, { SHADING: { FLAT: 2, SHADED: 4, POST_SHADING: 8, CAST_SHADOW: 16, RECEIVE_SHADOW: 32, RECEIVE_REFLECTION: 64, TRANSPARENT: 128, OPUQUE: 256, DEPTH_TEST: 512, NO_DEPTH_TEST: 1024, DOUBLE_SIDES: 2048, SHADOW_DOUBLE_SIDES: 4096 }, DISPLAY_ALWAYS: 2, ITEM_TYPES: { MESH: 4, LIGHT: 8, CAMERA: 16, MANIPULATOR: 32, OTHER: 1024 }, PICKABLE_MESH: 2048, TRANS: { SCALABLE: 2, ANIMATED: 4, ANIMATED_POSITION: 8, ANIMATED_SCALE: 16, ANIMATED_ROTATION: 32, IK_ANIMATED: 64 }, GL_ACTIVE_ATTRIBUTES: 35721, GL_ACTIVE_TEXTURE: 34016, GL_ACTIVE_UNIFORMS: 35718, GL_ALIASED_LINE_WIDTH_RANGE: 33902, GL_ALIASED_POINT_SIZE_RANGE: 33901, GL_ALPHA: 6406, GL_ALPHA_BITS: 3413, GL_ALWAYS: 519, GL_ARRAY_BUFFER: 34962, GL_ARRAY_BUFFER_BINDING: 34964, GL_ATTACHED_SHADERS: 35717, GL_BACK: 1029, GL_BLEND: 3042, GL_BLEND_COLOR: 32773, GL_BLEND_DST_ALPHA: 32970, GL_BLEND_DST_RGB: 32968, GL_BLEND_EQUATION: 32777, GL_BLEND_EQUATION_ALPHA: 34877, GL_BLEND_EQUATION_RGB: 32777, GL_BLEND_SRC_ALPHA: 32971, GL_BLEND_SRC_RGB: 32969, GL_BLUE_BITS: 3412, GL_BOOL: 35670, GL_BOOL_VEC2: 35671, GL_BOOL_VEC3: 35672, GL_BOOL_VEC4: 35673, GL_BROWSER_DEFAULT_WEBGL: 37444, GL_BUFFER_SIZE: 34660, GL_BUFFER_USAGE: 34661, GL_BYTE: 5120, GL_CCW: 2305, GL_CLAMP_TO_EDGE: 33071, GL_COLOR_ATTACHMENT0: 36064, GL_COLOR_BUFFER_BIT: 16384, GL_COLOR_CLEAR_VALUE: 3106, GL_COLOR_WRITEMASK: 3107, GL_COMPILE_STATUS: 35713, GL_COMPRESSED_TEXTURE_FORMATS: 34467, GL_CONSTANT_ALPHA: 32771, GL_CONSTANT_COLOR: 32769, GL_CONTEXT_LOST_WEBGL: 37442, GL_CULL_FACE: 2884, GL_CULL_FACE_MODE: 2885, GL_CURRENT_PROGRAM: 35725, GL_CURRENT_VERTEX_ATTRIB: 34342, GL_CW: 2304, GL_DECR: 7683, GL_DECR_WRAP: 34056, GL_DELETE_STATUS: 35712, GL_DEPTH_ATTACHMENT: 36096, GL_DEPTH_BITS: 3414, GL_DEPTH_BUFFER_BIT: 256, GL_DEPTH_CLEAR_VALUE: 2931, GL_DEPTH_COMPONENT: 6402, GL_DEPTH_COMPONENT16: 33189, GL_DEPTH_FUNC: 2932, GL_DEPTH_RANGE: 2928, GL_DEPTH_STENCIL: 34041, GL_DEPTH_STENCIL_ATTACHMENT: 33306, GL_DEPTH_TEST: 2929, GL_DEPTH_WRITEMASK: 2930, GL_DITHER: 3024, GL_DONT_CARE: 4352, GL_DST_ALPHA: 772, GL_DST_COLOR: 774, GL_DYNAMIC_DRAW: 35048, GL_ELEMENT_ARRAY_BUFFER: 34963, GL_ELEMENT_ARRAY_BUFFER_BINDING: 34965, GL_EQUAL: 514, GL_FASTEST: 4353, GL_FLOAT: 5126, GL_FLOAT_MAT2: 35674, GL_FLOAT_MAT3: 35675, GL_FLOAT_MAT4: 35676, GL_FLOAT_VEC2: 35664, GL_FLOAT_VEC3: 35665, GL_FLOAT_VEC4: 35666, GL_FRAGMENT_SHADER: 35632, GL_FRAMEBUFFER: 36160, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048, GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051, GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050, GL_FRAMEBUFFER_BINDING: 36006, GL_FRAMEBUFFER_COMPLETE: 36053, GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054, GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057, GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055, GL_FRAMEBUFFER_UNSUPPORTED: 36061, GL_FRONT: 1028, GL_FRONT_AND_BACK: 1032, GL_FRONT_FACE: 2886, GL_FUNC_ADD: 32774, GL_FUNC_REVERSE_SUBTRACT: 32779, GL_FUNC_SUBTRACT: 32778, GL_GENERATE_MIPMAP_HINT: 33170, GL_GEQUAL: 518, GL_GREATER: 516, GL_GREEN_BITS: 3411, GL_HIGH_FLOAT: 36338, GL_HIGH_INT: 36341, GL_IMPLEMENTATION_COLOR_READ_FORMAT: 35739, GL_IMPLEMENTATION_COLOR_READ_TYPE: 35738, GL_INCR: 7682, GL_INCR_WRAP: 34055, GL_INT: 5124, GL_INT_VEC2: 35667, GL_INT_VEC3: 35668, GL_INT_VEC4: 35669, GL_INVALID_ENUM: 1280, GL_INVALID_FRAMEBUFFER_OPERATION: 1286, GL_INVALID_OPERATION: 1282, GL_INVALID_VALUE: 1281, GL_INVERT: 5386, GL_KEEP: 7680, GL_LEQUAL: 515, GL_LESS: 513, GL_LINEAR: 9729, GL_LINEAR_MIPMAP_LINEAR: 9987, GL_LINEAR_MIPMAP_NEAREST: 9985, GL_LINES: 1, GL_LINE_LOOP: 2, GL_LINE_STRIP: 3, GL_LINE_WIDTH: 2849, GL_LINK_STATUS: 35714, GL_LOW_FLOAT: 36336, GL_LOW_INT: 36339, GL_LUMINANCE: 6409, GL_LUMINANCE_ALPHA: 6410, GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661, GL_MAX_CUBE_MAP_TEXTURE_SIZE: 34076, GL_MAX_FRAGMENT_UNIFORM_VECTORS: 36349, GL_MAX_RENDERBUFFER_SIZE: 34024, GL_MAX_TEXTURE_IMAGE_UNITS: 34930, GL_MAX_TEXTURE_SIZE: 3379, GL_MAX_VARYING_VECTORS: 36348, GL_MAX_VERTEX_ATTRIBS: 34921, GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660, GL_MAX_VERTEX_UNIFORM_VECTORS: 36347, GL_MAX_VIEWPORT_DIMS: 3386, GL_MEDIUM_FLOAT: 36337, GL_MEDIUM_INT: 36340, GL_MIRRORED_REPEAT: 33648, GL_NEAREST: 9728, GL_NEAREST_MIPMAP_LINEAR: 9986, GL_NEAREST_MIPMAP_NEAREST: 9984, GL_NEVER: 512, GL_NICEST: 4354, GL_NONE: 0, GL_NOTEQUAL: 517, GL_NO_ERROR: 0, GL_ONE: 1, GL_ONE_MINUS_CONSTANT_ALPHA: 32772, GL_ONE_MINUS_CONSTANT_COLOR: 32770, GL_ONE_MINUS_DST_ALPHA: 773, GL_ONE_MINUS_DST_COLOR: 775, GL_ONE_MINUS_SRC_ALPHA: 771, GL_ONE_MINUS_SRC_COLOR: 769, GL_OUT_OF_MEMORY: 1285, GL_PACK_ALIGNMENT: 3333, GL_POINTS: 0, GL_POLYGON_OFFSET_FACTOR: 32824, GL_POLYGON_OFFSET_FILL: 32823, GL_POLYGON_OFFSET_UNITS: 10752, GL_RED_BITS: 3410, GL_RENDERBUFFER: 36161, GL_RENDERBUFFER_ALPHA_SIZE: 36179, GL_RENDERBUFFER_BINDING: 36007, GL_RENDERBUFFER_BLUE_SIZE: 36178, GL_RENDERBUFFER_DEPTH_SIZE: 36180, GL_RENDERBUFFER_GREEN_SIZE: 36177, GL_RENDERBUFFER_HEIGHT: 36163, GL_RENDERBUFFER_INTERNAL_FORMAT: 36164, GL_RENDERBUFFER_RED_SIZE: 36176, GL_RENDERBUFFER_STENCIL_SIZE: 36181, GL_RENDERBUFFER_WIDTH: 36162, GL_RENDERER: 7937, GL_REPEAT: 10497, GL_REPLACE: 7681, GL_RGB: 6407, GL_RGB5_A1: 32855, GL_RGB565: 36194, GL_RGBA: 6408, GL_RGBA4: 32854, GL_SAMPLER_2D: 35678, GL_SAMPLER_CUBE: 35680, GL_SAMPLES: 32937, GL_SAMPLE_ALPHA_TO_COVERAGE: 32926, GL_SAMPLE_BUFFERS: 32936, GL_SAMPLE_COVERAGE: 32928, GL_SAMPLE_COVERAGE_INVERT: 32939, GL_SAMPLE_COVERAGE_VALUE: 32938, GL_SCISSOR_BOX: 3088, GL_SCISSOR_TEST: 3089, GL_SHADER_TYPE: 35663, GL_SHADING_LANGUAGE_VERSION: 35724, GL_SHORT: 5122, GL_SRC_ALPHA: 770, GL_SRC_ALPHA_SATURATE: 776, GL_SRC_COLOR: 768, GL_STATIC_DRAW: 35044, GL_STENCIL_ATTACHMENT: 36128, GL_STENCIL_BACK_FAIL: 34817, GL_STENCIL_BACK_FUNC: 34816, GL_STENCIL_BACK_PASS_DEPTH_FAIL: 34818, GL_STENCIL_BACK_PASS_DEPTH_PASS: 34819, GL_STENCIL_BACK_REF: 36003, GL_STENCIL_BACK_VALUE_MASK: 36004, GL_STENCIL_BACK_WRITEMASK: 36005, GL_STENCIL_BITS: 3415, GL_STENCIL_BUFFER_BIT: 1024, GL_STENCIL_CLEAR_VALUE: 2961, GL_STENCIL_FAIL: 2964, GL_STENCIL_FUNC: 2962, GL_STENCIL_INDEX8: 36168, GL_STENCIL_PASS_DEPTH_FAIL: 2965, GL_STENCIL_PASS_DEPTH_PASS: 2966, GL_STENCIL_REF: 2967, GL_STENCIL_TEST: 2960, GL_STENCIL_VALUE_MASK: 2963, GL_STENCIL_WRITEMASK: 2968, GL_STREAM_DRAW: 35040, GL_SUBPIXEL_BITS: 3408, GL_TEXTURE: 5890, GL_TEXTURE0: 33984, GL_TEXTURE1: 33985, GL_TEXTURE2: 33986, GL_TEXTURE3: 33987, GL_TEXTURE4: 33988, GL_TEXTURE5: 33989, GL_TEXTURE6: 33990, GL_TEXTURE7: 33991, GL_TEXTURE8: 33992, GL_TEXTURE9: 33993, GL_TEXTURE10: 33994, GL_TEXTURE11: 33995, GL_TEXTURE12: 33996, GL_TEXTURE13: 33997, GL_TEXTURE14: 33998, GL_TEXTURE15: 33999, GL_TEXTURE16: 34e3, GL_TEXTURE17: 34001, GL_TEXTURE18: 34002, GL_TEXTURE19: 34003, GL_TEXTURE20: 34004, GL_TEXTURE21: 34005, GL_TEXTURE22: 34006, GL_TEXTURE23: 34007, GL_TEXTURE24: 34008, GL_TEXTURE25: 34009, GL_TEXTURE26: 34010, GL_TEXTURE27: 34011, GL_TEXTURE28: 34012, GL_TEXTURE29: 34013, GL_TEXTURE30: 34014, GL_TEXTURE31: 34015, GL_TEXTURE_2D: 3553, GL_TEXTURE_BINDING_2D: 32873, GL_TEXTURE_BINDING_CUBE_MAP: 34068, GL_TEXTURE_CUBE_MAP: 34067, GL_TEXTURE_CUBE_MAP_NEGATIVE_X: 34070, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074, GL_TEXTURE_CUBE_MAP_POSITIVE_X: 34069, GL_TEXTURE_CUBE_MAP_POSITIVE_Y: 34071, GL_TEXTURE_CUBE_MAP_POSITIVE_Z: 34073, GL_TEXTURE_MAG_FILTER: 10240, GL_TEXTURE_MIN_FILTER: 10241, GL_TEXTURE_WRAP_S: 10242, GL_TEXTURE_WRAP_T: 10243, GL_TRIANGLES: 4, GL_TRIANGLE_FAN: 6, GL_TRIANGLE_STRIP: 5, GL_UNPACK_ALIGNMENT: 3317, GL_UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443, GL_UNPACK_FLIP_Y_WEBGL: 37440, GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441, GL_UNSIGNED_BYTE: 5121, GL_UNSIGNED_INT: 5125, GL_UNSIGNED_SHORT: 5123, GL_UNSIGNED_SHORT_4_4_4_4: 32819, GL_UNSIGNED_SHORT_5_5_5_1: 32820, GL_UNSIGNED_SHORT_5_6_5: 33635, GL_VALIDATE_STATUS: 35715, GL_VENDOR: 7936, GL_VERSION: 7938, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975, GL_VERTEX_ATTRIB_ARRAY_ENABLED: 34338, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922, GL_VERTEX_ATTRIB_ARRAY_POINTER: 34373, GL_VERTEX_ATTRIB_ARRAY_SIZE: 34339, GL_VERTEX_ATTRIB_ARRAY_STRIDE: 34340, GL_VERTEX_ATTRIB_ARRAY_TYPE: 34341, GL_VERTEX_SHADER: 35633, GL_VIEWPORT: 2978, GL_ZERO: 0 }), this.module_export_code = function () { this.byte_code = this.byte_code.replace("/*STR_CONSTANTS*/", "Object.assign(this," + this.str_constants + ");") } }.apply(_FM.ge, [_FM.ecs, _FM.math]), function (t, e, i, r) { i.define = t.define, i.guidi = t.guidi, i.str = function (t, e, i, r, n, a) { return t = "var arr=[];arr.push('" + t.replace(/\n/g, "\\n").replace(/[\r\t]/g, " ").split("<?").join("\t").replace(/((^|\?>)[^\t]*)'/g, "$1\r").replace(/\t=(.*?)\?>/g, "',$1,'").split("\t").join("');").split("?>").join("arr.push('").split("\r").join("\\'") + "');return arr.join('');", new Function(e, i, r, n, a, t) }, i.create_canvas = function (t, e) { var i = document.createElement("canvas"); return i.ctx = i.getContext("2d"), i.width = t, i.height = e, i.set_size = function (t, e) { this.width = t, this.height = e }, i._get_image_data = function () { return this.imd = this.ctx.getImageData(0, 0, this.width, this.height), this.imd }, i._put_image_data = function () { this.ctx.putImageData(this.imd, 0, 0) }, i }, i.mouse_events = function (t, e) { t.addEventListener("mousedown", function (i) { t.bound_rect = t.bound_rect || t.getBoundingClientRect(), t.mouse_x = i.clientX - t.bound_rect.left, t.mouse_y = i.clientY - t.bound_rect.top, t.mouse_button = i.buttons, e(t, "mousedown", t.mouse_x, t.mouse_y, i) }), t.addEventListener("mouseup", function (i) { t.mouse_button = i.buttons, e(t, "mouseup", t.mouse_x, t.mouse_y, i) }), t.addEventListener("mousemove", function (i) { t.bound_rect = t.bound_rect || t.getBoundingClientRect(), t.mouse_x = i.clientX - t.bound_rect.left, t.mouse_y = i.clientY - t.bound_rect.top, t.mouse_button = i.buttons, e(t, "mousemove", t.mouse_x, t.mouse_y, i) }) }, i.event = i.define(function (t) { return t.add = function (t, e) { e = e || this.owner, this.handlers[this.handlers.length] = [t, e] }, t.trigger = function (t) { for (var e = 0; e < this.handlers.length; e++)if (!1 === this.handlers[e][0].apply(this.handlers[e][1], t)) return !1 }, t.trigger_params = function () { for (var t = 0; t < this.handlers.length; t++)if (!1 === this.handlers[t][0].apply(this.handlers[t][1], this.params)) return !1 }, function (t, e) { this.owner = t, this.handlers = [], this.params = e } }), i.flags_setting = i.define(function (t) { return i.set_flag = function (t, e) { return t & e || (t |= e), t }, i.unset_flag = function (t, e) { return 0 != (t & e) && (t &= ~e), t }, t.set_flag = function (t) { return this.flags & t || (this.flags |= t), this }, t.unset_flag = function (t) { return 0 != (this.flags & t) && (this.flags &= ~t), this }, function () { this.flags = 0 } }), i.bulk_image_loader = i.define(function (e) { return e.load = function (t, e) { var i = this.pool.get(); null !== i ? (i.params = e, i.manager = this, i.src = t) : this.park.enqueue([t, e]) }, e.check_park = function () { this.park.size() > 0 && this.load.apply(this, this.park.dequeue()) }, e.free = function (t) { this.pool.free(t), t.params = void 0, t.manager = void 0, t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=", this.check_park() }, function (e) { return this.park = new t.queue, this.pool = new t.object_pooler(function () { if (this.allocated <= this.max_size) { var t = new Image; return t.crossOrigin = "Anonymous", t.onload = function () { this.manager && (this.manager.onload(this, this.params), this.manager.auto_free && this.manager.free(this)) }, t } return this.allocated--, null }), this.pool.max_size = e, this.auto_free = !0, this } }), i.load_working_image = (l = new t.queue, u = new Image, u.crossOrigin = "Anonymous", u.is_busy = !1, function t(e, i) { u.is_busy ? l.enqueue([e, i]) : (u.onload = function () { i && i(this), this.is_busy = !1, l.size() > 0 && t.apply(this, l.dequeue()) }, u.is_busy = !0, u.src = e) }), i.load_working_image_data = function () { var e = new t.queue, r = new Image; r.crossOrigin = "Anonymous", r.is_busy = !1; var n = i.create_canvas(1, 1); return function t(i, a, s, o) { r.is_busy ? e.enqueue([i, a, s, o]) : (r.onload = function () { n.set_size(s || this.width, o || this.height), n.ctx.drawImage(this, 0, 0, n.width, n.height), a && a(n._get_image_data().data, n.width, n.height, this), n._put_image_data(), this.is_busy = !1, e.size() > 0 && t.apply(this, e.dequeue()) }, r.is_busy = !0, r.src = i) } }(), i.array = i.define(function (t) { t.push = function (t) { return this.data[this.length++] = t, this }; var e = 0; return t.push_args = function () { for (e = 0; e < arguments.length; e++)this.data[this.length++] = arguments[e] }, t.append_other = function (t) { for (e = 0; e < t.length; e++)this.data[this.length++] = t.data[e] }, t.peek = function () { return this.data[this.length - 1] }, t.pop = function () { return 0 === this.length ? null : this.data[--this.length] }, t.clear = function () { this.length = 0 }, t.for_each = function (t, e) { for (this.index = 0; this.index < this.length;)t(this.data[this.index], this.index++, e); this.index = 0 }, t.next = function () { return this.index < this.length ? this.data[this.index++] : null }, t.float32Array = function () { var t = new Float32Array(this.length); for (e = 0; e < this.length; e++)t[e] = this.data[e]; return t }, function () { this.data = [], this.length = 0, this.index = 0 } }), i.worker = function (t, e) { return new Worker(window.URL.createObjectURL(new Blob([(e || []).join(";") + ";self.main=" + t.toString() + ";self.main(self);"]))) }, i.worker_processor = i.define(function (e) { return e.add_job = function (e, i, r) { var n = this.job_id++, a = i.toString(), s = t.parse_args_from_func(a); if (r) { var o = r.toString(), _ = t.parse_args_from_func(o).join(","); a = function () { return function (t, e) { func_body() } }.toString().replace(/job_id/g, n).replace(/func_arguments/g, s.join(",")).replace(/respone_arguments/g, _).replace("func_body()", a.replace(/^function.*\(.*\)\s*\{|\}$/g, "")), this.jobs.push("self[" + n + "]=(" + a + ")()"), this.callbacks[n] = new Function("return " + function (t, e) { func_body() }.toString().replace(/respone_arguments/g, _).replace("func_body()", o.replace(/^function.*\(.*\)\s*\{|\}$/g, "")))() } else a = function (t, e) { func_body() }.toString().replace(/job_id/g, n).replace(/func_arguments/g, s.join(",")).replace("func_body()", a.replace(/^function.*\(.*\)\s*\{|\}$/g, "")), this.jobs.push("\nself[" + n + "]=" + a); this.jobs_func.push({ name: e, func: new Function("return " + function (t) { this.postMessage([job_id, t]) }.toString().replace(/job_id/g, n).replace(/func_arguments/g, s.join(",")))() }) }, e.data_processor = function (e, r, n) { var a = this.data_processor_id++, s = r.toString(), o = n.toString(), _ = t.parse_args_from_func(o).join(","), l = t.parse_args_from_func(s); s = function () { return function (t, e, i) { func_body() } }.toString().replace(/job_id/g, a).replace(/func_arguments/g, l.join(",")).replace(/respone_arguments/g, _).replace("func_body()", s.replace(/^function.*\(.*\)\s*\{|\}$/g, "")), this.jobs.push("self[" + a + "]=(" + s + ")()"); var u = this.DP; this.data_processors.push({ name: e, creator: i.define(function (i) { return i.params = new Array(l.length + 2), i.DP = u, i.parking = new t.queue, i.release = function (t, e) { this.DP.release(t, e), this.parking.size() > 0 && this.func.apply(this, this.parking.dequeue()) }, i.call = new Function("return " + function (t) { this._func_name.func(t) }.toString().replace(/func_arguments/g, l.join(",")).replace(/func_name/g, e))(), i.func = new Function("return " + function (t) { var e = this.DP.free_index(); e > -1 ? (data_buffer = this.DP.buffers[e], this.worker.postMessage([job_id, e, t], [data_buffer])) : this.parking.enqueue([t]) }.toString().replace(/func_arguments/g, l.join(",")).replace(/job_id/g, a))(), function (t) { this.worker = t } }) }), this.callbacks[a] = new Function("return " + function (t, e, i) { func_body(), this._func_name.release(e, data_buffer) }.toString().replace(/respone_arguments/g, _).replace(/func_name/g, e).replace("func_body()", o.replace(/^function.*\(.*\)\s*\{|\}$/g, "")))() }, e.build_worker = function (t) { var e = this.globals.join("\n") + this.jobs.join("\n"), i = new Worker(window.URL.createObjectURL(new Blob([e]))); for (var r in console.log(e), this.callbacks) i[r] = this.callbacks[r]; return i.host = t, this.data_processors.forEach(function (t) { i["_" + t.name] = new t.creator(i), i[t.name] = i["_" + t.name].call }), this.jobs_func.forEach(function (t) { i[t.name] = t.func }), i.onmessage = function (t) { this[t.data[0]].apply(this, t.data) }, i }, e.add_global = function (t) { this.globals.push(t.toString().replace(/^function.*\(.*\)\s*\{|\}$/g, "").trim()) }, function () { this.globals = [], this.data_processors = [], this.jobs = [], this.jobs_func = [], this.callbacks = {}, this.job_id = 100, this.data_processor_id = 1e4; var t = 0; this.DP = { buffers: [new ArrayBuffer(1), new ArrayBuffer(1), new ArrayBuffer(1)], free_index: function () { for (t = 0; t < this.buffers.length;) { if (this.buffers[t].byteLength > 0) return t; t++ } return -1 }, release: function (t, e) { this.buffers[t] = e } }, this.add_global(function () { self.onmessage = function (t) { this[t.data[0]].apply(this, t.data) } }) } }), i.renderable = i.define(function (t, e) { return t.expand_bounds = function (t, e, i) { this.bounds[0] = Math.min(this.bounds[0], t), this.bounds[1] = Math.min(this.bounds[1], e), this.bounds[2] = Math.min(this.bounds[2], i), this.bounds[3] = Math.max(this.bounds[3], t), this.bounds[4] = Math.max(this.bounds[4], e), this.bounds[5] = Math.max(this.bounds[5], i) }, t.initialize_item = function () { }, t.update_bounds = function (t) { }, t.update_world_transform = function (t, e, i) { r.mat4.from_quat(this.matrix_world, i), r.mat4.scale(this.matrix_world, e), this.matrix_world[12] = t[0], this.matrix_world[13] = t[1], this.matrix_world[14] = t[2] }, function (t) { this.matrix_world = r.mat4(), this.world_position = new Float32Array(this.matrix_world.buffer, 48, 3), this.view_position = r.vec3(), this.fw_vector = new Float32Array(this.matrix_world.buffer, 32, 3), this.bounds = r.aabb(), this.item_type = 1024, this.flags = 0, this.require_update = 0 } }), i.utils = {}, i.utils.timers = (n = [], a = 0, s = null, o = 0, _ = new t.object_pooler(function () { return n.push({}), n[n.length - 1] }), function t() { for (o = Date.now(), a = 0; a < n.length; a++)(s = n[a]).cb && o - s.last_time > s.interval && (s.last_time = o, s.cb(o - s.begin_time, o)); setTimeout(t, 100) }(), { create: function (t, e) { e = e || 1e3; var i = _.get(); return i.cb = t, i.interval = e, i.last_time = Date.now() - e, i.begin_time = i.last_time + e, i }, release: function (t) { t.cb = void 0, _.free(t) } }), i.utils.canvas_data_url = function () { var t = new i.create_canvas(1, 1); function e(e, i, r) { return t.set_size(e, i), r(t, t.ctx) } return e.box = function (e, i, r) { return t.set_size(e, i), t.ctx.fillStyle = r, t.ctx.fillRect(0, 0, e, i), t.toDataURL("image/png") }, e }(), i.app = i.define(function (e, r) { return e.create_renderable = function (t, e) { var i = this.create_entity({ components: { ge_transform: {}, ge_renderable: { items: [t] } } }); return t.entity_id = i.uuid, e(i.ge_renderable.items[0], i), i }, e.create_renderables = function (t, e) { var i = this.create_entity({ components: { ge_transform: {}, ge_renderable: { items: t } } }); return e && i.ge_renderable.items.forEach(function (t, r) { t.entity_id = i.uuid, e(t, i) }), i }, e.start = function (t) { return function (e, i) { var r = this; t.apply(this, [function () { this.on_frame.trigger(), e(), r.timer - r.last_debug_timer > .2 && (r.last_debug_timer = r.timer, r.show_debug && r.display_debug(r.debug_ctx)) }, i]) } }(e.start), e.display_debug = function (t) { t.clearRect(0, 0, this.debug_canvas.width, this.debug_canvas.height), t.fillStyle = "#ffffff", t.fillText(this.render_system.fps + " FPS", 2, 10); for (var e = 0; e < this._systems.length; e++)t.fillText(this._systems[e].name_id + " " + this._systems[e].frame_time + " ms ", 1, 10 * e + 25) }, function (e) { e = e || {}, r.apply(this, arguments), e.host = e.host || (document.body.style.height = "100vh", document.body.style.width = "100%", document.body.style.padding = "0", document.body.style.margin = "0", document.body.style.overflow = "hidden", document.body), this.use_system("ge_render_system", { host: e.host, renderer: e.renderer }), this.root = this.create_entity({ components: { ge_transform: {}, ge_renderable: { items: [] } } }), this.show_debug = e.show_debug || !1, this.on_frame = new i.event(this), this.last_debug_timer = 0, this.debug_canvas = i.create_canvas(1, 1), this.debug_canvas.setAttribute("style", "position:absolute;width:100%;height:100%;left:0;top:0;box-sizing: border-box;pointer-events: none;"), this.debug_ctx = this.debug_canvas.ctx, this.render_system = this.systems.ge_render_system, this.render_system.host.appendChild(this.debug_canvas); var n = this; this.all_timers = [], this.timers = new t.object_pooler(function () { var t = { cb: void 0, interval: 0, created: 0, lastClock: 0 }; return this.all_timers.push(t), t }), this.render_system.renderer.on_canvas_size = function (t, e) { n.debug_canvas.set_size(.5 * t, .5 * e) } } }, e.app); var n, a, s, o, _; var l, u }(_FM.fin, _FM.ecs, _FM.ge, _FM.math), function (t, e) { e.webgl = {}, e.webgl.texture = e.define(function (i) { function r(e, i, r, n, a, s, o) { this.uuid = t.guidi(), this.gl_texture = null, this.needs_update = !1, void 0 === n ? (this.source = new Uint8Array([255, 255, 255, 255]), this.needs_update = !0) : this.source = n, this.width = s || 1, this.height = o || 1, this.last_used_time = 0, this.format = i || 6408, this.format_type = r || 5121, this.target = e || 3553, this.parameters = {}, this.generate_mipmap = a || !1, this.parameters[10242] = 10497, this.parameters[10243] = 10497, this.generate_mipmap ? (this.parameters[10240] = 9729, this.parameters[10241] = 9987) : (this.parameters[10240] = 9728, this.parameters[10241] = 9728), this.source && null !== this.source && (this.needs_update = !0) } var n; return i.enable_linear_interpolation = function () { this.parameters[10240] = 9729, this.parameters[10241] = 9729 }, i.enable_nearest_interpolation = function () { this.parameters[10240] = 9728, this.parameters[10241] = 9728 }, i.enable_clamp_to_edge = function () { this.parameters[10242] = 33071, this.parameters[10243] = 33071 }, r.load_images = new e.bulk_image_loader(20), r.load_images.auto_free = !1, console.log(r.load_images), r.load_images.onload = (n = e.create_canvas(1, 1), function (t, e) { e.fit_size ? (n.set_size(e.fit_size, e.fit_size), n.ctx.drawImage(t, 0, 0, e.fit_size, e.fit_size), e.source = n._get_image_data().data, e.width = e.fit_size, e.height = e.fit_size, r.load_images.free(t)) : (e.source = t, e.width = t.width, e.height = t.height), e.needs_update = !0 }), i.free_source = function () { null !== this.source && (this.source.src && r.load_images.free(this.source), this.source = null) }, r.update_from_url = function (t, e) { return r.load_images.load(e, t), t }, r.from_url = function (t, i, n) { var a = new e.webgl.texture(void 0, void 0, void 0, null, i); return a.fit_size = n, r.load_images.load(t, a), a }, r.from_size = function (t, i) { return new e.webgl.texture(!1, !1, !1, null, !1, t, i) }, r.create_tiled_texture = function () { var i = e.create_canvas(1, 1); i.is_busy = !1; var n = e.create_canvas(1, 1), a = 0, s = 0, o = 0, _ = 0, l = null, u = []; function h(r, o, _, l, c) { if ((c = c || new e.webgl.texture(!1, !1, !1, null, !0, _, l)).tile_size = o, i.is_busy) return u.push([r, o, _, l, c]), c; i.is_busy = !0, i.set_size(_, l), n.set_size(o, o); var d = o / 2; return c.tile_offset = o / 4, c.tile_offsetf = c.tile_offset / _, c.tile_sizef = o / _, a = 0, s = 0, t.each_index(function (t, l) { e.load_working_image(r[t], function (m) { n.ctx.drawImage(m, 0, 0, d, d), n.ctx.drawImage(m, d, 0, d, d), n.ctx.drawImage(m, 0, d, d, d), n.ctx.drawImage(m, d, d, d, d), i.ctx.drawImage(n, a, s, o, o), a + o < _ ? a += o : (a = 0, s += o), t < r.length - 1 ? l(t + 1) : (c.source = i._get_image_data().data, c.needs_update = !0, i.is_busy = !1, u.length > 0 && h.apply(e.webgl.texture, u.shift())) }, o, o) }, 0), c } return n.ctx.imageSmoothingEnabled = !1, i.ctx.imageSmoothingEnabled = !1, r.create_texture_atlas = function (r, n) { return n = n || new e.webgl.texture(!1, !1, !1, null, !0, r.width, r.height), i.is_busy ? (u.push([r, n]), n) : (i.is_busy = !0, i.set_size(r.width, r.height), t.each_index(function (t, c) { l = r.inputs[t], e.load_working_image(l.src, function (d) { if (l.tiles_in_row && (l.tile_size = d.width / l.tiles_in_row, l.tile_width = l.tile_size, l.tile_height = l.tile_size), o = 0, _ = 0, l.rotation_sprites) { i.ctx.strokeStyle = "green"; for (var m = 6.283185 / l.rotation_sprites, p = 0; p <= 6.283185;)i.ctx.save(), i.ctx.translate(l.dest_x + o + .5 * l.dest_size, l.dest_y + _ + .5 * l.dest_size), i.ctx.rotate(p), i.ctx.drawImage(d, .5 * -l.dest_size, .5 * -l.dest_size, l.dest_size, l.dest_size), i.ctx.restore(), o += l.dest_size, p += m } else for (s = 0; s < d.height; s += l.tile_height)for (a = 0; a < d.width; a += l.tile_width)i.ctx.drawImage(d, a, s, l.tile_width, l.tile_height, l.dest_x + o, l.dest_y + _, l.dest_size, l.dest_size), o += l.dest_size, l.dest_per_row && o / l.dest_size >= l.dest_per_row && (o = 0, _ += l.dest_size); t < r.inputs.length - 1 ? c(t + 1) : (n.source = i._get_image_data().data, n.needs_update = !0, i.is_busy = !1, document.getElementById("test_texture_atlas") && (document.getElementById("test_texture_atlas").src = i.toDataURL("")), u.length > 0 && h.apply(e.webgl.texture, u.shift())) }) }, 0), n) }, h }(), r.pooler = t.define(function (i) { i.get = function (t) { return this.pool.get(t) }, i.free = function (t) { t.valid_id = -100, t.free_source(), this.pool.free(t) }, i.valid_texture = function (t, e) { return !(!t || !e) && t.valid_id === e }; var r, n = 0; return i.tick = function (t) { if (t - this.last_gc_time > this.gc_check_time) for (this.last_gc_time = t, n = 0; n < this.textures.length; n++)(r = this.textures[n]).valid_id > 0 && t - r.last_used_time > this.gc_time && this.free(r) }, i.create_texture = function (t) { return e.webgl.texture.from_url(t, !0) }, i.update_texture = function (t, i) { return e.webgl.texture.update_from_url(t, i) }, function (e) { e = e || {}, this.last_gc_time = 0, this.gc_check_time = e.gc_check_time || 5, this.gc_time = e.gc_time || 3; var i = this; this.textures = [], this.pool = new t.object_pooler(function (e) { var r = i.create_texture(e); return r.valid_id = t.guidi(), i.textures[i.textures.length] = r, r }, function (e, r) { return e.valid_id = t.guidi(), i.update_texture(e, r) }, e.pool_size) } }), r }), e.webgl.texture.dummy = new e.webgl.texture, e.webgl.canvas_texture = e.define(function (t, e) { return t.update = function (t) { this.source = t || this.canvas, this.needs_update = !0 }, function (t, i, r, n, a) { e.apply(this, [r, n, a, null, !1, t, i]), this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), this.parameters[10242] = 33071, this.parameters[10243] = 33071, this.source = this.canvas, this.canvas.width = this.width, this.canvas.height = this.height, this.ctx.transform(1, 0, 0, -1, 0, this.canvas.height), this.needs_update = !0 } }, e.webgl.texture), e.webgl.render_target = e.define(function (i) { return i.resize = function (t, e) { this.width = t, this.height = e, this.color_texture && (this.color_texture.width = t, this.color_texture.height = e, this.renderer.update_texture(this.color_texture)), this.depth_texture && (this.depth_texture.width = t, this.depth_texture.height = e, this.renderer.update_texture(this.depth_texture)), this.owned_depth_buffer && this.depth_buffer && (this.renderer.gl.bindRenderbuffer(36161, this.depth_buffer), this.renderer.gl.renderbufferStorage(36161, 33189, t, e)), this.vp_bottom = e, this.vp_right = t }, i.set_viewport_per = function (t, e, i, r) { return this.vp_left = this.width * t, this.vp_top = this.height * e, this.vp_right = this.width * i, this.vp_bottom = this.height * r, this }, i.set_viewport = function (t, e, i, r) { this.vp_left = t, this.vp_top = e, this.vp_right = i, this.vp_bottom = r }, i.set_default_viewport = function () { return this.set_viewport_per(0, 0, 1, 1), this }, i.bind = function (t) { return !(this.renderer.render_target_id === this.uuid && !t || (this.renderer.gl.bindFramebuffer(36160, this.frame_buffer), this.apply_viewport(), this.renderer.render_target_id = this.uuid, this.clear_buffer && this.renderer.gl.clear(16640), 0)) }, i.apply_viewport = function () { return this.renderer.gl.viewport(this.vp_left, this.vp_top, this.vp_right - this.vp_left, this.vp_bottom - this.vp_top), this }, i.bind_only = function () { return this.renderer.render_target_id === this.uuid ? this : (this.renderer.render_target_id = this.uuid, this.renderer.gl_bindFramebuffer(36160, this.frame_buffer), this.renderer.gl.viewport(this.vp_left, this.vp_top, this.vp_right - this.vp_left, this.vp_bottom - this.vp_top), this) }, i.unbind = function () { this.renderer.render_target_id = -1, this.renderer.gl_bindFramebuffer(36160, null) }, i.attach_color = function () { return this.color_texture = new e.webgl.texture(void 0, void 0, void 0, null, !1, this.width, this.height), this.bind_texture(this.color_texture, 36064), this.color_texture.parameters[10242] = 33071, this.color_texture.parameters[10243] = 33071, this.renderer.update_texture(this.color_texture), this }, i.attach_depth = function () { return this.depth_texture = this.bind_texture(new e.webgl.texture(void 0, 6402, 5123, null, !1, this.width, this.height), 36096), this.depth_texture.parameters[10242] = 33071, this.depth_texture.parameters[10243] = 33071, this }, i.check_status = function () { this.valid = !1; var t = this.renderer.gl.checkFramebufferStatus(36160); switch (t) { case 36053: this.valid = !0; break; case 36054: throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT"; case 36055: throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"; case 36057: throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS"; case 36061: throw "Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED"; default: throw "Incomplete framebuffer: " + t } }, i.attach_depth_buffer = function (t) { return t ? (this.depth_buffer = t, this.owned_depth_buffer = !1) : (this.owned_depth_buffer = !0, this.depth_buffer = this.renderer.gl.createRenderbuffer(), this.renderer.gl.bindRenderbuffer(36161, this.depth_buffer), this.renderer.gl.renderbufferStorage(36161, 33189, this.width, this.height)), this.renderer.gl.bindFramebuffer(36160, this.frame_buffer), this.renderer.gl.framebufferRenderbuffer(36160, 36096, 36161, this.depth_buffer), this.check_status(), this.renderer.gl.bindFramebuffer(36160, null), this.renderer.gl.bindRenderbuffer(36161, null), this }, i.bind_texture = function (t, e) { return this.renderer.gl.bindFramebuffer(36160, this.frame_buffer), null === t.gl_texture && this.renderer.update_texture(t), this.renderer.gl.bindTexture(t.target, t.gl_texture), t.generate_mipmap && this.renderer.gl.generateMipmap(t.target), this.renderer.gl.framebufferTexture2D(36160, e, t.target, t.gl_texture, 0), this.check_status(), this.renderer.gl.bindTexture(t.target, null), this.renderer.gl.bindFramebuffer(36160, null), t }, function (e, i, r) { return this.uuid = t.guidi(), this.renderer = e, this.frame_buffer = e.gl.createFramebuffer(), this.vp_left = 0, this.vp_top = 0, this.width = i, this.height = r, this.vp_bottom = r, this.vp_right = i, this.clear_buffer = !0, this.owned_depth_buffer = !1, this.set_default_viewport(), this.ratio = 1, this } }), e.webgl.shader = e.define(function (i) { function r(e, i) { return this.vs = e, this.fs = i, this.compiled = !1, this.uuid = t.guidi(), this.params = {}, this.parent = null, this.parts = null, this } return i.collect_parts = function (t, e) { null !== this.parent && this.parent.collect_parts(t, e), this.parts.vertex && t.push(this.parts.vertex), this.parts.fragment && e.push(this.parts.fragment) }, i.extend = function (t, i) { return e.webgl.shader.parse_shader(t, this, i) }, i.set_uniform = function (t, e) { var i = this.uniforms[t]; return !!i && (i.params[i.params_length] = e, i.func.apply(this.gl, i.params), !0) }, i.enter = function (t) { }, i.exit = function (t) { }, t.macro(function (t, e) { uni = r.uniforms[t], uni && (uni.params[uni.params_length] = e, uni.func.apply(r.gl, uni.params)) }, e), t.macro(function (t, e) { uni = r.uniforms[t], uni.params[uni.params_length] = e, uni.func.apply(r.gl, uni.params) }, e), r.chunks = {}, r.load_chunks = function (t) { t.split("/*chunk-").forEach(function (t) { if ((t = t.trim()).length > 0) { var e = t.substr(0, t.indexOf("*/") + 2); t = t.replace(e, ""), e = e.replace("*/", ""), r.chunks[e] = t } }) }, r.create_chunks_lib = function (t) { var e, i = {}; return t.split("/*chunk-").forEach(function (t) { (t = t.trim()).length > 0 && (e = t.substr(0, t.indexOf("*/") + 2), t = t.replace(e, ""), 0 === (e = e.replace("*/", "")).indexOf("global-") && (r.chunks[e] = t), i[e] = t) }), i }, r.load_chunks("/*chunk-precision*/ \n#extension GL_OES_standard_derivatives : enable\n#if GL_FRAGMENT_PRECISION_HIGH == 1\n    precision highp float;\n#else\nprecision mediump float;\n#endif\n\nconst float DEGTORAD=0.017453292519943295;\nconst float RADTODEG=57.295779513082323;\n\n\n\n\n\n\n/*chunk-shadow-sampling*/\n\nfloat sample_shadow_map(sampler2D shadowMap, vec2 coords, float compare)\n{\n\treturn step(compare, texture2D(shadowMap, coords.xy).r);\n}\n\nfloat sample_shadow_map_linear(sampler2D shadowMap, vec2 coords, float compare, vec2 texelSize)\n{\n\tvec2 pixelPos = coords / texelSize + vec2(0.5);\n\tvec2 fracPart = fract(pixelPos);\n\tvec2 startTexel = (pixelPos - fracPart) * texelSize;\n\n\tfloat blTexel = sample_shadow_map(shadowMap, startTexel, compare);\n\tfloat brTexel = sample_shadow_map(shadowMap, startTexel + vec2(texelSize.x, 0.0), compare);\n\tfloat tlTexel = sample_shadow_map(shadowMap, startTexel + vec2(0.0, texelSize.y), compare);\n\tfloat trTexel = sample_shadow_map(shadowMap, startTexel + texelSize, compare);\n\n\tfloat mixA = mix(blTexel, tlTexel, fracPart.y);\n\tfloat mixB = mix(brTexel, trTexel, fracPart.y);\n\n\treturn mix(mixA, mixB, fracPart.x);\n}\n\nfloat sample_shadow_map_pcf(sampler2D shadowMap, vec2 coords, float compare, vec2 texelSize)\n{\n\tconst float NUM_SAMPLES = 3.0;\n\tconst float SAMPLES_START = (NUM_SAMPLES - 1.0) / 2.0;\n\tconst float NUM_SAMPLES_SQUARED = NUM_SAMPLES * NUM_SAMPLES;\n\n\tfloat result = 0.0;\n\tfor (float y = -SAMPLES_START; y <= SAMPLES_START; y += 1.0)\n\t{\n\t\tfor (float x = -SAMPLES_START; x <= SAMPLES_START; x += 1.0)\n\t\t{\n\t\t\tvec2 coordsOffset = vec2(x, y) * texelSize;\n\t\t\tresult += sample_shadow_map_linear(shadowMap, coords + coordsOffset, compare, texelSize);\n\t\t}\n\t}\n\treturn result / NUM_SAMPLES_SQUARED;\n}\n\n\n/*chunk-timer*/\nuniform float u_timer_rw;\n\n\n/*chunk-random*/\nfloat random(vec3 seed, int i){\n\tvec4 seed4 = vec4(seed,i);\n\tfloat dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));\n\treturn fract(sin(dot_product) * 43758.5453);\n}\n\n\n\n/*chunk-debug_aabbs*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nattribute vec3 a_box_position_rw;\nattribute vec3 a_box_size_rw;\nattribute vec3 a_box_color_rw;\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\nvarying vec3 v_box_color_rw;\nvoid vertex(){\n    vec4 pos;\n    pos.xyz=a_position_rw*a_box_size_rw;    \n    pos.xyz+=a_box_position_rw;\n    pos.w=1.0;    \n    v_box_color_rw=a_box_color_rw;\n    gl_Position = u_view_projection_rw*u_model_rw*pos;\t\n    gl_PointSize =5.0;\n\n}\n<?=chunk('precision')?>\nvarying vec3 v_box_color_rw;\nvoid fragment(void) {\t\ngl_FragColor=vec4(v_box_color_rw,1.0);\n}\n\n\n\n\n\n/*chunk-quat-dquat*/\n\nvec3 quat_transform(vec4 q, vec3 v)\n{\n   return (v + cross(2.0 * q.xyz, cross(q.xyz, v) + q.w * v));\n}\n\n/*chunk-mat3-transpose*/\nmat3 transpose(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}"), r.context_param, r.$str = function (t, i) { return e.str(t, "chunk", "param")(i ? e.webgl.shader.nested_get_chunk : e.webgl.shader.get_chunk, e.webgl.shader.get_param) }, r.nested_get_chunk = function (t) { return e.webgl.shader.$str(e.webgl.shader.chunks[t], !0) }, r.get_chunk = function (t) { return e.webgl.shader.chunks[t] }, r.get_param = function (t) { return e.webgl.shader.context_param && void 0 !== e.webgl.shader.context_param[t] ? e.webgl.shader.context_param[t] : "" }, r.compile = function () { function t(t, e, i) { var r = t.createShader(i); t.shaderSource(r, e); var n = t.getShaderSource(r); return t.compileShader(r), t.getShaderParameter(r, 35713) ? r : (console.log("source", n), console.error("Error compiling shader : ", t.getShaderInfoLog(r)), console.log(e), t.deleteShader(r), null) } var i = function () { var t = { 5126: ["uniform1f", 2], 35664: ["uniform2fv", 2], 35665: ["uniform3fv", 2], 35666: ["uniform4fv", 2], 35678: ["uniform1i", 2], 35680: ["uniform1i", 2], 35675: ["uniformMatrix3fv", 3], 35676: ["uniformMatrix4fv", 3], float: 5126, vec2: 35664, vec3: 35665, vec4: 35666 }; function e(e, i, r, n) { var a = e.getUniformLocation(i.program, r), s = t[n], o = {}; 3 === s[1] ? o.params = [a, !1, 0] : 2 === s[1] && (o.params = [a, 0]), o.func = e[s[0]], o.params_length = o.params.length - 1, i.uniforms[r] = o } return function (t, i) { var r, n = 0, a = 0; for (i.uniforms = {}, n = 0; n < t.getProgramParameter(i.program, 35718); n++)if ((r = t.getActiveUniform(i.program, n)).size > 1) for (a = 0; a < r.size; a++)e(t, i, r.name.replace("[0]", "[" + a + "]"), r.type); else 1 === r.size && e(t, i, r.name, r.type); for (i.attributes = {}, i.all_attributes = [], n = 0; n < t.getProgramParameter(i.program, 35721); n++)r = t.getActiveAttrib(i.program, n), i.attributes[r.name] = { name: r.name, location: t.getAttribLocation(i.program, r.name) }, i.all_attributes.push(i.attributes[r.name]) } }(); return function (r, n, a) { var s, o; if (!n.compiled) return e.webgl.shader.context_param = {}, Object.assign(e.webgl.shader.context_param, a), Object.assign(e.webgl.shader.context_param, n.params), n.vs = e.webgl.shader.$str(n.vs, !0), n.fs = e.webgl.shader.$str(n.fs, !0), n.gl = r, !!(s = t(r, n.vs, 35633)) && ((o = t(r, n.fs, 35632)) ? (n.program = function (t, e, i, r) { var n = t.createProgram(); return t.attachShader(n, e), t.attachShader(n, i), t.linkProgram(n), t.getProgramParameter(n, 35714) ? r && (t.validateProgram(n), !t.getProgramParameter(n, 35715)) ? (console.error("Error validating program", t.getProgramInfoLog(n)), t.deleteProgram(n), null) : (t.detachShader(n, e), t.detachShader(n, i), t.deleteShader(i), t.deleteShader(e), n) : (console.error("Error creating shader program.", t.getProgramInfoLog(n)), t.deleteProgram(n), null) }(r, s, o, !0), r.useProgram(n.program), i(r, n), r.useProgram(null), n.compiled = !0, !0) : (r.deleteShader(s), !1)) } }(), r.parse_flat = function (t, i) { var r = t.split("/*--fragment--*/"), n = new e.webgl.shader(r[0].toString().trim(), r[1].toString().trim()); return n.source = t, n.params = i || {}, n }, r.parse_shader = function () { var t = ["vertex", "fragment"]; function i(e) { e = e.replace(/\\n/g, "\n"); var i = []; t.forEach(function (t) { i.push({ f: t, i: e.indexOf(t) }) }), i.sort(function (t, e) { return t.i - e.i }); var r = e.split(""); function n(t, i) { return e.substr(i, function (t) { for (var e = 1; 0 !== e && t < r.length;)"{" === r[t] ? e++ : "}" === r[t] && e--, t++; return t }(e.indexOf(t) + t.length) - i) } var a = 0, s = {}; return i.forEach(function (t) { var i = new RegExp("void " + t.f + "[\\s\\S]*?{", "ig"), r = e.match(i); null !== r && r.length > 0 && (s[t.f] = n(r[0], a), a += s[t.f].length) }), s } function r(t) { var e = {}, i = "", r = null; return function (t, e) { null !== t && t.forEach(e) }(t.match(/(\w+ +\w+ *\([^\)]*\) *\{)|(\w+ +\w+ +\w+ *\([^\)]*\) *\{)/g), function (t) { i = t.replace(/\s+/g, " ").substr(0, t.indexOf("(")).trim(), (r = { a: i.split(" "), d: t }).f = r.a[r.a.length - 1], e[i] = r }), e } return function (t, n, a) { a = a || {}; var s, o, _, l, u = new e.webgl.shader, h = null, c = "", d = "", m = null, p = "", f = ""; for (h in u.parts = i(t), u.level = 0, u.parts) u.parts[h] = u.parts[h].replace(/\r?\n\s+\{|\r\s+\{/g, "{").replace(/\s+\(/g, "("); if (n) { for (h in u.level = n.level + 1, u.parts) if (!1 !== a[h] && (c = u.parts[h], d = n.parts[h])) { for (m in s = r(c), o = r(d), s) o[m] && (_ = s[m], l = o[m], p = "super_" + _.f, u.level > 1 ? (f = m.replace(_.f, p), d = (d = d.replace(f + "(", f + u.level + "(")).replace(p + "(", p + u.level + "("), p = l.d.replace(l.f, "super_" + l.f), d = d.replace(l.d, p)) : (p = l.d.replace(l.f, "super_" + l.f), d = d.replace(l.d, p))); u.parts[h] = d + c } u.parts.vertex = u.parts.vertex || n.parts.vertex, u.parts.fragment = u.parts.fragment || n.parts.fragment } return u.vs = u.parts.vertex + "void main(){vertex();}", u.fs = u.parts.fragment + "void main(){fragment();}", u.parent = n || null, u } }(), r.parse = function (t) { return this.parse_shader(t, void 0, !0, !0) }, r }) }(_FM.fin, _FM.ge), function (t, e) { var i; t.shading = {}, i = t.webgl.shader.create_chunks_lib("/*chunk-flat-material*/\n\n<?=chunk('precision')?>\n\nattribute vec3 a_position_rw;\nattribute vec2 a_uv_rw;\nattribute vec4 a_color_rw;\nuniform mat4 u_view_projection_rw;\nuniform mat3 u_texture_matrix_rw;\nuniform mat4 u_model_rw;\nvarying vec2 v_uv_rw;\nvarying vec4 v_color_rw;\nvarying vec4 v_position_rw;\nvec4 att_position(void);\nvec3 att_uv(void);\n\nvec4 att_position(void){\n    return vec4(a_position_rw,1.0);\n}\nvec3 att_uv(void){\n    return vec3(a_uv_rw,1.0);\n}\n\nvoid vertex(void){\n    v_position_rw=u_model_rw*att_position();\n    gl_Position=u_view_projection_rw*v_position_rw;\n    v_uv_rw=(u_texture_matrix_rw*att_uv()).xy;\n    v_color_rw=a_color_rw;\n    gl_PointSize =10.0;\n}\n<?=chunk('precision')?>\n\nvarying vec2 v_uv_rw;\nvarying vec4 v_position_rw;\nvarying vec4 v_color_rw;\nuniform mat4 u_object_material_rw;\nuniform sampler2D u_texture_rw;\nvoid fragment(void) {\t\n\n    gl_FragColor = texture2D(u_texture_rw, v_uv_rw)*v_color_rw ;\n    gl_FragColor.rgb*=u_object_material_rw[0].rgb;    \n\tgl_FragColor.w*=u_object_material_rw[0].w;    \n\t\n    \n\n}\n\n\n/*chunk-shaded-material*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nattribute vec3 a_normal_rw;\nattribute vec2 a_uv_rw;\nattribute vec4 a_color_rw;\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\nuniform mat3 u_texture_matrix_rw;\n\nvarying vec2 v_uv_rw;\nvarying vec4 v_position_rw;\nvarying vec3 v_normal_rw;\nvarying vec4 v_color_rw;\n\nvec4 att_position(void);\nvec4 att_normal(void);\nvec3 att_uv(void);\n\nvec4 att_position(void){\n    return vec4(a_position_rw,1.0);\n}\nvec4 att_normal(void){\n    return vec4(a_normal_rw,0.0);\n}\n\nvec3 att_uv(void){\n    return vec3(a_uv_rw,1.0);\n}\n\nvoid vertex(){\t\n\tv_position_rw=u_model_rw*att_position();\n    gl_Position=u_view_projection_rw*v_position_rw;\n\tv_normal_rw=(u_model_rw*att_normal()).xyz;\t\n\tv_uv_rw=(u_texture_matrix_rw*att_uv()).xy;\n\n\tv_color_rw=a_color_rw;\n\t\t\n}\n\n<?=chunk('precision')?>\n\n<?=chunk('global-render-system-lighting')?>\n\nvarying vec2 v_uv_rw;\nvarying vec4 v_position_rw;\nvarying vec3 v_normal_rw;\nvarying vec4 v_color_rw;\n\nuniform mat4 u_object_material_rw;\nuniform sampler2D u_texture_rw;\nuniform vec4 u_eye_position_rw;\n\nvoid fragment(void) {\n\t\n\tvec3 total_light=get_render_system_lighting(\n\tu_object_material_rw,\n\tv_position_rw.xyz,\n\tnormalize(v_normal_rw),\n\tnormalize(u_eye_position_rw.xyz - v_position_rw.xyz));\n\t\n\t\n\n\tgl_FragColor = vec4(total_light, u_object_material_rw[0].w)* \n\ttexture2D(u_texture_rw, v_uv_rw)*v_color_rw;\t\n\tgl_FragColor.w*=u_object_material_rw[0].w;\n\t\n}\n\n"), t.shading.material = t.define(function (r, n) { function a(i) { i = i || {}, n.apply(this, [i]), this.uuid = t.guidi(), this.object_material = new Float32Array(16), this.ambient = new Float32Array(this.object_material.buffer, 0, 4), this.diffuse = new Float32Array(this.object_material.buffer, 16, 4), this.specular = new Float32Array(this.object_material.buffer, 32, 4), this.texture = i.texture || null, e.vec3.copy(this.ambient, i.ambient || [.5, .5, .5]), e.vec3.copy(this.diffuse, i.diffuse || [.5, .5, .5]), e.vec3.copy(this.specular, i.specular || [.863, .863, .863]), this.ambient[3] = 1, this.texture_matrix = i.texture_matrix || e.mat3(), i.set_texture_matrix && e.mat3.translate_rotate_scale(this.texture_matrix, i.set_texture_matrix[0], i.set_texture_matrix[1], i.set_texture_matrix[2], i.set_texture_matrix[3], i.set_texture_matrix[4]), this.instances_count = -1, this.wireframe = i.wireframe || !1, this.flags = 2, void 0 !== i.flags && (this.flags += i.flags), this.shader = i.shader || t.shading.material.shader, this.draw_type = 4, void 0 !== i.draw_type && (this.draw_type = i.draw_type), i.always_display && (this.flags += 2), this.on_before_render = new t.event(this), this.on_after_render = new t.event(this), this.draw_elements = !1, this.transparent_layer = i.transparent_layer || 0, void 0 !== i.transparent && this.set_tansparency(i.transparent), this.cull_face = i.cull_face || 1029, i.both_sides && (this.flags += 2048) } var s; return a.shader = t.webgl.shader.parse(i["flat-material"]), r.set_tansparency = function (t) { return this.ambient[3] = Math.min(t, 1), t < 1 ? this.set_flag(128) : this.unset_flag(128), this }, r.set_shinness = function (t) { return this.specular[3] = t, this }, r.set_ambient = function (t, e, i) { return this.ambient[0] = t, this.ambient[1] = e, this.ambient[2] = i, this }, r.set_diffuse = function (t, e, i) { return this.diffuse[0] = t, this.diffuse[1] = e, this.diffuse[2] = i, this }, r.render_mesh = (s = [null, null, null], r.complete_render_mesh = function (t, e, i) { this.instances_count > -1 ? this.instances_count > 0 && (this.draw_elements ? t.gl.ANGLE_instanced_arrays.drawElementsInstancedANGLE(this.final_draw_type, this.final_draw_count, 5125, 4 * this.final_draw_offset, this.instances_count) : t.gl.ANGLE_instanced_arrays.drawArraysInstancedANGLE(this.final_draw_type, this.final_draw_offset, this.final_draw_count, this.instances_count)) : this.draw_elements ? t.gl.drawElements(this.final_draw_type, this.final_draw_count, 5125, 4 * this.final_draw_offset) : t.gl.drawArrays(this.final_draw_type, this.final_draw_offset, this.final_draw_count) }, function (t, e, i) { var r; s[0] = t, s[1] = e, s[2] = i, 1024 & this.flags ? t.gl_disable(2929) : t.gl_enable(2929), 0 != (2048 & this.flags) ? t.gl_disable(2884) : t.gl_enable(2884), (r = e.uniforms.u_object_material_rw) && (r.params[r.params_length] = this.object_material, r.func.apply(e.gl, r.params)), (r = e.uniforms.u_texture_matrix_rw) && (r.params[r.params_length] = this.texture_matrix, r.func.apply(e.gl, r.params)), t.use_texture(this.texture, 0), this.final_draw_type = this.wireframe ? 1 : this.draw_type, this.final_draw_count = i.draw_count || i.geometry.num_items, this.final_draw_offset = i.draw_offset || 0, this.draw_elements = t.activate_geometry_index_buffer(i.geometry, this.wireframe), this.wireframe && (this.final_draw_count *= 2, this.final_draw_offset *= 2), this.on_before_render.trigger(s), this.complete_render_mesh(t, e, i), this.on_after_render.trigger(s) }), a }, t.flags_setting), t.shading.shaded_material = t.define(function (e, r) { function n(e) { return e = e || {}, r.apply(this, [e]), this.shader = t.shading.shaded_material.shader, this.flags = 4, this.light_pass_limit = 1e4, this.lights_count = -1, this.set_shinness(e.shinness || 100), void 0 !== e.transparent && this.set_tansparency(e.transparent), e.cast_shadows && (this.flags += 16), e.receive_shadows && (this.flags += 32), void 0 !== e.flags && this.set_flag(e.flags), e.both_sides && (this.flags += 2048), this } return n.shader = t.webgl.shader.parse(i["shaded-material"]), n }, t.shading.material), t.shading.light = t.define(function (t, i) { return t.update_bounds = function (t, e) { if (this.light_type > -1) { var i = .5 * this.range, r = this.world_position; this.bounds[0] = r[0], this.bounds[1] = r[1], this.bounds[2] = r[2], this.bounds[3] = r[0], this.bounds[4] = r[1], this.bounds[5] = r[2], minx = r[0] - i, miny = r[1] - i, minz = r[2] - i, maxx = r[0] + i, maxy = r[1] + i, maxz = r[2] + i, this.expand_bounds(minx, miny, minz), this.expand_bounds(minx, miny, maxz), this.expand_bounds(minx, maxy, minz), this.expand_bounds(minx, maxy, maxz), this.expand_bounds(maxx, miny, minz), this.expand_bounds(maxx, miny, maxz), this.expand_bounds(maxx, maxy, minz), this.expand_bounds(maxx, maxy, maxz) } }, t.set_intensity = function (t) { return this.ambient[3] = t, this }, t.set_ambient = function (t, i, r) { return e.vec3.set(this.ambient, t, i, r), this }, t.set_diffuse = function (t, i, r) { return e.vec3.set(this.diffuse, t, i, r), this }, t.set_specular = function (t, i, r) { return e.vec3.set(this.specular, t, i, r), this }, t.enable_shadows = function (t) { return t = t || {}, this.cast_shadows = !0, this.shadow_bias = t.shadow_bias || 1e-8, this.shadow_intensity = t.shadow_intensity || this.shadow_intensity, this.shadow_map_size = t.shadow_map_size || 1024, this.shadow_camera_distance = t.shadow_camera_distance || 30, this }, function (t) { t = t || {}, i.apply(this, [t]), this.light_material = new Float32Array(16), this.ambient = new Float32Array(this.light_material.buffer, 0, 4), this.diffuse = new Float32Array(this.light_material.buffer, 16, 4), this.specular = new Float32Array(this.light_material.buffer, 32, 4), this.attenuation = new Float32Array(this.light_material.buffer, 48, 4), this.diffuse[3] = -1, this.specular[3] = -1, this.range = 2e4, this.light_type = 0, this.enabled = !0, this.item_type = 8, this.view_angle = Math.PI, this.flags = 2, this.version = 0, e.vec3.copy(this.ambient, t.ambient || [.1, .1, .1]), e.vec3.copy(this.diffuse, t.diffuse || [.87, .87, .87]), e.vec3.copy(this.specular, t.specular || [.85, .85, .85]), e.vec4.copy(this.attenuation, t.attenuation || [0, 0, 0, 0]), this.ambient[3] = t.intensity || 1, this.diffuse[3] = -1, this.specular[3] = -1, this.cast_shadows = t.cast_shadows || !1, this.shadow_bias = t.shadow_bias || 1e-8, this.shadow_intensity = t.shadow_intensity || .25, this.shadow_map_size = t.shadow_map_size || 1024, this.shadow_camera_distance = t.shadow_camera_distance || 30 } }, t.renderable), t.shading.point_light = t.define(function (t, i) { var r, n, a, s, o; return t.set_attenuation_by_distance = (o = [[7, 1, .7, 1.8], [13, 1, .35, .44], [20, 1, .22, .2], [32, 1, .14, .07], [50, 1, .09, .032], [65, 1, .07, .017], [100, 1, .045, .0075], [160, 1, .027, .0028], [200, 1, .022, .0019], [325, 1, .014, 7e-4], [600, 1, .007, 2e-4], [3250, 1, .0014, 7e-6]], function (t) { for (a = 0; a < o.length; a++)if (t < o[a][0]) { n = a; break } return 0 === n ? this.set_attenuation.apply(this, o[0]) : (r = n - 1, s = o[n][0] - o[r][0], s = (t - o[r][0]) / s, this.attenuation[0] = o[r][1] + (o[n][1] - o[r][1]) * s, this.attenuation[1] = o[r][2] + (o[n][2] - o[r][2]) * s, this.attenuation[2] = o[r][3] + (o[n][3] - o[r][3]) * s, this) }), t.set_attenuation = function (t, i, r) { return e.vec3.set(this.attenuation, t, i, r), this }, function (t) { t = t || {}, i.apply(this, [t]), this.flags = 0, this.shadow_intensity = .9, this.range = t.range || 20, t.attenuation ? this.set_attenuation(this.attenuation[0], this.attenuation[1], this.attenuation[2]) : this.set_attenuation_by_distance(2 * this.range), this.specular[3] = 0, this.diffuse[3] = 0, this.light_type = 1 } }, t.shading.light), t.shading.spot_light = t.define(function (t, e) { return t.set_outer_angle = function (t) { return this.view_angle = t, this.diffuse[3] = Math.cos(t / 2), this }, t.set_inner_angle = function (t) { return this.specular[3] = Math.cos(t / 2), this }, function (t) { t = t || {}, e.apply(this, [t]), this.range = t.range || 10, t.attenuation ? this.set_attenuation(this.attenuation[0], this.attenuation[1], this.attenuation[2]) : this.set_attenuation_by_distance(2 * this.range), this.set_outer_angle(t.outer || .8726646259971648).set_inner_angle(t.inner || .8726646259971648), this.light_type = 2 } }, t.shading.point_light) }(_FM.ge, _FM.math), function (t, e, i, r) { i.register_component("ge_transform", t.define(function (t, e) { t.set_position = function (t, e, i) { return r.vec3.set(this.position, t, e, i), this.require_update = 1, this }, t.set_rotation = function (t, e, i, n) { return r.vec4.set(this.rotation, t, e, i, n), this.require_update = 1, this }, t.set_scale = function (t, e, i) { return r.vec3.set(this.scale, t, e, i), this.require_update = 1, this }, t.rotate_eular = function (t, e, i) { return r.quat.rotate_eular(this.rotation, t, e, i), this.require_update = 1, this }; var i = r.vec3(), n = r.quat(); function a(t, e, i, n) { this.entity = e, this.position = r.vec3(t.position), this.scale = r.vec3(t.scale || [1, 1, 1]), this.rotation = r.quat(t.rotation), this.position_world = r.vec3(), this.scale_world = r.vec3(), this.rotation_world = r.quat(), this.animation_data = void 0, this.require_update = 1, this.parent = void 0, this.flags = 0, this.version = 0 } return t.drage_to_direction = function (t, e) { return r.vec3.scale(i, t, e), r.quat.invert(n, this.rotation_world), r.vec3.transform_quat(i, i, n), r.vec3.add(this.position, this.position, i), this.require_update = 1, this }, a.validate = function (t) { t.app.use_system("ge_transform_system") }, a }, i.component)), i.register_component("ge_transform_controller", t.define(function (t, e) { function i(t, i, n, a) { this.entity = i, e.apply(this, arguments), this.rotate = r.vec3(0, 0, 0), this.matrix_world = r.mat4(), this.up_vector = new Float32Array(this.matrix_world.buffer, 16, 3), this.fw_vector = new Float32Array(this.matrix_world.buffer, 32, 3), this.sd_vector = new Float32Array(this.matrix_world.buffer, 0, 3), this.transform = i.ge_transform, t.rotate && r.vec3.copy(this.rotate, t.rotate), this.rotate_eular(this.rotate[0], this.rotate[1], this.rotate[2]), t.position && this.set_position(t.position[0], t.position[1], t.position[2]) } return t.rotate_eular = function (t, e, i) { return r.quat.rotate_eular(this.transform.rotation, t, e, i), this.transform.require_update = 1, this }, t.yaw_pitch = function (t, e) { return this.rotate[0] += t, this.rotate[1] += e, r.quat.rotate_eular(this.transform.rotation, this.rotate[0], this.rotate[1], this.rotate[2]), this.transform.require_update = 1, this }, t.set_rotate = function (t, e, i) { return this.rotate[0] = t, this.rotate[1] = e, this.rotate[2] = i, r.quat.rotate_eular(this.transform.rotation, this.rotate[0], this.rotate[1], this.rotate[2]), this.transform.require_update = 1, this }, t.set_position = function (t, e, i) { return this.transform.position[0] = t, this.transform.position[1] = e, this.transform.position[2] = i, this.transform.require_update = 1, this }, t.set_position_x = function (t) { return this.transform.position[0] = t, this.transform.require_update = 1, this }, t.set_position_y = function (t) { return this.transform.position[1] = t, this.transform.require_update = 1, this }, t.set_position_z = function (t) { return this.transform.position[2] = t, this.transform.require_update = 1, this }, t.set_position_x_inc = function (t) { return this.transform.position[0] += t, this.transform.require_update = 1, this }, t.set_position_y_inc = function (t) { return this.transform.position[1] += t, this.transform.require_update = 1, this }, t.set_position_z_inc = function (t) { return this.transform.position[2] += t, this.transform.require_update = 1, this }, t.move_front_back = function (t) { return this.transform.position[0] += this.fw_vector[0] * t, this.transform.position[1] += this.fw_vector[1] * t, this.transform.position[2] += this.fw_vector[2] * t, this.transform.require_update = 1, this }, t.move_forward_xz = function (t) { return this.transform.position[0] += this.fw_vector[0] * t, this.transform.position[2] += this.fw_vector[2] * t, this.transform.require_update = 1, this }, t.move_forward_xy = function (t) { return this.transform.position[0] += this.fw_vector[0] * t, this.transform.position[1] += this.fw_vector[1] * t, this.transform.require_update = 1, this }, t.move_left_right = function (t) { return this.transform.position[0] += this.sd_vector[0] * t, this.transform.position[1] += this.sd_vector[1] * t, this.transform.position[2] += this.sd_vector[2] * t, this.transform.require_update = 1, this }, t.move_up_down = function (t) { return this.transform.position[0] += this.up_vector[0] * t, this.transform.position[1] += this.up_vector[1] * t, this.transform.position[2] += this.up_vector[2] * t, this.transform.require_update = 1, this }, i.validate = function (t) { t.app.use_system("ge_transform_system") }, i }, i.component)), i.register_system("ge_transform_system", t.define(function (t, i) { var n = 0, a = null, s = null, o = r.vec3(), _ = r.quat(), l = null, u = null, h = null; t.step = function () { for (this.transforms.length = 0, n = 0; null !== (s = this.app.iterate_entities("ge_transform"));)a = s.ge_transform, this.transforms[n++] = a, a.flags; for (this.process(this.transforms, 1); null !== (s = this.app.iterate_entities("ge_transform_controller"));)a = s.ge_transform_controller, this.transforms[n++] = a, 0 !== a.transform.require_update && (r.mat4.from_quat(a.matrix_world, a.transform.rotation_world), r.mat4.scale(a.matrix_world, a.transform.scale_world), a.matrix_world[12] = a.transform.position_world[0], a.matrix_world[13] = a.transform.position_world[1], a.matrix_world[14] = a.transform.position_world[2]) }, t.step_end = function () { for (n = 0; n < this.transforms.length; n++)(a = this.transforms[n]).require_update < 0 ? a.require_update = Math.abs(a.require_update) : a.require_update = 0 }, e.create_animation_data = function () { var t = new Float32Array(10); return { data: t, position: new Float32Array(t.buffer, 0, 3), scale: new Float32Array(t.buffer, 12, 3), rotation: new Float32Array(t.buffer, 24, 4) } }; var c, d, m, p, f, g, v, w, x, y, b, E, T, A, z, M, L, I, k, S, R, F, N, C, G, P, j, O = e.create_animation_data(); return t.process = function (t, e) { for (n = 0; n < t.length; n++)a = t[n], l = a.scale, h = a.position, u = a.rotation, a.animation_data ? ((c = a.animation_data).position && (O.position[0] = a.position[0] + c.position[0], O.position[1] = a.position[1] + c.position[1], O.position[2] = a.position[2] + c.position[2], h = O.position), c.scale && (O.scale[0] = a.scale[0] + c.scale[0], O.scale[1] = a.scale[1] + c.scale[1], O.scale[2] = a.scale[2] + c.scale[2], l = O.scale), c.rotation ? (y = O.rotation, b = a.rotation, E = c.rotation, d = b[0], m = b[1], p = b[2], f = b[3], g = E[0], v = E[1], w = E[2], x = E[3], y[0] = d * x + f * g + m * w - p * v, y[1] = m * x + f * v + p * g - d * w, y[2] = p * x + f * w + d * v - m * g, y[3] = f * x - d * g - m * v - p * w, u = O.rotation) : c.eular && (y = _, d = Math.sin(.5 * c.eular[0]), m = Math.sin(.5 * c.eular[1]), p = Math.sin(.5 * c.eular[2]), g = Math.cos(.5 * c.eular[0]), v = Math.cos(.5 * c.eular[1]), w = Math.cos(.5 * c.eular[2]), y[0] = d * v * w - g * m * p, y[1] = g * m * w + d * v * p, y[2] = g * v * p - d * m * w, y[3] = g * v * w + d * m * p, d = y[0], m = y[1], p = y[2], f = y[3], (T = d * d + m * m + p * p + f * f) > 0 && (T = 1 / Math.sqrt(T)), y[0] = d * T, y[1] = m * T, y[2] = p * T, y[3] = f * T, y = O.rotation, b = a.rotation, E = _, d = b[0], m = b[1], p = b[2], f = b[3], g = E[0], v = E[1], w = E[2], x = E[3], y[0] = d * x + f * g + m * w - p * v, y[1] = m * x + f * v + p * g - d * w, y[2] = p * x + f * w + d * v - m * g, y[3] = f * x - d * g - m * v - p * w, u = O.rotation), a.require_update = 1) : a.animation_data_absolute && ((c = a.animation_data_absolute).position && (h = c.position), c.scale && (l = c.scale), c.rotation ? u = c.rotation : c.eular && (y = O.rotation, d = Math.sin(.5 * c.eular[0]), m = Math.sin(.5 * c.eular[1]), p = Math.sin(.5 * c.eular[2]), g = Math.cos(.5 * c.eular[0]), v = Math.cos(.5 * c.eular[1]), w = Math.cos(.5 * c.eular[2]), y[0] = d * v * w - g * m * p, y[1] = g * m * w + d * v * p, y[2] = g * v * p - d * m * w, y[3] = g * v * w + d * m * p, d = y[0], m = y[1], p = y[2], f = y[3], (T = d * d + m * m + p * p + f * f) > 0 && (T = 1 / Math.sqrt(T)), y[0] = d * T, y[1] = m * T, y[2] = p * T, y[3] = f * T, u = O.rotation), a.require_update = 1), void 0 !== a.parent ? (a.parent.require_update !== e && 100 !== a.parent.require_update || (a.require_update = e), a.require_update === e && (y = a.rotation_world, b = a.parent.rotation_world, E = u, d = b[0], m = b[1], p = b[2], f = b[3], g = E[0], v = E[1], w = E[2], x = E[3], y[0] = d * x + f * g + m * w - p * v, y[1] = m * x + f * v + p * g - d * w, y[2] = p * x + f * w + d * v - m * g, y[3] = f * x - d * g - m * v - p * w, a.scale_world[0] = a.parent.scale_world[0] * l[0], a.scale_world[1] = a.parent.scale_world[1] * l[1], a.scale_world[2] = a.parent.scale_world[2] * l[2], 2 & a.flags ? (o[0] = h[0] * a.parent.scale_world[0], o[1] = h[1] * a.parent.scale_world[1], o[2] = h[2] * a.parent.scale_world[2], A = o[0], z = o[1], M = o[2], L = a.parent.rotation_world[0], I = a.parent.rotation_world[1], k = a.parent.rotation_world[2], S = a.parent.rotation_world[3], G = I * (C = L * z - I * A) - k * (N = k * A - L * M), P = k * (F = I * M - k * z) - L * C, j = L * N - I * F, F *= R = 2 * S, N *= R, C *= R, G *= 2, P *= 2, j *= 2, o[0] = A + F + G, o[1] = z + N + P, o[2] = M + C + j) : (A = h[0], z = h[1], M = h[2], L = a.parent.rotation_world[0], I = a.parent.rotation_world[1], k = a.parent.rotation_world[2], S = a.parent.rotation_world[3], G = I * (C = L * z - I * A) - k * (N = k * A - L * M), P = k * (F = I * M - k * z) - L * C, j = L * N - I * F, F *= R = 2 * S, N *= R, C *= R, G *= 2, P *= 2, j *= 2, o[0] = A + F + G, o[1] = z + N + P, o[2] = M + C + j), a.position_world[0] = o[0] + a.parent.position_world[0], a.position_world[1] = o[1] + a.parent.position_world[1], a.position_world[2] = o[2] + a.parent.position_world[2], a.version = (1 + (0 | a.version)) % 99999)) : a.require_update === e && (a.scale_world[0] = l[0], a.scale_world[1] = l[1], a.scale_world[2] = l[2], a.position_world[0] = h[0], a.position_world[1] = h[1], a.position_world[2] = h[2], a.rotation_world[0] = u[0], a.rotation_world[1] = u[1], a.rotation_world[2] = u[2], a.rotation_world[3] = u[3], a.version = (1 + (0 | a.version)) % 99999) }, function () { i.apply(this, arguments), this.transforms = [], this.priority = 100 } }, i.system)) }(_FM.fin, _FM.ge, _FM.ecs, _FM.math), ge = _FM.ge, ecs = _FM.ecs, math = _FM.math, ecs.register_component("ge_camera", ge.define(function (t, e) { t.update_aspect = function (t) { this.aspect = t, this.update_view_projection = 1 }, t.set_projection = function (t) { this.projection = t, math.mat4.multiply(this.view_projection, t, this.view_inverse) }; var i, r, n, a = 0; function s(t, i, r, n) { e.apply(this, arguments), this.view = math.mat4(), this.view_inverse = math.mat4(), this.projection = math.mat4(), this.projection_inverse = math.mat4(), this.view_projection = math.mat4(), this.view_projection_inverse = math.mat4(), this.freez_projection = !1, this.version = 0, this.up_vector = new Float32Array(this.view.buffer, 16, 3), this.fw_vector = new Float32Array(this.view.buffer, 32, 3), this.sd_vector = new Float32Array(this.view.buffer, 0, 3), this.frustum_plans = [math.vec4(), math.vec4(), math.vec4(), math.vec4(), math.vec4(), math.vec4()], this.world_position = new Float32Array(this.view.buffer, 48, 3), this.bounds = math.aabb(), this._bounds = math.aabb(), this.is_locked = !1, this.entity = i, this.update_view_projection = !0, this.type = t.type || "perspective", "perspective" === this.type ? (this.fov = .017453292519943295 * (void 0 !== t.fov ? t.fov : 60), this.near = void 0 !== t.near ? t.near : .1, this.far = void 0 !== t.far ? t.far : 2e4, this.aspect = void 0 !== t.aspect ? t.aspect : 1) : (this.left = t.left || -.5, this.right = t.right || .5, this.bottom = t.bottom || -.5, this.top = t.top || .5, this.near = t.near || .1, this.far = t.far || 20, this.aspect = Math.abs((this.right - this.left) / (this.top - this.bottom))), this.vp_left = 0, this.vp_top = 0, this.vp_width = 1, this.vp_height = 1, this.drag_direction = math.vec3(), this.last_drag_direction = math.vec3(), this.version = 0, this.update_view_projection = 1 } return t.update_frustum_plane = function (t, e, i, r, n) { a = e * e + i * i + r * r + n * n, a = 1 / Math.sqrt(a), this.frustum_plans[t][0] = e * a, this.frustum_plans[t][1] = i * a, this.frustum_plans[t][2] = r * a, this.frustum_plans[t][3] = n * a }, t.calc_bounds = function () { var t, e, i, r, n, a; function s(s, o, _) { t = Math.min(t, s), e = Math.min(e, o), i = Math.min(i, _), r = Math.max(r, s), n = Math.max(n, o), a = Math.max(a, _) } return function () { var o = Math.tan(this.fov / 2) * this.aspect, _ = o * this.near, l = o * this.far, u = o * this.near, h = o * this.far; t = 99999, e = 99999, i = 99999, r = -99999, n = -99999, a = -99999, s(-_, -u, this.near), s(_, -u, this.near), s(_, u, this.near), s(-_, u, this.near), s(-l, -h, -this.far), s(l, -h, -this.far), s(l, h, -this.far), s(-l, h, -this.far), this._bounds[0] = t, this._bounds[1] = e, this._bounds[2] = i, this._bounds[3] = r, this._bounds[4] = n, this._bounds[5] = a } }(), t.update_frustum = function (t) { math.aabb.transform_mat4(this.bounds, this._bounds, this.view), this.update_frustum_plane(0, t[3] - t[0], t[7] - t[4], t[11] - t[8], t[15] - t[12]), this.update_frustum_plane(1, t[3] + t[0], t[7] + t[4], t[11] + t[8], t[15] + t[12]), this.update_frustum_plane(2, t[3] + t[1], t[7] + t[5], t[11] + t[9], t[15] + t[13]), this.update_frustum_plane(3, t[3] - t[1], t[7] - t[5], t[11] - t[9], t[15] - t[13]), this.update_frustum_plane(4, t[3] - t[2], t[7] - t[6], t[11] - t[10], t[15] - t[14]), this.update_frustum_plane(5, t[3] + t[2], t[7] + t[6], t[11] + t[10], t[15] + t[14]) }, t.frustum_aabb = (t._frustum_aabb = function (t, e, i, r, n, a) { var s, o = 0; for (o = 0; o < 6; o++)if (s = this.frustum_plans[o], Math.max(t * s[0], r * s[0]) + Math.max(e * s[1], n * s[1]) + Math.max(i * s[2], a * s[2]) + s[3] < 0) return !1; return !0 }, function (t) { return this._frustum_aabb(t[0], t[1], t[2], t[3], t[4], t[5]) }), t.aabb_aabb = function (t) { return (i = this.bounds)[0] <= t[3] && i[3] >= t[0] && i[1] <= t[4] && i[4] >= t[1] && i[2] <= t[5] && i[5] >= t[2] }, t.get_mouse_ray_pos = (r = math.vec4(), n = math.vec3(), t.set_drag_direction = function (t, e, i, a) { return r[0] = t / i * 2 - 1, r[1] = -e / a * 2 + 1, r[2] = -1, math.vec3.transform_mat4(n, r, this.view_projection_inverse), r[2] = 1, math.vec3.transform_mat4(r, r, this.view_projection_inverse), math.vec3.subtract(this.drag_direction, r, this.last_drag_direction), math.vec3.normalize(this.drag_direction, this.drag_direction), math.vec3.copy(this.last_drag_direction, r), this.drag_direction }, function (t, e, i, a, s) { return r[0] = e / a * 2 - 1, r[1] = -i / s * 2 + 1, r[2] = -1, math.vec3.transform_mat4(n, r, this.view_projection_inverse), r[2] = 1, math.vec3.transform_mat4(t, r, this.view_projection_inverse), t }), t.set_freez_projection = function (t) { math.mat4.copy(this.projection, t), this.freez_projection = !0, this.update_view_projection = 1 }, s.validate = function (t) { t.app.use_system("ge_camera_system") }, s }, ecs.component)), ecs.register_component("ge_mouse_camera_controller", fin.define(function (t, e) { function i(t, e, i, r) { this.entity = e, console.log(e), this.element = t.element, this.wheel_delta = t.wheel_delta || .25, this.set_mouse_input(this.element), this.mouse_camera_ray_pos = math.vec3(), this.mouse_camera_ray = math.vec3(), this.on_mouse_down = new ge.event(this, [0, 0, null]), this.on_mouse_up = new ge.event(this, [0, 0, null]), this.on_mouse_drage = new ge.event(this, [0, 0, null]), this.on_mouse_wheel = new ge.event(this, [0, null]), this.mouse_ray_start = math.vec3(), this.mouse_ray_end = math.vec3(), this.suspended = !1, t.on_mouse_down && this.on_mouse_down.add(t.on_mouse_down), t.on_mouse_up && this.on_mouse_up.add(t.on_mouse_up), t.on_mouse_drage && this.on_mouse_drage.add(t.on_mouse_drage), t.on_mouse_wheel && this.on_mouse_wheel.add(t.on_mouse_wheel) } return t.mouse_wheel = function (t, e) { this.on_mouse_wheel.params[0] = t, this.on_mouse_wheel.params[1] = e, !1 !== this.on_mouse_wheel.trigger_params() && (this.entity.ge_camera.is_locked || this.entity.ge_transform_controller.move_front_back(-this.wheel_delta * t)) }, t.get_mouse_camera_pos = function (t) { this.entity.ge_camera.get_mouse_ray_pos(t, this.mouse_x, this.mouse_y, this.elm_rect.width, this.elm_rect.height) }, t.mouse_drage = function (t, e, i) { this.entity.ge_camera.set_drag_direction(this.mouse_x, this.mouse_y, this.elm_rect.width, this.elm_rect.height), this.on_mouse_drage.params[0] = t, this.on_mouse_drage.params[1] = e, this.on_mouse_drage.params[2] = i, !1 !== this.on_mouse_drage.trigger_params() && (this.entity.ge_camera.is_locked || this.entity.ge_transform_controller.yaw_pitch(.005 * -e, .005 * -t)) }, t.mouse_click = t.mouse_move = function (t, e, i) { }, t.mouse_move2 = function (t, e, i) { this.entity.ge_camera.get_mouse_ray_pos(this.mouse_camera_ray_pos, this.mouse_x, this.mouse_y, this.elm_rect.width, this.elm_rect.height), math.vec3.subtract(this.mouse_camera_ray, this.mouse_camera_ray_pos, this.entity.ge_camera.world_position), math.vec3.normalize(this.mouse_camera_ray, this.mouse_camera_ray) }, t.mouse_down = function (t, e, i) { this.on_mouse_down.params[0] = t, this.on_mouse_down.params[1] = e, this.on_mouse_down.params[2] = i, this.on_mouse_down.trigger_params() }, t.mouse_up = function (t, e, i) { this.on_mouse_up.params[0] = t, this.on_mouse_up.params[1] = e, this.on_mouse_up.params[2] = i, this.on_mouse_up.trigger_params() }, t.mouse_drage2 = function (t, e, i) { }, t.set_mouse_input = function (t) { var e = this; this.elm_rect = t.getBoundingClientRect(), t.addEventListener(/Firefox/i.test(navigator.userAgent) ? "DOMMouseScroll" : "mousewheel", function (t) { e.mouse_wheel(t.detail ? -120 * t.detail : t.wheelDelta, t) }, !1); var i = 0, r = 0, n = null; t.addEventListener("mousedown", function (a) { this.elm_rect = t.getBoundingClientRect(), n = this.elm_rect, i = a.clientX - n.left, r = a.clientY - n.top, e.elm_width = n.right - n.left, e.elm_height = n.bottom - n.top, e.mouse_buttons = a.buttons, e.mouse_down_x = i, e.mouse_down_y = r, e.mouse_down(e.mouse_down_x, e.mouse_down_y, a), e.mouse_delta = 1, e.mouse_is_down = !0, e.mouse_is_up = !1 }), t.addEventListener("click", function (t) { e.mouse_click(e.mouse_x, e.mouse_y, t) }), t.addEventListener("mouseup", function (t) { e.mouse_buttons = 0, e.mouse_is_up = !0, e.mouse_is_down = !1, e.mouse_up(e.mouse_x, e.mouse_y, t) }), t.addEventListener("mousemove", function (a) { n = t.getBoundingClientRect(), i = a.clientX - n.left, r = a.clientY - n.top, e.elm_width = n.right - n.left, e.elm_height = n.bottom - n.top, e.mouse_buttons = a.buttons, e.mouse_x = i, e.mouse_y = r, e.mouse_draging = !1, e.mouse_move(e.mouse_x, e.mouse_y, a), 1 == a.buttons && (e.mouse_down_x = e.mouse_down_x || i, e.mouse_down_y = e.mouse_down_y || r, e.mouse_dx = i - e.mouse_down_x, e.mouse_dy = r - e.mouse_down_y, e.mouse_drage(e.mouse_dx, e.mouse_dy, a), e.mouse_down_x = i, e.mouse_down_y = r, e.mouse_draging = !0) }) }, t.set_mouse_ray = function () { math.vec3.copy(this.mouse_ray_start, this.entity.ge_camera.world_position), this.entity.ge_camera.get_mouse_ray_pos(this.mouse_ray_end, this.mouse_x, this.mouse_y, this.elm_rect.width, this.elm_rect.height) }, i.validate = function (t) { t.app.use_system("ge_camera_system"), t.app.use_system("ge_render_system") }, i }, ecs.component)), ecs.register_component("ge_keyboard_camera_controller", fin.define(function (t, e) { function i(t, e, i, r) { this.entity = e, console.log(e), this.element = t.element, this.front_back_delta = t.front_back_delta || 1, this.shift_key = !1, this.set_keyboard_input(this.element), this.key_down = !1, this.on_key_down = t.on_key_down } return t.set_keyboard_input = function (t) { var e = this; e.keys = [], t.addEventListener("keydown", function (t) { e.keys[t.keyCode] = !0, e.shift_key = t.shiftKey, e.key_down = !0 }), t.addEventListener("keyup", function (t) { e.keys[t.keyCode] = !1, e.shift_key = t.shiftKey, e.key_down = !1 }) }, t.update = function () { this.keys[87] && (this.shift_key ? this.entity.ge_transform_controller.move_front_back(4 * -this.front_back_delta) : this.entity.ge_transform_controller.move_front_back(-this.front_back_delta), this.entity.ge_transform.require_update = -1), this.keys[83] && (this.shift_key ? this.entity.ge_transform_controller.move_front_back(4 * this.front_back_delta) : this.entity.ge_transform_controller.move_front_back(this.front_back_delta), this.entity.ge_transform.require_update = -1), this.key_down && this.on_key_down && this.on_key_down(this.keys) }, i.validate = function (t) { t.app.use_system("ge_camera_system"), t.app.use_system("ge_render_system") }, i }, ecs.component)), ecs.register_system("ge_camera_system", ge.define(function (t, e) { var i, r, n, a, s, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y, b, E, T, A, z, M, L, I, k, S, R, F, N, C, G, P, j = null, O = null, D = null; return t.step = function () { for (; null !== (D = this.app.iterate_entities("ge_keyboard_camera_controller"));)D.ge_keyboard_camera_controller.update(); for (; null !== (D = this.app.iterate_entities("ge_camera"));)O = D.ge_camera, j = D.ge_transform, 1 === O.update_view_projection && (O.freez_projection || ("perspective" === O.type ? math.mat4.perspective(O.projection, O.fov, O.aspect, O.near, O.far) : math.mat4.ortho(O.projection, O.left, O.right, O.bottom, O.top, O.near, O.far)), S = O.projection_inverse, R = O.projection, i = R[0], r = R[1], n = R[2], a = R[3], s = R[4], o = R[5], _ = R[6], l = R[7], u = R[8], h = R[9], c = R[10], d = R[11], m = R[12], p = R[13], f = R[14], g = R[15], (v = (w = i * o - r * s) * (k = c * g - d * f) - (x = i * _ - n * s) * (I = h * g - d * p) + (y = i * l - a * s) * (L = h * f - c * p) + (b = r * _ - n * o) * (M = u * g - d * m) - (E = r * l - a * o) * (z = u * f - c * m) + (T = n * l - a * _) * (A = u * p - h * m)) && (v = 1 / v, S[0] = (o * k - _ * I + l * L) * v, S[1] = (n * I - r * k - a * L) * v, S[2] = (p * T - f * E + g * b) * v, S[3] = (c * E - h * T - d * b) * v, S[4] = (_ * M - s * k - l * z) * v, S[5] = (i * k - n * M + a * z) * v, S[6] = (f * y - m * T - g * x) * v, S[7] = (u * T - c * y + d * x) * v, S[8] = (s * I - o * M + l * A) * v, S[9] = (r * M - i * I - a * A) * v, S[10] = (m * E - p * y + g * w) * v, S[11] = (h * y - u * E - d * w) * v, S[12] = (o * z - s * L - _ * A) * v, S[13] = (i * L - r * z + n * A) * v, S[14] = (p * x - m * b - f * w) * v, S[15] = (u * b - h * x + c * w) * v)), 0 !== j.require_update && (O.version = (1 + (0 | O.version)) % 99999, S = O.view, G = j.rotation_world, i = G[0], r = G[1], n = G[2], a = G[3], w = i * (F = i + i), x = i * (N = r + r), y = i * (C = n + n), b = r * N, E = r * C, T = n * C, A = a * F, z = a * N, M = a * C, S[0] = 1 - (b + T), S[1] = x + M, S[2] = y - z, S[3] = 0, S[4] = x - M, S[5] = 1 - (w + T), S[6] = E + A, S[7] = 0, S[8] = y + z, S[9] = E - A, S[10] = 1 - (w + b), S[11] = 0, S = O.view, G = j.scale_world, S[0] *= G[0], S[1] *= G[0], S[2] *= G[0], S[3] *= G[0], S[4] *= G[1], S[5] *= G[1], S[6] *= G[1], S[7] *= G[1], S[8] *= G[2], S[9] *= G[2], S[10] *= G[2], S[11] *= G[2], O.view[12] = j.position_world[0], O.view[13] = j.position_world[1], O.view[14] = j.position_world[2], O.update_view_projection = 1), 1 === O.update_view_projection && (O.version = (1 + (0 | O.version)) % 99999, O.update_view_projection = 0, S = O.view_inverse, R = O.view, i = R[0], r = R[1], n = R[2], a = R[3], s = R[4], o = R[5], _ = R[6], l = R[7], u = R[8], h = R[9], c = R[10], d = R[11], m = R[12], p = R[13], f = R[14], g = R[15], (v = (w = i * o - r * s) * (k = c * g - d * f) - (x = i * _ - n * s) * (I = h * g - d * p) + (y = i * l - a * s) * (L = h * f - c * p) + (b = r * _ - n * o) * (M = u * g - d * m) - (E = r * l - a * o) * (z = u * f - c * m) + (T = n * l - a * _) * (A = u * p - h * m)) && (v = 1 / v, S[0] = (o * k - _ * I + l * L) * v, S[1] = (n * I - r * k - a * L) * v, S[2] = (p * T - f * E + g * b) * v, S[3] = (c * E - h * T - d * b) * v, S[4] = (_ * M - s * k - l * z) * v, S[5] = (i * k - n * M + a * z) * v, S[6] = (f * y - m * T - g * x) * v, S[7] = (u * T - c * y + d * x) * v, S[8] = (s * I - o * M + l * A) * v, S[9] = (r * M - i * I - a * A) * v, S[10] = (m * E - p * y + g * w) * v, S[11] = (h * y - u * E - d * w) * v, S[12] = (o * z - s * L - _ * A) * v, S[13] = (i * L - r * z + n * A) * v, S[14] = (p * x - m * b - f * w) * v, S[15] = (u * b - h * x + c * w) * v), S = O.view_projection, R = O.projection, P = O.view_inverse, i = R[0], r = R[1], n = R[2], a = R[3], s = R[4], o = R[5], _ = R[6], l = R[7], u = R[8], h = R[9], c = R[10], d = R[11], m = R[12], p = R[13], f = R[14], g = R[15], w = P[0], x = P[1], y = P[2], b = P[3], S[0] = w * i + x * s + y * u + b * m, S[1] = w * r + x * o + y * h + b * p, S[2] = w * n + x * _ + y * c + b * f, S[3] = w * a + x * l + y * d + b * g, w = P[4], x = P[5], y = P[6], b = P[7], S[4] = w * i + x * s + y * u + b * m, S[5] = w * r + x * o + y * h + b * p, S[6] = w * n + x * _ + y * c + b * f, S[7] = w * a + x * l + y * d + b * g, w = P[8], x = P[9], y = P[10], b = P[11], S[8] = w * i + x * s + y * u + b * m, S[9] = w * r + x * o + y * h + b * p, S[10] = w * n + x * _ + y * c + b * f, S[11] = w * a + x * l + y * d + b * g, w = P[12], x = P[13], y = P[14], b = P[15], S[12] = w * i + x * s + y * u + b * m, S[13] = w * r + x * o + y * h + b * p, S[14] = w * n + x * _ + y * c + b * f, S[15] = w * a + x * l + y * d + b * g, S = O.view_projection_inverse, R = O.view_projection, i = R[0], r = R[1], n = R[2], a = R[3], s = R[4], o = R[5], _ = R[6], l = R[7], u = R[8], h = R[9], c = R[10], d = R[11], m = R[12], p = R[13], f = R[14], g = R[15], (v = (w = i * o - r * s) * (k = c * g - d * f) - (x = i * _ - n * s) * (I = h * g - d * p) + (y = i * l - a * s) * (L = h * f - c * p) + (b = r * _ - n * o) * (M = u * g - d * m) - (E = r * l - a * o) * (z = u * f - c * m) + (T = n * l - a * _) * (A = u * p - h * m)) && (v = 1 / v, S[0] = (o * k - _ * I + l * L) * v, S[1] = (n * I - r * k - a * L) * v, S[2] = (p * T - f * E + g * b) * v, S[3] = (c * E - h * T - d * b) * v, S[4] = (_ * M - s * k - l * z) * v, S[5] = (i * k - n * M + a * z) * v, S[6] = (f * y - m * T - g * x) * v, S[7] = (u * T - c * y + d * x) * v, S[8] = (s * I - o * M + l * A) * v, S[9] = (r * M - i * I - a * A) * v, S[10] = (m * E - p * y + g * w) * v, S[11] = (h * y - u * E - d * w) * v, S[12] = (o * z - s * L - _ * A) * v, S[13] = (i * L - r * z + n * A) * v, S[14] = (p * x - m * b - f * w) * v, S[15] = (u * b - h * x + c * w) * v), "perspective" === O.type && O.calc_bounds(), O.update_frustum(O.view_projection)) }, t.validate = function (t) { this.priority = t.use_system("ge_transform_system").priority + 50 }, function (t, i) { e.apply(this, arguments) } }, ecs.system)), function (t, e, i) { var r, n; e.geometry = { shapes: {} }, e.geometry.geometry_data = e.define(function (r) { function n() { return this.compiled = !1, this.uuid = t.guidi(), this.attributes = {}, this.version = 0, this.bounds_sphere = 0, this.aabb = i.aabb(), this.index_buffer = null, this.index_data = null, this.origin = i.vec3(), this } n.index_data_type = Uint32Array; var s, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y, b, E, T, A, z, M, L, I = new n.index_data_type(1); return r.set_indices = function (t) { Object.prototype.toString.call(t) === Object.prototype.toString.call(I) ? this.index_data = t : this.index_data = n.create_index_data(t), this.index_needs_update = !0, this.num_items = this.index_data.length }, r.add_attribute = function (t, e) { return e.buffer = null, e.item_size = e.item_size || 3, e.data = e.data || null, e.needs_update = e.needs_update || !1, e.divisor = e.divisor || 0, e.array = e.array || null, e.data_offset = e.data_offset || 0, e.data_length = e.data_length || 0, e.buffer_type = e.buffer_type || 35044, e.name = t, e.geo_id = this.uuid, null !== e.data && (e.data_length = e.data.length), this.attributes[t] = e, e }, r.create_instance_id_attribute = function (t) { for (var e = this.add_attribute("a_instance_id_rw", { data: new Float32Array(t), item_size: 1, divisor: 1 }), i = 0; i < e.data.length; i++)e.data[i] = i }, r.convert_to_index_geometry = function () { var t, e, i, r = this.attributes.a_position_rw.data, a = this.attributes.a_normal_rw ? this.attributes.a_normal_rw.data : void 0, s = this.attributes.a_uv_rw ? this.attributes.a_uv_rw.data : void 0, o = [], _ = [], l = [], u = {}, h = []; for (e = 0; e < r.length; e += 3)u[t = r[e] + ":" + r[e + 1] + ":" + r[e + 2]] || (u[t] = o.length / 3 + 1, o.push(r[e], r[e + 1], r[e + 2]), a && _.push(a[e], a[e + 1], a[e + 2]), s && (i = e / 3 * 2, l.push(s[i], s[i + 1]))), h.push(u[t] - 1); var c = n.create({ vertices: new Float32Array(o), normals: _.length > 0 ? new Float32Array(_) : void 0, uvs: l.length > 0 ? new Float32Array(l) : void 0 }); return c.set_indices(h), c }, r.auto_normals = function (t) { this.attributes.a_normal_rw && !t || n.calc_normals(this) }, r.clone = function () { var t = n.create({ vertices: new Float32Array(this.attributes.a_position_rw.data), normals: this.attributes.a_normal_rw ? new Float32Array(this.attributes.a_normal_rw.data) : void 0, uvs: this.attributes.a_uv_rw ? new Float32Array(this.attributes.a_uv_rw.data) : void 0 }); return null !== this.index_data && t.set_indices(this.index_data), t }, r.find_origin = function (t, e) { return n.find_origin(this.attributes.a_position_rw.data, this.attributes.a_position_rw.item_size, t, e) }, r.center_pivot = function (t, e, i, r, a, s) { var o = this.attributes.a_position_rw; return n.center_pivot(this, t, e, i, r, a, s, o.data, o.data.length, o.item_size) }, r.scale_position_rotation = function (t, e, i, r, a, s, o, _, l, u) { u = u || this.attributes.a_position_rw, n.scale_position_rotation(t, e, i, r, a, s, o, _, l, u.data, u.data.length, u.item_size), n.calc_bounds(this, u.data, u.data.length, u.item_size) }, n.center_pivot = function (t, e, i, r, a, s, o, _, l, u) { var h = t.aabb; n.scale_position_rotation(1, 1, 1, -h[0], -h[1], -h[2], 0, 0, 0, _, l, u), n.calc_bounds(t, _, l, u); var c = .5 * ((h = t.aabb)[3] - h[0]), d = .5 * (h[4] - h[1]), m = .5 * (h[5] - h[2]); n.scale_position_rotation(1, 1, 1, -c, -d, -m, 0, 0, 0, _, l, u), n.calc_bounds(t, _, l, u), n.scale_position_rotation(e, i, r, 0, 0, 0, a, s, o, _, u), n.calc_bounds(t, _, l, u) }, n.create_index_data = function (t) { return new this.index_data_type(t) }, n.scale_position_rotation = (s = i.mat4(), o = i.quat(), function (t, e, r, a, _, l, u, h, c, d, m, p) { i.quat.rotate_eular(o, u, h, c), i.mat4.from_quat(s, o), s[0] *= t, s[1] *= e, s[2] *= r, s[4] *= t, s[5] *= e, s[6] *= r, s[8] *= t, s[9] *= e, s[10] *= r, s[12] = a, s[13] = _, s[14] = l, n.transform(d, m, p, s) }), n.calc_bounds = (_ = i.vec3(), l = i.vec3(), u = 0, n.transform = function (t, e, r, n) { for (u = 0; u < e; u += r)i.vec3.transform_mat4x(_, t[u], t[u + 1], t[u + 2], n), t[u] = _[0], t[u + 1] = _[1], t[u + 2] = _[2] }, n.find_origin = function (t, e, r, n) { for (i.vec3.set(_, 1 / 0, 1 / 0, 1 / 0), i.vec3.set(l, -1 / 0, -1 / 0, -1 / 0), u = r * e; u < r * e + n * e; u += e)_[0] = Math.min(_[0], t[u]), _[1] = Math.min(_[1], t[u + 1]), _[2] = Math.min(_[2], t[u + 2]), l[0] = Math.max(l[0], t[u]), l[1] = Math.max(l[1], t[u + 1]), l[2] = Math.max(l[2], t[u + 2]); var a = []; return a[0] = _[0] + .5 * (l[0] - _[0]), a[1] = _[1] + .5 * (l[1] - _[1]), a[2] = _[2] + .5 * (l[2] - _[2]), a }, function (t, e, r, n) { for (t.bounds_sphere = 0, i.vec3.set(_, 1 / 0, 1 / 0, 1 / 0), i.vec3.set(l, -1 / 0, -1 / 0, -1 / 0), u = 0; u < r; u += n)t.bounds_sphere = Math.max(t.bounds_sphere, Math.abs(Math.hypot(e[u], e[u + 1], e[u + 2]))), _[0] = Math.min(_[0], e[u]), _[1] = Math.min(_[1], e[u + 1]), _[2] = Math.min(_[2], e[u + 2]), l[0] = Math.max(l[0], e[u]), l[1] = Math.max(l[1], e[u + 1]), l[2] = Math.max(l[2], e[u + 2]); return t.origin[0] = _[0] + .5 * (l[0] - _[0]), t.origin[1] = _[1] + .5 * (l[1] - _[1]), t.origin[2] = _[2] + .5 * (l[2] - _[2]), i.aabb.set(t.aabb, _[0], _[1], _[2], l[0], l[1], l[2]), t.bounds_sphere }), n.calc_normals = (E = i.vec3(), T = i.vec3(), A = i.vec3(), z = i.vec3(), M = i.vec3(), L = i.vec3(), i.vec3(), i.vec3(), n.invert_normals = function (t) { for (b = t.attributes.a_normal_rw.data, w = 0; w < b.length; w += 3)b[w] = -b[w], b[w + 1] = -b[w + 1], b[w + 2] = -b[w + 2]; t.attributes.needs_update = !0 }, function (t, e) { var r = t.attributes.a_position_rw.data; t.attributes.a_normal_rw || t.add_attribute("a_normal_rw", { data: new Float32Array(r.length) }), b = t.attributes.a_normal_rw.data; var n = t.index_data; b.fill(0); var s = r.length, o = 9; null !== n && (s = n.length, o = 3); for (var _ = 0; _ < s; _ += o)null !== n ? (w = n[_], x = n[_ + 1], y = n[_ + 2], i.vec3.set(E, r[3 * w], r[3 * w + 1], r[3 * w + 2]), i.vec3.set(T, r[3 * x], r[3 * x + 1], r[3 * x + 2]), i.vec3.set(A, r[3 * y], r[3 * y + 1], r[3 * y + 2])) : (i.vec3.set(E, r[_ + 0], r[_ + 1], r[_ + 2]), i.vec3.set(T, r[_ + 3], r[_ + 4], r[_ + 5]), i.vec3.set(A, r[_ + 6], r[_ + 7], r[_ + 8])), i.vec3.subtract(z, A, T), i.vec3.subtract(M, E, T), null !== n ? (w *= 3, x *= 3, y *= 3) : (w = _, x = _ + 3, y = _ + 6), e ? (i.vec3.cross(L, z, M), i.vec3.normalize(z, L), b[w + 0] += z[0], b[w + 1] += z[1], b[w + 2] += z[2], b[x + 0] += z[0], b[x + 1] += z[1], b[x + 2] += z[2], b[y + 0] += z[0], b[y + 1] += z[1], b[y + 2] += z[2]) : (i.vec3.cross(L, z, M), i.vec3.copy(z, L), b[w + 0] += z[0], b[w + 1] += z[1], b[w + 2] += z[2], b[x + 0] += z[0], b[x + 1] += z[1], b[x + 2] += z[2], b[y + 0] += z[0], b[y + 1] += z[1], b[y + 2] += z[2]); for (a = 0; a < b.length; a += 3)i.vec3.set(z, b[a], b[a + 1], b[a + 2]), i.vec3.normalize(L, z), b[a] = L[0], b[a + 1] = L[1], b[a + 2] = L[2] }), n.calc_tangents = (h = i.vec3(), c = i.vec3(), d = i.vec4(), m = i.vec3(), p = i.vec3(), f = i.vec3(), g = i.vec3(), v = i.vec3(), function (t) { var e = t.attributes.a_position_rw.data, r = t.attributes.a_normal_rw.data, n = t.attributes.a_tangent_rw.data, a = t.attributes.a_uv_rw.data, s = t.index_data, o = new Float32Array(e.length); o.fill(0); var _, l, u, w, x, y, b, E, T, A, z, M, L, I, k, S, R, F, N, C, G, P = new Float32Array(e.length); P.fill(0); for (var j = 0; j < s.length; j += 3)_ = s[j], l = s[j + 1], w = 3 * _, y = 3 * (u = s[j + 2]), b = e[x = 3 * l] - e[w], E = e[y] - e[w], T = e[x + 1] - e[w + 1], A = e[y + 1] - e[w + 1], z = e[x + 2] - e[w + 2], M = e[y + 2] - e[w + 2], L = 2 * _, k = 2 * u, S = a[I = 2 * l] - a[L], R = a[k] - a[L], F = a[I + 1] - a[L + 1], C = 1 / (S * (N = a[k + 1] - a[L + 1]) - R * F), i.vec3.set(g, (N * b - F * E) * C, (N * T - F * A) * C, (N * z - F * M) * C), i.vec3.set(v, (S * E - R * b) * C, (S * A - R * T) * C, (S * M - R * z) * C), o[w] += g[0], o[w + 1] += g[1], o[w + 2] += g[2], o[x] += g[0], o[x + 1] += g[1], o[x + 2] += g[2], o[y] += g[0], o[y + 1] += g[1], o[y + 2] += g[2], P[w] += v[0], P[w + 1] += v[1], P[w + 2] += v[2], P[x] += v[0], P[x + 1] += v[1], P[x + 2] += v[2], P[y] += v[0], P[y + 1] += v[1], P[y + 2] += v[2]; for (var O = 0; O < e.length; O += 3)G = O / 3, i.vec3.set(h, r[O], r[O + 1], r[O + 2]), i.vec3.set(c, o[O], o[O + 1], o[O + 2]), i.vec3.scale(f, h, i.vec3.dot(h, c)), i.vec3.subtract(p, c, f), i.vec3.normalize(d, p), i.vec3.cross(m, h, c), i.vec3.set(p, P[O], P[O + 1], P[O + 2]), d[3] = i.vec3.dot(m, p) < 0 ? -1 : 1, n[4 * G] = d[0], n[4 * G + 1] = d[1], n[4 * G + 2] = d[2], n[4 * G + 3] = d[3] }), n.lines_builder = new function () { var t, i, r, a, s, o; return this.vertices = new e.array, this.clear = function () { return this.vertices.clear(), this }, this.add = function (e, n, a) { return t = e, i = n, r = a, this.vertices.push(e), this.vertices.push(n), this.vertices.push(a), this }, this.add2 = function (t, e, i, r, n, a) { return this.add(t, e, i), this.add(r, n, a), this }, this.add_to = function (e, n, a) { return this.add(t, i, r), this.add(e, n, a), this }, this.move_to = function (e, n, _) { return t = e, i = n, r = _, a = e, s = n, o = _, this }, this.close_path = function () { return this.add(t, i, r), this.vertices.push(a), this.vertices.push(s), this.vertices.push(o), this }, this.update_geo = function (e) { var i = e.attributes.a_position_rw; for (t = 0; t < i.data.length; t++)i.data[t] = this.vertices.data[t]; i.needs_update = !0 }, this.build = function () { var i = new e.geometry.geometry_data; for (i.add_attribute("a_position_rw", { data: new Float32Array(this.vertices.length), item_size: 3 }), t = 0; t < this.vertices.length; t++)i.attributes.a_position_rw.data[t] = this.vertices.data[t]; return i.num_items = this.vertices.length / 3, n.calc_bounds(i, i.attributes.a_position_rw.data, i.attributes.a_position_rw.data.length, 3), this.clear(), i }, this }, n.create = function (t) { var i = t.vertex_size || 3, r = new e.geometry.geometry_data; if (t.vertices && (r.add_attribute("a_position_rw", { data: t.vertices, item_size: i }), r.num_items = t.vertices.length / i), t.normals && r.add_attribute("a_normal_rw", { data: t.normals, item_size: i }), t.uvs && r.add_attribute("a_uv_rw", { data: t.uvs, item_size: 2 }), t.colors && r.add_attribute("a_color_rw", { data: t.colors, item_size: 4 }), t.skin_joints && r.add_attribute("a_joints_indices", { data: t.skin_joints, item_size: 4 }), t.skin_weights && r.add_attribute("a_joints_weights", { data: t.skin_weights, item_size: 4 }), t.attr) for (var a in t.attr) r.add_attribute(a, t.attr[a]); return t.indices && r.set_indices(t.indices), r.attributes.a_position_rw && n.calc_bounds(r, r.attributes.a_position_rw.data, r.attributes.a_position_rw.data.length, 3), r }, n.merge = function (t) { var i, r, a, s = {}, o = 0; for (r in t[0].attributes) i = t[0].attributes[r], s[r] = { __size: 0, __datas: [], item_size: i.item_size, divisor: i.divisor }; var _ = new e.geometry.geometry_data; _.subs = []; var l = 0, u = 0; t.forEach(function (t) { for (r in t.index_data && (o += t.index_data.length), t.attributes) s[r] && (s[r].__size += t.attributes[r].data.length, s[r].__datas.push(t.attributes[r].data)), "a_position_rw" === r && (l = t.attributes[r].data.length / t.attributes[r].item_size, _.subs.push({ v_index: u, v_count: l }), u += l) }); var h = 0, c = 0; for (r in s) i = t[0].attributes[r], s[r].data = new Float32Array(s[r].__size), h = 0, s[r].__datas.forEach(function (t) { for (a = 0; a < t.length; a++)s[r].data[h++] = t[a] }), delete s[r].__size, delete s[r].__datas, _.add_attribute(r, s[r]); return o > 0 && (_.index_data = n.create_index_data(o), h = 0, c = 0, t.forEach(function (t, e) { for (a = 0; a < t.index_data.length; a++)_.index_data[h++] = _.subs[e].v_index + t.index_data[a]; _.subs[e].i_start = 4 * c, _.subs[e].i_count = t.index_data.length, c += t.index_data.length })), _.num_items = _.index_data.length, _ }, n.create_float32_ids = function (t) { for (var e = new Float32Array(t), i = 0; i < t; i++)e[i] = i; return e }, n.create_float32_timeline = function (t) { for (var e = new Float32Array(t), i = 0; i < t; i++)e[i] = i / t; return e }, n.to_distributed_geometry = function () { var t = new e.array, i = new e.array, r = new e.array, a = new e.array, s = { aabb: [], origin: [] }, o = 0, _ = 0; function l(e) { t.push(e.attributes.a_position_rw.data[o]).push(e.attributes.a_position_rw.data[o + 1]).push(e.attributes.a_position_rw.data[o + 2]), e.attributes.a_normal_rw && r.push(e.attributes.a_normal_rw.data[o]).push(e.attributes.a_normal_rw.data[o + 1]).push(e.attributes.a_normal_rw.data[o + 2]), e.attributes.a_uv_rw && (_ = o / 3 * 2, a.push(e.attributes.a_uv_rw.data[_]).push(e.attributes.a_uv_rw.data[_ + 1])) } return function (e, _) { i.clear(), r.clear(), a.clear(); var u, h = []; _.forEach(function (r) { if (t.clear(), r.length) r.forEach(function (t) { for (o = 3 * t.draw_offset; o < 3 * t.draw_offset + 3 * t.draw_count; o += 3)l(e) }); else for (o = 3 * r.draw_offset; o < 3 * r.draw_offset + 3 * r.draw_count; o += 3)l(e); n.calc_bounds(s, t.data, t.length, 3), u = r.length ? r[0] : r, Object.assign(u, { draw_offset: i.length / 3, draw_count: t.length / 3, origin: [s.origin[0], s.origin[1], s.origin[2]] }), h.push(u), !1 !== u.center_pivot && n.center_pivot(s, 1, 1, 1, 0, 0, 0, t.data, t.length, 3), i.append_other(t) }); var c = n.create({ vertices: i.float32Array(), normals: r.length > 0 ? r.float32Array() : void 0, uvs: a.length > 0 ? a.float32Array() : void 0 }); return c.distribution = h, c } }(), n }), e.geometry.shapes.cube = function (t) { (t = t || {}).size = t.size || 1; var r = t.width || t.size, n = t.height || t.size, a = t.depth; void 0 === a && (a = t.size); var s, o, _, l, u, h, c, d, m, p, f, g, v = t.divs || 1, w = Math.floor(t.divs_x) || v, x = Math.floor(t.divs_y) || v, y = Math.floor(t.divs_z) || v, b = i.vec3(), E = [], T = [], A = [], z = [], M = 0; function L(t, e, i, r, n, a, v, w, x, y) { for (s = a / x, o = v / y, _ = a / 2, l = v / 2, u = w / 2, h = x + 1, c = y + 1, d = 0, p = 0; p < c; p++)for (g = p * o - l, m = 0; m < h; m++)f = m * s - _, b[t] = f * r, b[e] = g * n, b[i] = u, T.push(b[0], b[1], b[2]), b[t] = 0, b[e] = 0, b[i] = w > 0 ? 1 : -1, A.push(b[0], b[1], b[2]), z.push(m / x), z.push(p / y), d += 1; for (p = 0; p < y; p++)for (m = 0; m < x; m++) { var L = M + m + h * p, I = M + m + h * (p + 1), k = M + (m + 1) + h * (p + 1), S = M + (m + 1) + h * p; E.push(L, I, S), E.push(I, k, S) } M += d } L(2, 1, 0, -1, -1, a, n, r, y, x), L(2, 1, 0, 1, -1, a, n, -r, y, x), L(0, 2, 1, 1, 1, r, a, n, w, y), L(0, 2, 1, 1, -1, r, a, -n, w, y), L(0, 1, 2, 1, -1, r, n, a, w, x), L(0, 1, 2, -1, -1, r, n, -a, w, x); var I = new e.geometry.geometry_data; return I.add_attribute("a_position_rw", { data: new Float32Array(T) }), I.add_attribute("a_normal_rw", { data: new Float32Array(A) }), I.add_attribute("a_uv_rw", { data: new Float32Array(z), item_size: 2 }), I.add_attribute("a_tangent_rw", { data: new Float32Array(T.length / 3 * 4), item_size: 4 }), I.set_indices(E), I.shape_type = "cube", e.geometry.geometry_data.calc_tangents(I), e.geometry.geometry_data.calc_bounds(I, I.attributes.a_position_rw.data, I.attributes.a_position_rw.data.length, 3), I }, e.geometry.shapes.plane = function (t) { (t = t || {}).size = t.size || 1, width = t.width || t.size, height = t.height || t.size, t.divs = t.divs || 1, t.divsX = t.divsX || t.divs, t.divsY = t.divsY || t.divs, divs_x = t.divsX, divs_y = t.divsY; var i, r, n = width / 2, a = height / 2, s = Math.floor(divs_x), o = Math.floor(divs_y), _ = s + 1, l = o + 1, u = width / s, h = height / o, c = (divs_x + 1) * (divs_y + 1), d = new e.geometry.geometry_data; d.add_attribute("a_position_rw", { data: new Float32Array(3 * c), item_size: 3 }); var m = null, p = null; d.add_attribute("a_normal_rw", { data: new Float32Array(3 * c), item_size: 3 }), m = d.attributes.a_normal_rw.data, d.add_attribute("a_uv_rw", { data: new Float32Array(2 * c), item_size: 2 }), p = d.attributes.a_uv_rw.data, d.add_attribute("a_tangent_rw", { data: new Float32Array(4 * c), item_size: 4 }), d.index_data = e.geometry.geometry_data.create_index_data(s * o * 6), d.index_needs_update = !0, d.num_items = d.index_data.length, d.shape_type = "plane"; var f, g, v, w, x = d.attributes.a_position_rw.data, y = d.index_data, b = 0, E = 0; for (r = 0; r < l; r++) { var T = r * h - a; for (i = 0; i < _; i++) { var A = i * u - n; x[3 * E + 0] = A, x[3 * E + 1] = -T, x[3 * E + 2] = 0, null !== m && (m[3 * E + 0] = 0, m[3 * E + 1] = 0, m[3 * E + 2] = 1), null !== p && (p[2 * E + 0] = i / s, p[2 * E + 1] = 1 - r / o), E++ } } for (b = 0, r = 0; r < o; r++)for (i = 0; i < s; i++)f = i + _ * r, g = i + _ * (r + 1), v = i + 1 + _ * (r + 1), w = i + 1 + _ * r, y[b++] = f, y[b++] = g, y[b++] = w, y[b++] = g, y[b++] = v, y[b++] = w; return e.geometry.geometry_data.calc_tangents(d), e.geometry.geometry_data.calc_bounds(d, d.attributes.a_position_rw.data, d.attributes.a_position_rw.data.length, 3), d }, e.geometry.shapes.sphere = (r = i.vec3(), n = i.vec3(), function (t) { (t = t || {}).rad = t.rad || 1, t.divs = t.divs || 8, t.divsX = t.divsX || t.divs, t.divsY = t.divsY || t.divs; var a, s, o = t.radX || t.rad, _ = t.radY || t.rad, l = t.radZ || t.rad, u = Math.max(3, Math.floor(t.divsX)), h = Math.max(2, Math.floor(t.divsY)), c = void 0 !== t.phiStart ? t.phiStart : 0, d = void 0 !== t.phiLength ? t.phiLength : 2 * Math.PI, m = void 0 !== t.thetaStart ? t.thetaStart : 0, p = void 0 !== t.thetaLength ? t.thetaLength : Math.PI, f = m + p, g = 0, v = [], w = (u + 1) * (h + 1), x = new e.geometry.geometry_data; x.add_attribute("a_position_rw", { data: new Float32Array(3 * w), item_size: 3 }); var y = null, b = null; x.add_attribute("a_normal_rw", { data: new Float32Array(3 * w), item_size: 3 }), y = x.attributes.a_normal_rw.data, x.add_attribute("a_uv_rw", { data: new Float32Array(2 * w), item_size: 2 }), b = x.attributes.a_uv_rw.data, x.add_attribute("a_tangent_rw", { data: new Float32Array(4 * w), item_size: 4 }), x.index_data = e.geometry.geometry_data.create_index_data(6 * w), x.num_items = x.index_data.length, x.index_needs_update = !0, x.shape_type = "sphere"; var E = x.attributes.a_position_rw.data, T = x.index_data, A = 0, z = 0; for (s = 0; s <= h; s++) { var M = [], L = s / h, I = 0 == s ? .5 / u : s == h ? -.5 / u : 0; for (a = 0; a <= u; a++) { var k = a / u; n[0] = -o * Math.cos(c + k * d) * Math.sin(m + L * p), n[1] = _ * Math.cos(m + L * p), n[2] = l * Math.sin(c + k * d) * Math.sin(m + L * p), E[3 * z + 0] = n[0], E[3 * z + 1] = n[1], E[3 * z + 2] = n[2], null !== y && (i.vec3.normalize(r, n), y[3 * z + 0] = r[0], y[3 * z + 1] = r[1], y[3 * z + 2] = r[2]), null !== b && (b[2 * z + 0] = k + I, b[2 * z + 1] = 1 - L), z++, M.push(g++) } v.push(M) } for (A = 0, s = 0; s < h; s++)for (a = 0; a < u; a++) { var S = v[s][a + 1], R = v[s][a], F = v[s + 1][a], N = v[s + 1][a + 1]; (0 !== s || m > 0) && (T[A++] = S, T[A++] = R, T[A++] = N), (s !== h - 1 || f < Math.PI) && (T[A++] = R, T[A++] = F, T[A++] = N) } return e.geometry.geometry_data.calc_tangents(x), e.geometry.geometry_data.calc_bounds(x, x.attributes.a_position_rw.data, x.attributes.a_position_rw.data.length, 3), x }), e.geometry.shapes.terrain = function () { var t, i = 1200, r = new Uint8Array(0), n = new Float32Array(0), a = {}, s = i / 2, o = 0; function _(t, e) { return o = r[(e + s) * i + (t + s)] } for (var l = 1; l <= 1024;)a[l] = { i: 0, list: [] }, l *= 2; function u(e, n, a) { r[t = (n + s) * i + (e + s)] = Math.min(r[t], a) } s = (i = 2056) / 2, t = i * i, r.length < t && (r = new Uint8Array(t), n = new Float32Array(4 * t)); var h, c, d, m, f, g, v, w, y = new Float32Array(6e5), b = 0, E = 0, T = new Float32Array(2e5), A = 4, M = 16, L = 2; function I(t, e) { return g[e * v + t] } var k = function () { var t, e, n, a, _ = 0, l = [-1, 1, -.75, 1, -.5, 1, -.25, 1, 0, 1, .25, 1, .5, 1, .75, 1, 1, 1, 1, .75, 1, .5, 1, .25, 1, 0, 1, -.25, 1, -.5, 1, -.75, 1, -1, .75, -1, .5, -1, .25, -1, 0, -1, -.25, -1, -.5, -1, -.75, -1, -1, -1, -1, -.75, -1, -.5, -1, -.25, -1, 0, -1, .25, -1, .5, -1, .75, -1, 1], h = []; h[16] = !0, h[32] = !0, h[48] = !0, h[64] = !0; var c = l.length; return function (d, m, p, f) { for (t = l[0], e = l[1], _ = f; _ < c;)o = r[(m + (a = l[_ + 1]) * p + s) * i + (d + (n = l[_]) * p + s)], (h[_] || o < p) && (w = d + t * p, x = m + e * p, E = d + n * p, T = m + a * p, u(g = d, v = m, A = p), y[b] = g, y[b + 2] = v, b += 6, u(w, x, A), y[b] = w, y[b + 2] = x, b += 6, u(E, T, A), y[b] = E, y[b + 2] = T, b += 6, t = n, e = a), _ += f; var g, v, w, x, E, T, A } }(), S = new Float32Array(1024), R = 0, F = 0, N = 0, C = !0, G = !1; function P(u, P, O, D) { for (g = P, E = 0, function t(e, i, r, n, a) { h = I(e, i), c = I(e - r, i - r), d = I(e + r, i - r), m = I(e + r, i + r), f = I(e - r, i + r); var s = E; return y[s] = Math.max(Math.abs(.5 * (c + d) - h), Math.abs(.5 * (f + m) - h), Math.abs(.5 * (c + f) - h), Math.abs(.5 * (d + m) - h)), n > -1 && (y[n + a] = s), r > A && (E += 5, r *= .5, y[s] = Math.max(y[s], t(e - r, i - r, r, s, 1), t(e + r, i - r, r, s, 2), t(e - r, i + r, r, s, 3), t(e + r, i + r, r, s, 4))), y[s] }(w = (v = O) / 2, w, w, -1, 0), F = 0; F < E;)T[F] = y[F++]; b = 0, r.fill(255), function (t, e, i, r, n) { var s = 0; for (S[R = 0] = t, S[R + 1] = e, S[R + 2] = i, S[R + 3] = s, R += 4; R > 0;)t = S[R -= 4], e = S[R + 1], i = S[R + 2], s = S[R + 3], N = r, i > M || i > A && n[s] > N ? (i *= .5, S[R] = t + i, S[R + 1] = e + i, S[R + 2] = i, S[R + 3] = n[s + 4], S[R += 4] = t - i, S[R + 1] = e + i, S[R + 2] = i, S[R + 3] = n[s + 3], S[R += 4] = t + i, S[R + 1] = e - i, S[R + 2] = i, S[R + 3] = n[s + 2], S[R += 4] = t - i, S[R + 1] = e - i, S[R + 2] = i, S[R + 3] = n[s + 1], R += 4) : (p = a[i], p.list[p.i++] = t, p.list[p.i++] = e) }(w, w, w, D, T), function () { for (l = A, G = !1; l <= M;) { for (p = a[l], F = 0, j = p.i; F < j;)x = p.list[F++], z = p.list[F++], fd = 16, C && l >= A && (G = !1, _(x - l, z) < l ? G = !0 : _(x + l, z) < l ? G = !0 : _(x, z - l) < l ? G = !0 : _(x, z + l) < l && (G = !0), G && (fd = l / o, fd < 16 ? fd = Math.max(2, 8 / fd) : fd = 2, fd = Math.min(L, fd))), k(x, z, l, fd); l *= 2 } }(), function (e, a, o, _, u) { for (F = e, l = M; F < a;)x = y[F], z = y[F + 2], _xx = x * u + o, _zz = z * u + _, t = (_zz + s) * i + (_xx + s), 222 !== r[t] ? (r[t] = 222, n[t *= 4] = I(x, z), nx = I(x - l, z) - I(x + l, z), ny = 2 * l, nz = I(x, z - l) - I(x, z + l), _fp = nx * nx + ny * ny + nz * nz, _fp > 0 && (_fp = 1 / Math.sqrt(_fp)), nx *= _fp, ny *= _fp, nz *= _fp, n[t + 1] = nx, n[t + 2] = ny, n[t + 3] = nz) : t *= 4, y[F + 1] = n[t], y[F + 3] = n[t + 1], y[F + 4] = n[t + 2], y[F + 5] = n[t + 3], y[F] = _xx, y[F + 2] = _zz, F += 6 }(0, b, 0, 0, 1); var q = u.attributes.a_position_rw; q.data = new Float32Array(b / 6 * 8); var U = 0; for (F = 0; F < b; F += 6)q.data[U] = y[F], q.data[U + 1] = y[F + 1], q.data[U + 2] = y[F + 2], q.data[U + 3] = y[F + 3], q.data[U + 4] = y[F + 4], q.data[U + 5] = y[F + 5], q.data[U + 6] = q.data[U] / v, q.data[U + 7] = q.data[U + 2] / v, U += 8; u.num_items = U / 8, q.data_length = U, q.needs_update = !0, e.geometry.geometry_data.calc_bounds(u, q.data, q.data.length, 8) } return function (t) { var i = new e.geometry.geometry_data; if (i.add_attribute("a_position_rw", { item_size: 3, data: new Float32Array(0), stride: 32 }), i.add_attribute("a_normal_rw", { item_size: 3, stride: 32, offset: 12 }), i.add_attribute("a_uv_rw", { item_size: 2, stride: 32, offset: 24 }), t.url) { var r = t.divisor || 1; e.load_working_image_data(t.url, function (e, n, a) { for (var s = new Float32Array((t.size + 1) * (t.size + 1)), o = 0; o < e.length / 4; o++)s[o] = e[4 * o] / r; P(i, s, t.size, t.details || 4) }, t.size, t.size) } return i } }(), function () { var i, r, n, s, o = e.define(function (t) { return t.clear = function () { this.indices.clear(), this.normal.clear(), this.texture.clear() }, function () { this.indices = new e.array, this.texture = new e.array, this.normal = new e.array, this.vindex = 0, this.obj_name = void 0 } }), _ = [], l = new t.object_pooler(function () { return new o }), u = new e.array, h = 3, c = new e.array, d = 2, m = new e.array, p = new e.array, f = new e.array, g = new e.array; e.geometry.shapes.obj = function () { var t, i, r, n, a, s, o, v, w = new e.array; function x(t, e) { e = (e - 1) * h, p.push(u.data[e]).push(u.data[e + 1]).push(u.data[e + 2]) } function y(t, e) { e = (e - 1) * h, g.push(m.data[e]).push(m.data[e + 1]).push(m.data[e + 2]) } function b(t, e) { e = (e - 1) * d, f.push(c.data[e]).push(c.data[e + 1]) } return { extract_mesh: function (t, n) { for (r = t.obj_meta.meshes[n], p.clear(), g.clear(), i = 3 * r.draw_offset; i < 3 * r.draw_offset + 3 * r.draw_count; i += 3)p.push(t.attributes.a_position_rw.data[i]).push(t.attributes.a_position_rw.data[i + 1]).push(t.attributes.a_position_rw.data[i + 2]), g.push(t.attributes.a_normal_rw.data[i]).push(t.attributes.a_normal_rw.data[i + 1]).push(t.attributes.a_normal_rw.data[i + 2]); var a = e.geometry.geometry_data.create({ vertices: p.float32Array(), normals: g.float32Array() }), s = [a.origin[0], a.origin[1], a.origin[2]]; return a.center_pivot(1, 1, 1, 0, 0, 0), a.origin = s, a }, parse: function (E, T) { v = void 0; var A = { materials: [], meshes: [] }; if (w.push("").push(0), T) { var z = {}; T.split("\n").forEach(function (t) { z = function (t, e, r) { if (-1 != (a = e.indexOf("#")) && (e = e.substring(0, a)), e = e.trim(), "newmtl" === (n = e.split(/\s+/))[0]) r.name && (t.materials.push(r), r = {}), r.name = n[1]; else if ("Kd" === n[0]) for (r.diffuse = [], i = 0; i < 3; ++i)r.diffuse.push(parseFloat(n[i + 1])); else if ("Ka" === n[0]) for (r.ambient = [], i = 0; i < 3; ++i)r.ambient.push(parseFloat(n[i + 1])); else if ("Ks" === n[0]) for (r.specular = [], i = 0; i < 3; ++i)r.specular.push(parseFloat(n[i + 1])); else "Ns" === n[0] ? r.specularExponent = parseFloat(n[1]) : "d" === n[0] || "Tr" === n[0] ? r.transparent = parseFloat(n[1]) : "illum" === n[0] ? r.illumMode = parseFloat(n[1]) : "map_Ka" === n[0] ? r.ambientMap = e.replace(n[0], "").trim() : "map_Kd" === n[0] ? r.diffuseMap = e.replace(n[0], "").trim() : "map_Ks" === n[0] ? r.specularMap = e.replace(n[0], "").trim() : "map_d" === n[0] ? r.alphaMat = e.replace(n[0], "").trim() : "map_bump" === n[0] || "bump" === n[0] ? r.bumpMap = e.replace(n[0], "").trim() : "disp" === n[0] && (r.displacementMap = e.replace(n[0], "").trim()); return r }(A, t, z) }), A.materials.push(z) } for (E.split("\n").forEach(function (e) { !function (e, r) { if (-1 != (a = r.indexOf("#")) && (r = r.substring(0, a)), r = r.trim(), "v" === (n = r.split(/\s+/))[0]) 3 == (h = n[4] ? 4 : 3) ? u.push(parseFloat(n[1])).push(parseFloat(n[2])).push(parseFloat(n[3])) : 4 == h && u.push(parseFloat(n[1])).push(parseFloat(n[2])).push(parseFloat(n[3])).push(parseFloat(n[4])); else if ("vt" === n[0]) 2 == (d = n[3] ? 3 : 2) ? c.push(parseFloat(n[1])).push(parseFloat(n[2])) : 3 == d && c.push(parseFloat(n[1])).push(parseFloat(n[2])).push(parseFloat(n[3])); else if ("vn" === n[0]) m.push(parseFloat(n[1])).push(parseFloat(n[2])).push(parseFloat(n[3])); else if ("f" === n[0]) for ((t = l.get()).clear(), _[_.length] = t, t.obj_name = v, i = 1; i < n.length; ++i)s = n[i].indexOf("//"), o = n[i].split(/\W+/), s > 0 ? (t.indices.push(parseInt(o[0])), t.normal.push(parseInt(o[1]))) : 1 === o.length ? t.indices.push(parseInt(o[0])) : 2 === o.length ? (t.indices.push(parseInt(o[0])), t.texture.push(parseInt(o[1]))) : 3 === o.length && (t.indices.push(parseInt(o[0])), t.texture.push(parseInt(o[1])), t.normal.push(parseInt(o[2]))); else if ("g" === n[0] || "o" === n[0]) v = n[1].trim(); else if ("usemtl" === n[0]) if (0 === _.length) w.data[0] = n[1].trim(); else { var p = n[1].trim(), f = _.length; w.push(p).push(f) } }(0, e) }), _.forEach(function (t) { t.vindex = p.length / 3, 3 === t.indices.length ? (x(0, t.indices.data[0]), x(0, t.indices.data[1]), x(0, t.indices.data[2])) : 4 === t.indices.length && (x(0, t.indices.data[0]), x(0, t.indices.data[1]), x(0, t.indices.data[2]), x(0, t.indices.data[0]), x(0, t.indices.data[2]), x(0, t.indices.data[3])), 3 === t.normal.length ? (y(0, t.normal.data[0]), y(0, t.normal.data[1]), y(0, t.normal.data[2])) : 4 === t.normal.length && (y(0, t.normal.data[0]), y(0, t.normal.data[1]), y(0, t.normal.data[2]), y(0, t.normal.data[0]), y(0, t.normal.data[2]), y(0, t.normal.data[3])), 3 === t.texture.length && (b(0, t.texture.data[0]), b(0, t.texture.data[1]), b(0, t.texture.data[2])) }), A.meshes = [], i = 0; i < w.length; i += 2)A.meshes.push({ mat: w.data[i], draw_offset: _[w.data[i + 1]].vindex, draw_count: 0, name: _[w.data[i + 1]].obj_name }); for (i = 0; i < A.meshes.length - 1; i++)(r = A.meshes[i]).draw_count = A.meshes[i + 1].draw_offset - r.draw_offset; (r = A.meshes[i]).draw_count = p.length / 3 - r.draw_offset; var M = e.geometry.geometry_data.create({ vertices: p.float32Array(), normals: g.length > 0 ? g.float32Array() : void 0, uvs: f.length > 0 ? f.float32Array() : void 0 }); for (M.obj_meta = A, i = 0; i < _.length; i++)l.free(_[i]); return _.length = 0, p.clear(), g.clear(), f.clear(), w.clear(), u.clear(), m.clear(), c.clear(), M } } }(), e.geometry.shapes.gltf = (r = { MODE_POINTS: 0, MODE_LINES: 1, MODE_LINE_LOOP: 2, MODE_LINE_STRIP: 3, MODE_TRIANGLES: 4, MODE_TRIANGLE_STRIP: 5, MODE_TRIANGLE_FAN: 6, TYPE_BYTE: 5120, TYPE_UNSIGNED_BYTE: 5121, TYPE_SHORT: 5122, TYPE_UNSIGNED_SHORT: 5123, TYPE_UNSIGNED_INT: 5125, TYPE_FLOAT: 5126, COMP_SCALAR: 1, COMP_VEC2: 2, COMP_VEC3: 3, COMP_VEC4: 4, COMP_MAT2: 4, COMP_MAT3: 9, COMP_MAT4: 16 }, n = function (t, e) { var i = t.accessors[e], n = t.bufferViews[i.bufferView], a = function (t, e) { var i = t.buffers[e]; if (null != i.dView) return i; if ("data:" != i.uri.substr(0, 5)) return i; for (var r = i.uri.indexOf("base64,") + 7, n = window.atob(i.uri.substr(r)), a = new DataView(new ArrayBuffer(n.length)), s = 0; s < n.length; s++)a.setUint8(s, n.charCodeAt(s)); return i.dView = a, i }(t, n.buffer), s = (i.byteOffset || 0) + (n.byteOffset || 0), o = 0, _ = null, l = null; switch (i.componentType) { case r.TYPE_FLOAT: _ = Float32Array, l = "getFloat32"; break; case r.TYPE_SHORT: _ = Int16Array, l = "getInt16"; break; case r.TYPE_UNSIGNED_SHORT: _ = Uint16Array, l = "getUint16"; break; case r.TYPE_UNSIGNED_INT: _ = Uint32Array, l = "getUint32"; break; case r.TYPE_UNSIGNED_BYTE: _ = Uint8Array, l = "getUint8"; break; default: return console.log("ERROR processAccessor", "componentType unknown", i.componentType), null }o = null != n.byteStride ? n.byteStride * i.count : i.count * r["COMP_" + i.type] * _.BYTES_PER_ELEMENT; for (var u = _.BYTES_PER_ELEMENT, h = o / u, c = new _(h), d = 0, m = 0; m < h; m++)d = s + m * u, c[m] = a.dView[l](d, !0); return { data: c, max: i.max, min: i.min, count: i.count, compLen: r["COMP_" + i.type] } }, function (t) { console.log(t); var e, r, a, s, o, _, l = { meshes: [] }; return t.nodes.forEach(function (e, r) { if (e.children && e.children.forEach(function (i, r) { e.children[r] = t.nodes[i], t.nodes[i].parent = e }), void 0 !== e.mesh && (e.mesh = t.meshes[e.mesh], e.mesh.loaded || (e.mesh.geos = [], e.mesh.primitives.forEach(function (e) { console.log(e); var i = {}; void 0 !== e.attributes.POSITION && (i.vertices = n(t, e.attributes.POSITION).data), void 0 !== e.attributes.NORMAL && (i.normals = n(t, e.attributes.NORMAL).data), void 0 !== e.attributes.WEIGHTS_0 && (i.weights = n(t, e.attributes.WEIGHTS_0).data), void 0 !== e.attributes.JOINTS_0 && (i.joints = new Float32Array(n(t, e.attributes.JOINTS_0).data)), void 0 !== e.indices && (i.indices = n(t, e.indices).data), l.meshes.push(i) }))), void 0 !== e.skin) { e.skin = t.skins[e.skin]; var a = { joints: [] }, s = n(t, e.skin.inverseBindMatrices); e.skin.joints.forEach(function (e, r) { i = t.nodes[e], a.joints[r] = { name: i.name, pos: i.translation, rot: i.rotation, scale: [1, 1, 1], bind_pos: new Float32Array(s.data.buffer, 16 * r * 4, 16) }, r > 0 && t.nodes[e].parent && (a.joints[r].pn = t.nodes[e].parent.name) }), l.skin = a } }), t.scenes.forEach(function (e) { e.nodes.forEach(function (i, r) { e.nodes[r] = t.nodes[i] }) }), t.animations && t.animations.forEach(function (i) { a = 1 / 0, s = -1 / 0, i.channels.forEach(function (o) { e = i.samplers[o.sampler], r = n(t, e.input), o.times = r.data, o.a1 = r, a = Math.min(a, r.min[0]), s = Math.max(s, r.max[0]), r = n(t, e.output), o.values = r.data, o.vsize = r.compLen, o.a2 = r }), i.duration = s - a, i.channels.forEach(function (t) { t.data = new Float32Array(t.values.length + t.times.length), t.times.forEach(function (e, r) { for (o = r * (t.vsize + 1), t.data[o++] = e / i.duration, _ = r * t.vsize, r = 0; r < t.vsize - 1; r++)t.data[o++] = t.values[_++] }) }) }), l }), e.geometry.shapes.gltf2 = ((s = function () { function t() { } return t.parse_accessor = function (e, i, r, n) { void 0 === n && (n = !1); var s, o, _ = i.accessors[e], l = i.bufferViews[_.bufferView], u = t["COMP_" + _.type], h = null; switch (_.componentType) { case t.TYPE_FLOAT: s = Float32Array, o = "getFloat32"; break; case t.TYPE_SHORT: s = Int16Array, o = "getInt16"; break; case t.TYPE_UNSIGNED_SHORT: s = Uint16Array, o = "getUint16"; break; case t.TYPE_UNSIGNED_INT: s = Uint32Array, o = "getUint32"; break; case t.TYPE_UNSIGNED_BYTE: s = Uint8Array, o = "getUint8"; break; default: return console.log("ERROR processAccessor", "componentType unknown", a.componentType), null }var c = { min: _.min, max: _.max, elm_cnt: _.count, comp_len: u }; if (l.byteStride) { n && console.error("GLTF STRIDE SPEC ONLY OPTION NEEDS TO BE IMPLEMENTED "); var d = l.byteStride, m = _.count, p = l.byteOffset || 0, f = _.byteOffset || 0, g = s.BYTES_PER_ELEMENT, v = m * u, w = new DataView(r), x = 0, y = 0, b = 0; h = new s(v); for (var E = 0; E < m; E++)for (x = p + d * E + f, y = 0; y < u; y++)h[b++] = w[o](x + y * g, !0); c.data = h } else n ? (c.array_type = s.name.substring(0, s.name.length - 5), c.byte_start = (_.byteOffset || 0) + (l.byteOffset || 0), c.byte_cnt = _.count * u * s.BYTES_PER_ELEMENT) : (p = (_.byteOffset || 0) + (l.byteOffset || 0), c.data = new s(r, p, _.count * u)); return c }, t.get_mesh = function (e, i, r, n) { void 0 === n && (n = !1); for (var a, s = null, o = null, _ = 0, l = i.nodes; _ < l.length; _++)if ((a = l[_]).name === e && null != a.mesh) { o = (s = a).mesh; break } if (!s) for (a = 0; a < i.meshes.length; a++)if (i.meshes[a].name == e) { o = a; break } if (null == o) return console.error("Node or Mesh by the name", e, "not found in GLTF"), null; for (var u, h, c, d = i.meshes[o], m = d.primitives.length, p = new Array(m), f = 0; f < m; f++)c = (h = d.primitives[f]).attributes, u = { name: e + (1 != m ? "_p" + f : ""), mode: null != h.mode ? h.mode : t.MODE_TRIANGLES }, s && (s.translation && (u.position = s.translation.slice(0)), s.rotation && (u.rotation = s.rotation.slice(0)), s.scale && (u.scale = s.scale.slice(0))), u.vertices = t.parse_accessor(c.POSITION, i, r, n), null != h.indices && (u.indices = t.parse_accessor(h.indices, i, r, n)), null != c.NORMAL && (u.normal = t.parse_accessor(c.NORMAL, i, r, n)), null != c.TEXCOORD_0 && (u.uv = t.parse_accessor(c.TEXCOORD_0, i, r, n)), null != c.WEIGHTS_0 && (u.weights = t.parse_accessor(c.WEIGHTS_0, i, r, n)), null != c.JOINTS_0 && (u.joints = t.parse_accessor(c.JOINTS_0, i, r, n)), p[f] = u; return p }, t.get_skin = function (e, i, r, n) { if (void 0 === r && (r = null), void 0 === n && (n = null), !e.skins) return console.error("There is no skin in the GLTF file."), null; var a, s = null; if (null != r) { for (var o = 0, _ = e.skins; o < _.length; o++)if ((a = _[o]).name == r) { s = a; break } if (!s) return console.error("skin not found", r), null } else for (var l = 0, u = e.skins; l < u.length; l++) { s = a = u[l], r = a.name; break } var h, c, d, m = s.joints.length, p = new Array(m), f = {}; for (a = 0; a < m; a++)f["n" + s.joints[a]] = a, p[a] = { idx: a, p_idx: null, lvl: 0, name: null, pos: null, rot: null, scl: null }; for (a = 0; a < m; a++)if (h = e.nodes[s.joints[a]], c = p[a], void 0 === h.name || "" == h.name ? c.name = "bone_" + a : c.name = h.name.replace("mixamorig:", ""), h.children && h.children.length > 0) for (var g = 0, v = h.children; g < v.length; g++)p[f["n" + v[g]]].p_idx = a; for (a = 0; a < m; a++)if (null != (c = p[a]).p_idx) { for (d = 0; null != c.p_idx;)d++, c = p[c.p_idx]; p[a].lvl = d } else c.lvl = 0; if (n) for (var w = 0, x = e.nodes; w < x.length; w++)if ((a = x[w]).name == r) { a.rotation && (n.rot = a.rotation), a.scale && (n.scl = a.scale), a.position && (n.pos = a.position); break } var y, b = t.parse_accessor(s.inverseBindMatrices, e, i), E = new Mat4, T = new Mat4; for (a = 0; a < m; a++)null == (c = p[a]).p_idx ? T.copy(b.data, 16 * a).invert() : (E.copy(b.data, 16 * c.p_idx), T.copy(b.data, 16 * a).invert(), Mat4.mul(E, T, T)), c.pos = T.get_translation(new Vec3).near_zero(), c.rot = T.get_rotation(new Quat).norm(), c.scl = (y = T.get_scale(new Vec3), 1 - Math.abs(y[0]) <= 1e-4 && (y[0] = 1), 1 - Math.abs(y[1]) <= 1e-4 && (y[1] = 1), 1 - Math.abs(y[2]) <= 1e-4 && (y[2] = 1), y); return p }, t.get_skin_by_nodes = function (t, e, i) { if (void 0 === e && (e = null), void 0 === i && (i = null), !t.skins) return console.error("There is no skin in the GLTF file."), null; var r, n = null; if (null != e) { for (var a = 0, s = t.skins; a < s.length; a++)if ((r = s[a]).name == e) { n = r; break } if (!n) return console.error("skin not found", e), null } else for (var o = 0, _ = t.skins; o < _.length; o++) { n = r = _[o], e = r.name; break } var l, u, h, c = n.joints.length, d = new Array(c), m = {}; for (r = 0; r < c; r++)m["n" + n.joints[r]] = r, d[r] = { idx: r, p_idx: null, lvl: 0, name: null, pos: null, rot: null, scl: null }; for (r = 0; r < c; r++)if (l = t.nodes[n.joints[r]], u = d[r], l.translation && (u.pos = l.translation.slice(0)), l.rotation && (u.rot = l.rotation.slice(0)), void 0 === l.name || "" == l.name ? u.name = "bone_" + r : u.name = l.name.replace("mixamorig:", ""), l.scale && (u.scl = l.scale.slice(0), Math.abs(1 - u.scl[0]) <= 1e-6 && (u.scl[0] = 1), Math.abs(1 - u.scl[1]) <= 1e-6 && (u.scl[1] = 1), Math.abs(1 - u.scl[2]) <= 1e-6 && (u.scl[2] = 1)), l.children && l.children.length > 0) for (var p = 0, f = l.children; p < f.length; p++)d[m["n" + f[p]]].p_idx = r; for (r = 0; r < c; r++)if (null != (u = d[r]).p_idx) { for (h = 0; null != u.p_idx;)h++, u = d[u.p_idx]; d[r].lvl = h } else u.lvl = 0; if (i) for (var g = 0, v = t.nodes; g < v.length; g++)if ((r = v[g]).name == e) { r.rotation && (i.rot = r.rotation), r.scale && (i.scl = r.scale), r.position && (i.pos = r.position); break } return d }, t.get_animation = function (t, e, i, r) { if (void 0 === i && (i = null), void 0 === r && (r = !0), void 0 === t.animations || 0 == t.animations.length) return console.error("There is no animations in gltf"), null; var n, a = null; if (i) { for (var s = 0, o = t.animations; s < o.length; s++)if ((n = o[s]).name === i) { a = n; break } if (!a) return console.error("Animation by the name", i, "not found in GLTF"), null } else a = t.animations[0]; var _ = {}, l = t.skins[0].joints; for (n = 0; n < l.length; n++)_[l[n]] = n; var u, h, c, d, m, p, f, g = 0, v = [], w = [], x = {}, y = 0, b = 0; for (g = 0; g < a.channels.length; g++)if (null != (u = a.channels[g]).target.node) if (null != _[c = u.target.node]) { switch (u.target.path) { case "rotation": d = "rot"; break; case "translation": d = "pos"; break; case "scale": d = "scl"; break; default: console.log("unknown channel path", u.path); continue }p = t.nodes[c].name.toLowerCase(), (!r || "rot" == d || -1 != p.indexOf("hip") && "pos" == d) && (null == (m = x[(h = a.samplers[u.sampler]).input]) && (x[h.input] = m = w.length, f = this.parse_accessor(h.input, t, e), w.push(f.data), y = Math.max(y, f.max[0]), b = Math.max(b, f.data.length)), v.push({ type: d, time_idx: m, joint_idx: _[c], interp: h.interpolation, data: this.parse_accessor(h.output, t, e).data })) } else console.log("Channel's target node is not a joint of the first skin."); return { time: y, frame_cnt: b, times: w, tracks: v } }, t.parse_b64_buffer = function (t) { var e = t.buffers[0]; if ("data:" != e.uri.substr(0, 5)) return null; for (var i = e.uri.indexOf("base64,") + 7, r = window.atob(e.uri.substr(i)), n = new ArrayBuffer(r.length), a = new DataView(n), s = 0; s < r.length; s++)a.setUint8(s, r.charCodeAt(s)); return n }, t }()).MODE_POINTS = 0, s.MODE_LINES = 1, s.MODE_LINE_LOOP = 2, s.MODE_LINE_STRIP = 3, s.MODE_TRIANGLES = 4, s.MODE_TRIANGLE_STRIP = 5, s.MODE_TRIANGLE_FAN = 6, s.TYPE_BYTE = 5120, s.TYPE_UNSIGNED_BYTE = 5121, s.TYPE_SHORT = 5122, s.TYPE_UNSIGNED_SHORT = 5123, s.TYPE_UNSIGNED_INT = 5125, s.TYPE_FLOAT = 5126, s.COMP_SCALAR = 1, s.COMP_VEC2 = 2, s.COMP_VEC3 = 3, s.COMP_VEC4 = 4, s.COMP_MAT2 = 4, s.COMP_MAT3 = 9, s.COMP_MAT4 = 16, s.TARGET_ARY_BUF = 34962, s.TARGET_ELM_ARY_BUF = 34963, function (t) { console.log(t) }) }(), e.geometry.shapes.flat_quad = new e.geometry.geometry_data, e.geometry.shapes.flat_quad.add_attribute("a_position_rw", { item_size: 3, data: new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0]) }), e.geometry.shapes.flat_quad.num_items = 12, e.geometry.mesh = e.define(function (t, e) { return t.update_bounds = function (t, e) { i.aabb.transform_mat4(this.bounds, this.geometry.aabb, t), this.bounds_sphere = this.geometry.bounds_sphere * e.scale_world[0] }, function (t) { t = t || {}, e.apply(this, [t]), this.geometry = t.geometry || null, this.material = t.material || null, this.has_multi_materials = !1, this.material.length > 0 && (this.has_multi_materials = !0), this.draw_offset = t.draw_offset || 0, t.draw_count ? this.draw_count = t.draw_count : null !== this.geometry && (this.draw_count = this.geometry.num_items), this.item_type = 4, this.flags = t.flags || 0 } }, e.renderable), e.geometry.mesh.triangles = e.define(function (t, i) { var r = 0; return t.add = function (t, e, i, n, a, s, o, _, l) { return r = this.ii, this.vertices[r++] = t, this.vertices[r++] = e, this.vertices[r++] = i, this.vertices[r++] = n, this.vertices[r++] = a, this.vertices[r++] = s, this.vertices[r++] = o, this.vertices[r++] = _, this.vertices[r++] = l, this.ii = r, this.geometry.attributes.a_position_rw.data_length = r, this.geometry.attributes.a_position_rw.needs_update = !0, this.draw_count = r / 3, this }, t.render_list = function () { this.geometry.attributes.a_position_rw.needs_update && e.geometry.geometry_data.calc_normals(this.geometry) }, function (t) { if (t = t || {}, i.apply(this, [t]), t.max_triangles = t.max_triangles || 1e3, this.vertices = new Float32Array(9 * t.max_triangles), this.geometry = e.geometry.geometry_data.create({ vertices: this.vertices, normals: new Float32Array(this.vertices.length) }), this.material = t.material || null, this.ii = 0, this.draw_offset = 0, this.draw_count = 0, this.item_type = 4, this.flags = t.flags || 0, t.triangles) for (var r = 0; r < t.triangles.length; r++)this.add.apply(this, t.triangles[r]) } }, e.renderable) }(_FM.fin, _FM.ge, _FM.math), function (t, e, i) { e.cui = e.define(function (i, r) { var n, a; return i.bubble_event = function (t, e, i) { t && (t[e] ? t[e].apply(t, i) : this.bubble_event(t.parent, e, i)) }, i.set_mouse_position = function (t, e, i) { if (t = Math.floor(t), e = Math.floor(e), this.mouse_x = t, this.mouse_y = e, this.mouse_dx = this.mouse_x - this.last_mouse_x, this.mouse_dy = this.mouse_y - this.last_mouse_y, this.mouse_down_dx = this.mouse_x - this.mouse_down_x, this.mouse_down_dy = this.mouse_y - this.mouse_down_y, this.mouse_down_delta = Math.sqrt(this.mouse_down_dx * this.mouse_down_dx + this.mouse_down_dy * this.mouse_down_dy), this.mouse_delta = Math.sqrt(this.mouse_dx * this.mouse_dx + this.mouse_dy * this.mouse_dy), i === this.mouse_button && 0 === this.mouse_delta) return this.last_mouse_x = t, this.last_mouse_y = e, 1 === i && (this.mouse_down_x = t, this.mouse_down_y = e), !1; if (this.mouse_is_moving = !1, 0 !== this.mouse_delta && (this.mouse_is_moving = !0), this.mouse_click = !1, this.mouse_down && 0 === i && !this.last_mouse_draging && (this.mouse_is_moving || 0 !== this.mouse_down_delta || (this.mouse_click = !0, this.mouse_down = !1)), this.mouse_draging = !1, this.mouse_down && 0 !== this.mouse_down_delta && (this.mouse_draging = !0), 1 !== i || this.mouse_down || this.mouse_draging ? 0 === i && (this.mouse_down = !1) : (this.mouse_down = !0, this.mouse_down_x = t, this.mouse_down_y = e), this.last_mouse_x = t, this.last_mouse_y = e, this.mouse_button = i, this.mouse_down && !this.mouse_draging && (this.mouse_node_id = 0, this.mouse_hit_node(this.doc.body, this.doc)), 0 !== this.mouse_node_id) { var r = this.doc.nodes[this.mouse_node_id]; r && (this.mouse_draging ? r.on_mouse_draging ? r.on_mouse_draging(r, this.mouse_dx, this.mouse_dy) : this.bubble_event(r.parent, "on_mouse_draging", [r, this.mouse_dx, this.mouse_dy]) : this.mouse_down && !this.mouse_draging ? r.on_mouse_down && r.on_mouse_down(r, this.mouse_down_x, this.mouse_down_y) : this.mouse_click && (r.on_mouse_click ? r.on_mouse_click(r, this.mouse_x, this.mouse_y) : this.bubble_event(r.parent, "on_mouse_click", [r, this.mouse_x, this.mouse_y]))) } return this.last_mouse_draging = this.mouse_draging, this.mouse_draging = !1, 0 === this.mouse_button && (this.mouse_node_id = 0), !0 }, i.render_node = function (t, e, i) { if (e.render ? e.render(t, e, this, this.components[e.type]) : this.components[e.type].render(t, e, this), e.actual_height = e._height, e.actual_width = e._width, e.gx = e._x + i.gx, e.gy = e._y + i.gy, e.children) { var r; "hidden" === e.styles.overflow && (t.beginPath(), t.rect(e.styles.padding_left, e.styles.padding_top, e._width - (e.styles.padding_left + e.styles.padding_right), e._height - (e.styles.padding_top + e.styles.padding_bottom)), t.clip()), t.translate(-e.scroll_left, -e.scroll_top); for (var n = e.styles.padding_top, a = e.styles.padding_left, s = 0, o = 0; o < e.children.length; o++)(r = e.children[o]).styles.visibled && (a + r._width + e.styles.padding_right > e._width && (a = e.styles.padding_left, n += s), "absolute" === r.styles.position && (a = 0, n = 0), a += r._left + r.styles.margin_left, n += r._top + r.styles.margin_top, t.save(), t.translate(a, n + r.styles.margin_top), r._x = a - e.scroll_left, r._y = n + r.styles.margin_top - e.scroll_top, a += this.render_node(t, r, e), t.restore(), s = r.actual_height + r.styles.margin_bottom) } return e.initiated = !0, e.actual_width }, i.mouse_hit_node = function (t, e) { if (t.styles.visibled && this.mouse_x > t.gx && this.mouse_x < t.gx + t.actual_width && this.mouse_y > t.gy && this.mouse_y < t.gy + t.actual_height && (t.styles.mouse_events && (this.mouse_node_id = t.uuid), t.children)) for (var i = 0; i < t.children.length; i++)this.mouse_hit_node(t.children[i], t) }, i.get_node = function (t) { return this.doc.nodes_names[t] }, i.init_node = function (t, i) { if (!t.initiated) { t.uuid = e.guidi(), this.doc.nodes[t.uuid] = t, t.name = t.name || "n" + t.uuid, this.doc.nodes_names[t.name] = t, t.document = i.document ? i.document : i, t.scroll_left = t.scroll_left || 0, t.scroll_top = t.scroll_top || 0, t.type = t.type || "block", t.left = t.left || "0px", t.top = t.top || "0px", t.styles = t.styles || {}, t.styles.padding && (void 0 === t.styles.padding_left && (t.styles.padding_left = t.styles.padding), void 0 === t.styles.padding_right && (t.styles.padding_right = t.styles.padding), void 0 === t.styles.padding_top && (t.styles.padding_top = t.styles.padding), void 0 === t.styles.padding_bottom && (t.styles.padding_bottom = t.styles.padding)), this.components[t.type].init && this.components[t.type].init(t, i, this), t.height = t.height || "100%", t.width = t.width || "100%"; var r = i._width - (i.styles.padding_left + i.styles.padding_right), a = i._height - (i.styles.padding_top + i.styles.padding_bottom); for (var s in t.left.indexOf("%") > 0 ? t._left = parseFloat(t.left) / 100 * r : t._left = parseFloat(t.left), t.top.indexOf("%") > 0 ? t._top = parseFloat(t.top) / 100 * a : t._top = parseFloat(t.top), t.width.indexOf("%") > 0 ? t._width = parseFloat(t.width) / 100 * r : t._width = parseFloat(t.width), t.parent = i, t.height.indexOf("%") > 0 ? t._height = parseFloat(t.height) / 100 * a : t._height = parseFloat(t.height), t._x = 0, t._y = 0, this.styles) void 0 === t.styles[s] && (t.styles[s] = this.styles[s]); if (t.on_init && t.on_init(t, i), t.styles.background_color.join && (n.images_loader.load(t.styles.background_color[0], [n.background_pattern_creator, t, this, t.styles.background_color[1] || "repeat", t.styles.background_color[2]]), t.styles.background_color = "transparent"), t.initiated = !0, t.children) for (var o = 0; o < t.children.length; o++)t.children[o].index = o, this.init_node(t.children[o], t) } }, i.display_document = function (t) { if (t ? this.doc = t : t = this.doc, t._width = this.canv.width, t._height = this.canv.height, t.gx = 0, t.gy = 0, !t.body.initiated) { for (var e in n.components) this.components[e] = n.components[e]; t.styles = this.styles, this.doc.nodes = {}, this.doc.nodes_names = {}, this.init_node(t.body, t) } this.canv.ctx.clearRect(0, 0, this.canv.width, this.canv.height), this.render_node(this.canv.ctx, t.body, t), this.canv.ctx.fillStyle = "rgba(10,10,10,0.37)", this.canv.ctx.fillRect(this.mouse_x - 3, this.mouse_y - 3, 6, 6) }, (n = function (i) { i = i || {}, t.merge_object({ width: 512, height: 512 }, i, !0), this.components = {}, this.canv = e.create_canvas(i.width, i.height), this.mouse_node_id = 0, this.mouse_x = -10, this.mouse_y = -10, this.last_mouse_x = 0, this.last_mouse_y = 0, this.mouse_dx = 0, this.mouse_dy = 0, this.styles = { font: "arial", font_size: 12, text_valign: "top", text_align: "left", background_color: "transparent", background_alpha: 1, foreground_color: "black", margin_left: 0, margin_right: 0, margin_top: 0, margin_bottom: 0, padding_left: 0, padding_right: 0, padding_top: 0, padding_bottom: 0, overflow: "visible", position: "relative", mouse_events: !0, visibled: !0, border_size: 0, border_type: "outset", border_color: "transparent", focus_rect: !1 }, this.doc = null }).load_images = {}, n.load_image = function (t) { if (n.load_images[t]) return n.load_images[t]; var e = new Image; return e.src = t, n.load_images[t] = e, e }, n.background_pattern_creator = (a = e.create_canvas(1, 1), function (t, e, i, r, n) { n = n || 64, a.set_size(n, n), a.ctx.drawImage(t, 0, 0, n, n), e.styles.background_color = i.canv.ctx.createPattern(a, r), i.needs_update = !0 }), n.images_loader = new e.bulk_image_loader(5), n.images_loader.onload = function (t, e) { var i = e[0]; e[0] = t, i.apply(this, e), n.images_loader.free(t) }, n.components = {}, n.define_component = function (t, e) { this.components[t] = e, e.ui = this }, n.define_component("block", { render: function (t, e, i) { "transparent" !== e.styles.background_color && (t.fillStyle = e.styles.background_color, t.globalAlpha = e.styles.background_alpha, t.fillRect(0, 0, e._width, e._height)), t.globalAlpha = 1, e.styles.border_size > 0 && (t.lineWidth = e.styles.border_size, t.strokeStyle = e.styles.border_color, t.strokeRect(0, 0, e._width, e._height), "outset" === e.styles.border_type ? (t.strokeStyle = "rgba(110,110,110,0.5)", t.beginPath(), t.moveTo(0, e._height), t.lineTo(0, 0), t.lineTo(e._width, 0), t.stroke(), t.strokeStyle = "rgba(50,50,50,0.5)", t.beginPath(), t.moveTo(0, e._height), t.lineTo(e._width, e._height), t.lineTo(e._width, 0), t.stroke()) : "inset" === e.styles.border_type && (t.strokeStyle = "rgba(50,50,50,0.5)", t.beginPath(), t.moveTo(0, e._height), t.lineTo(0, 0), t.lineTo(e._width, 0), t.stroke(), t.strokeStyle = "rgba(110,110,110,0.5)", t.beginPath(), t.moveTo(0, e._height), t.lineTo(e._width, e._height), t.lineTo(e._width, 0), t.stroke())), t.lineWidth = 1, e.uuid === i.mouse_node_id && i.mouse_down && e.styles.focus_rect && (t.fillStyle = "rgba(0,0,0,0.25)", t.fillRect(0, 0, e._width, e._height)) } }), n.define_component("scroll-panel", { init: function (t, e, i) { t.styles.overflow = "hidden", t.on_mouse_draging = function (t, e, i) { this.scroll_top -= i, this.scroll_top = Math.max(this.scroll_top, 0) } }, render: function (t, e, i) { n.components.block.render(t, e, i) } }), n.define_component("text", { init: function (t, e, i) { void 0 === t.height && (t.height = "20px"), void 0 === t.styles.mouse_events && (t.styles.mouse_events = !1), void 0 === t.styles.background_color && (t.styles.background_color = "transparent") }, render: function (t, e, i) { t.font = e.styles.font_size + "px " + e.styles.font, e._text !== e.text && (e._text_m = t.measureText(e.text), e._text = e.text, e._height = Math.max(e._height, e._text_m.actualBoundingBoxDescent + e.styles.padding_top + e.styles.padding_bottom), e._width = Math.max(e._width, e._text_m.width + e.styles.padding_left + e.styles.padding_right)); var r = e.styles.padding_left, a = e.styles.padding_top; n.components.block.render(t, e, i), t.textAlign = e.styles.text_align, t.textBaseline = e.styles.text_valign, t.fillStyle = e.styles.foreground_color, "center" === e.styles.text_align && (r += .5 * e._width), "middle" === e.styles.text_valign && (a += .5 * e._height + .35 * e._text_m.actualBoundingBoxDescent), t.fillText(e.text, r, a) } }), n.define_component("button", { init: function (t, e, i) { t.styles.text_align = "center", t.styles.text_valign = "middle", void 0 === t.styles.border_size && (t.styles.border_size = 3) }, render: function (t, e, i) { i.mouse_down && e.uuid === i.mouse_node_id ? (e.styles.border_type = "inset", e.styles.padding_left = 2, e.styles.padding_top = 2) : (e.styles.padding_left = 0, e.styles.padding_top = 0, e.styles.border_type = "outset"), n.components.text.render(t, e, i) } }), n.define_component("hslider", { init: function (t, e, i) { t.value = t.value || 50, t.min = t.min || 0, t.max = t.max || 100, void 0 === t.height && (t.height = "20px"), t.label_padding = t.label_padding || 0, t.children = [{ on_init: function (t, e) { e.trail_width = e._width - e.label_padding - 10, t.parent.per = (t.parent.value - t.parent.min) / (t.parent.max - t.parent.min), t._left = e.trail_width * e.per }, width: "10px", styles: { background_color: "rgba(30,30,30,0.75)", position: "absolute", margin_top: 0, border_size: 1 }, on_mouse_draging: function (t, e, i) { t._left += e, t._left < 0 && (t._left = 0), t._left > t.parent.trail_width && (t._left = t.parent.trail_width), t.parent.per = t._left / t.parent.trail_width, t.parent.value = t.parent.min + (t.parent.max - t.parent.min) * t.parent.per } }] }, render: function (t, e, i) { n.components.block.render(t, e, i), t.fillStyle = "rgba(40,40,40,0.5)", t.fillRect(0, .5 * e._height - 2, e.trail_width + 10, 6), e.label_padding > 0 && (t.textBaseline = "middle", t.font = "12px " + e.styles.font, t.textAlign = "right", t.fillStyle = e.styles.foreground_color, t.fillText(parseInt(e.value), e._width - 2, .5 * e._height)) } }), n.define_component("checkbox", { init: function (t, e, i) { void 0 === t.checked && (t.checked = !1), t.styles.text_valign = "middle", void 0 === t.height && (t.height = "20px"), t.on_mouse_down = function () { this.checked = !this.checked, this.on_checked && this.on_checked(this.checked) } }, render: function (t, e, i) { e.styles.padding_left = e._height, n.components.text.render(t, e, i), t.strokeStyle = e.styles.foreground_color, t.strokeRect(4, 4, e._height - 8, e._height - 8), e.checked && (t.fillStyle = e.styles.foreground_color, t.fillRect(6, 6, e._height - 12, e._height - 12)) } }), n.define_component("listbox", { init: function (t, e, i) { n.components["scroll-panel"].init(t, e, i), t.item_height = t.item_height || 20, t.item_count = 50, console.log("node", t) }, render: function (t, e, i) { n.components["scroll-panel"].render(t, e, i), t.textAlign = "left", t.textBaseline = "middle"; var r, a = 0, s = 0; for (t.fillStyle = e.styles.foreground_color; a < e.items.length && (r = e.items[a++], t.fillText(r, 2, s + e.styles.font_size), !((s += e.item_height) > e._height));); } }), n.define_component("label-field", { init: function (t, e, i) { t.height = t.height || "25px", t.field.width = t.field_size || "60%", t.field.styles = { margin_top: 2 }, t.styles.border_size = 1, t.children = [{ type: "text", width: "40%", styles: { text_valign: "middle", font_size: 10 }, text: t.label }, t.field] }, render: function (t, e, i) { n.components.block.render(t, e, i) } }), n }), e.cui.mesh = e.define(function (t, r) { return t.on_render = function (t) { this.ui.needs_update && (this.update_document(), this.ui.needs_update = !1), this.is_picked && (t.is_locked = !0, this.mouse_controller.set_mouse_ray(), 0 !== this.mouse_controller.mouse_delta && i.utils.ray_plane_intersection(this.mouse_int_point, this.mouse_controller.mouse_ray_start, this.mouse_controller.mouse_ray_end, this.world_position, this.fw_vector) && this.set_mouse_position(this.mouse_int_point, this.mouse_controller.mouse_buttons), 0 === this.mouse_controller.mouse_buttons && (this.is_picked = !1, t.is_locked = !1, this.ui.set_mouse_position(-10, -10, 0) && this.update_document())) }, t.set_mouse_position = function (t, e) { this.mesh_version !== this.version && (this.mesh_version = this.version, i.mat4.inverse(this.imatrix_world, this.matrix_world)), i.vec3.transform_mat4(t, t, this.imatrix_world), t[0] = t[0] / this.width, t[1] = t[1] / this.height, t[0] += .5, t[1] += .5, t[1] = 1 - t[1], this.ui.set_mouse_position(t[0] * this.ui.canv.width, t[1] * this.ui.canv.height, e) && this.update_document() }, t.update_bounds = function (t, e) { i.aabb.transform_mat4(this.bounds, this.geometry.aabb, t), this.bounds_sphere = this.geometry.bounds_sphere * e.scale_world[0] }, t.update_document = function () { this.ui.display_document(), this.material.texture.source = this.ui.canv, this.material.texture.needs_update = !0, this.on_document_update.params[0] = this.ui, this.on_document_update.trigger_params() }, t.set_document = function (t) { this.ui.display_document(t), this.material.texture.needs_update = !0 }, function (t) { t = t || {}, r.apply(this, [t]), this.width = t.width / 100, this.height = t.height / 100, this.mouse_controller = t.mouse_controller, this.geometry = e.geometry.shapes.plane({ width: this.width, height: this.height }), this.material = new e.shading.material({ ambient: [1, 1, 1], specular: [0, 0, 0], transparent: .95 }), this.ui = new e.cui(t), this.material.texture = e.webgl.texture.from_size(t.width, t.height), this.material.texture.source = this.ui.canv, this.material.texture.needs_update = !0, this.material.flags += 2048, this.material.texture.parameters[10242] = 33071, this.material.texture.parameters[10243] = 33071, this.material.texture.enable_linear_interpolation(), this.ui.canv.ctx.transform(1, 0, 0, -1, 0, this.ui.canv.height), this.draw_offset = 0, this.draw_count = this.geometry.num_items, this.item_type = 4, this.flags = t.flags || 0, this.mesh_version = -1, this.imatrix_world = i.mat4(), this.flags += 2048, this.mouse_int_point = i.vec3(), this.on_document_update = new e.event(this, [null]) } }, e.renderable) }(_FM.fin, _FM.ge, _FM.math), function t(e, r, n) { r.renderer = r.define(function (a, s) { var o, _ = r.webgl.shader.create_chunks_lib("/*chunk-global-render-system-lighting*/\n\n<?for(var i= 0;i<param('fws_num_lights');i++) {?>\n\tuniform mat4 u_light_material_rw<?=i?>;\n\tuniform mat4 u_light_matrix_rw<?=i?>;\n<?}?>\n\n\n\n\n\nfloat fws_distance_to_light;\nfloat fws_lambertian;\nfloat fws_specular;\nfloat fws_attenuation;\nfloat fws_intensity;\nfloat fws_spot_light_calc;\nfloat fws_spot_theta;\nfloat fws_spot_light_status;\n\nvec3 fws_total_light;\nvec3 fws_light_value;\n\nvec3 fws_lighting(\n\tmat4 fws_object_material,\n\tmat4 fws_light_material,\n\tvec3 fws_vertex_position, \n\tvec3 fws_vertex_normal,\n\tvec3 fws_direction_to_eye,\n\tvec3 fws_direction_to_light, vec3 fws_direction_from_light) {\n\n\tfws_distance_to_light = length(fws_direction_to_light);\n\n\t\n\n\tfws_direction_to_light = normalize(fws_direction_to_light);\n\tfws_lambertian = max(dot(fws_direction_to_light, fws_vertex_normal), 0.0);\n\n\n\tfws_lambertian =dot(fws_direction_to_light, fws_vertex_normal);\n\n\tfws_intensity = fws_light_material[0].w;\n\t\n\tfws_attenuation = (fws_light_material[3].x + fws_light_material[3].y * fws_distance_to_light\n\t\t+ fws_light_material[3].z * (fws_distance_to_light * fws_distance_to_light)) + fws_light_material[3].w;\n\n\tfws_spot_light_status = step(0.000001, fws_light_material[1].w);\t\n\tfws_spot_theta = dot(fws_direction_to_light, fws_direction_from_light);\n\tfws_spot_light_calc = clamp((fws_spot_theta - fws_light_material[2].w) / (fws_light_material[1].w - fws_light_material[2].w), 0.0, 1.0);\n\tfws_intensity *= (fws_spot_light_status * (step(fws_light_material[1].w, fws_spot_theta) * fws_spot_light_calc))\n\t\t+ abs(1.0 - fws_spot_light_status);\n\n\t\n\tfws_specular = pow(max(dot(normalize(fws_direction_to_light.xyz + fws_direction_to_eye), fws_vertex_normal), 0.0), fws_object_material[2].w) * fws_lambertian;\n\tfws_specular *= fws_intensity * step(0.0, fws_lambertian);\n\t\n\t\n\n\n\tfws_light_value = (fws_light_material[0].xyz * fws_object_material[0].xyz) +\n\t\t(fws_object_material[1].xyz * fws_lambertian * fws_light_material[1].xyz * fws_intensity) +\n\t\t(fws_object_material[2].xyz * fws_specular * fws_light_material[2].xyz);\n\n\t\tfws_light_value=max(fws_light_value,0.0);\n\n\n\t\t\n\treturn (fws_light_value / fws_attenuation);\n\n\n}\n\n\nvec3 get_render_system_lighting(\n\tmat4 object_material_rw,\n\tvec3 fws_vertex,\n\tvec3 fws_normal,\n\tvec3 fws_direction_to_eye){\n\n\tfws_total_light=vec3(0.0);\n\t<?for (var i = 0;i < param('fws_num_lights');i++) {?>\n\t\t\tfws_total_light += fws_lighting(\n\t\t\t\tobject_material_rw,\n\t\t\t\tu_light_material_rw<?=i?>,\n\t\t\t\tfws_vertex, fws_normal, fws_direction_to_eye,\n\t\t\t\tu_light_matrix_rw<?=i?>[3].xyz - fws_vertex,\n\t\t\t u_light_matrix_rw<?=i?>[2].xyz);\n\t<?}?>\n\n\treturn fws_total_light;\n}\n\n\n\n\n/*chunk-global-render-system-fog-effect*/\n\nuniform vec3 u_fog_params_rw;\nuniform vec4 u_fog_color_rw;\nfloat get_linear_fog_factor(float eye_dist)\n{  \n   return clamp( (u_fog_params_rw.y - eye_dist) /\n            (u_fog_params_rw.y - u_fog_params_rw.x ), 0.0, 1.0 );\n}\n\nvec4 mix_fog_color(vec4 frag_color){\n\tfloat fog_density=0.0005;\n    const float LOG2=1.442695;\n    float z=gl_FragCoord.z/gl_FragCoord.w;\n    float fog_factor=exp2(-fog_density*fog_density*z*z*LOG2);\n    fog_factor=clamp(fog_factor,0.0,1.0);\n\treturn mix(u_fog_color_rw,frag_color,fog_factor);\n}\n\n\n/*chunk-textured-quad*/\nattribute vec2 a_position_rw;\nuniform vec4 u_pos_size;\nconst vec2 madd=vec2(0.5,0.5);\nvarying vec2 v_uv_rw;\nvoid vertex()\n{\ngl_Position = vec4((a_position_rw.xy*u_pos_size.zw)+u_pos_size.xy,0.0,1.0);\t\n\tv_uv_rw = a_position_rw.xy*madd+madd;  \n\tv_uv_rw.y=1.0-v_uv_rw.y;\n\n\n}\n<?=chunk('precision')?>\nuniform sampler2D u_texture_rw;\nvarying vec2 v_uv_rw;\nvoid fragment(void)\n{\t\ngl_FragColor = texture2D(u_texture_rw, v_uv_rw);\t\n}\n\n/*chunk-render-shadow-map*/\n\n<?=chunk('precision')?>\nuniform sampler2D u_texture_rw;\nvarying vec2 v_uv_rw;\nvoid fragment(void) {\t\t\t\n\n\tif(texture2D(u_texture_rw, v_uv_rw).a<0.02) discard;\t\n\tgl_FragColor=vec4(0.85);\t\n}\n\n\n/*chunk-receive-shadow*/\nuniform mat4 u_light_camera_matrix_rw;\nvarying vec4 v_shadow_light_vertex_rw;\n\nvoid vertex(){\n\tsuper_vertex();\t\n\tv_shadow_light_vertex_rw = u_light_camera_matrix_rw * v_position_rw;\n}\n\n\n<?=chunk('precision')?>\n<?=chunk('shadow-sampling')?>\n\n\nvarying vec3 v_normal_rw;\nvarying vec4 v_shadow_light_vertex_rw;\nuniform sampler2D u_texture_rw;\nuniform sampler2D u_shadow_map_rw;\nuniform vec4 u_shadow_params_rw;\nuniform vec4 u_shadow_attenuation_rw;\n\nuniform vec3 u_light_pos_rw;\nuniform vec3 u_light_dir_rw;\n\nvarying vec2 v_uv_rw;\nvarying vec4 v_position_rw;\n\n\nfloat get_shadow_sample() {\t\t\n\n\n\n\tfloat f=texture2D(u_texture_rw, v_uv_rw).a;\t\t\n\t\n\n\tvec3 shadow_map_coords =v_shadow_light_vertex_rw.xyz/v_shadow_light_vertex_rw.w;\n\tf*=step(-(dot(v_normal_rw,normalize(u_light_pos_rw - v_position_rw.xyz))),0.0);\n\n\tshadow_map_coords.xyz = shadow_map_coords.xyz * 0.5 + 0.5;\n\n\tf*=step(shadow_map_coords.x,1.0)*step(shadow_map_coords.y,1.0)*step(shadow_map_coords.z,1.0);\n\tf*=step(0.0,shadow_map_coords.x)*step(0.0,shadow_map_coords.y)*step(0.0,shadow_map_coords.y);\n\t\n\n\tvec3 fws_direction_to_light=(u_light_pos_rw.xyz-v_position_rw.xyz);\t\t\t\n\n\t\n\tfloat fws_distance_to_light=length(fws_direction_to_light)*0.99;\n\tfws_direction_to_light=normalize(fws_direction_to_light);\n\n\t\t\n\tfloat fws_spot_theta = dot(fws_direction_to_light,u_light_dir_rw);\n\tfloat fws_spot_light_calc = clamp((fws_spot_theta) / u_shadow_params_rw.w, 0.0, 1.0);\n\t\n\tf*=(step(1.0,fws_spot_light_calc));\n\n\t\n\tfloat fws_attenuation = (u_shadow_attenuation_rw.y * fws_distance_to_light\n\t\t+ u_shadow_attenuation_rw.z * (fws_distance_to_light * fws_distance_to_light));\n\t\t\n\n\n\n\tf/=(max(fws_attenuation,0.0));\n\n\tf*=(u_shadow_attenuation_rw.w/fws_distance_to_light);\n\n\tf*=(u_shadow_params_rw.x*(u_shadow_attenuation_rw.w/fws_distance_to_light));\n\t\n\tf=clamp(f,0.0,0.8);\n\n\treturn  ((f-sample_shadow_map_pcf(u_shadow_map_rw, shadow_map_coords.xy,\n\tshadow_map_coords.z-u_shadow_params_rw.z ,vec2(u_shadow_params_rw.y))*f)\n\t*u_shadow_params_rw.x);\n\n\t\t\n}\n\n\nvoid fragment(void) {\t\ngl_FragColor = vec4((get_shadow_sample()));\n}"); a.gl_enable = function (t) { return 1 !== this.gl_states_flags[t] && (this.gl_states_flags[t] = 1, this.gl.enable(t), !0) }, a.gl_disable = function (t) { return 0 !== this.gl_states_flags[t] && (this.gl_states_flags[t] = 0, this.gl.disable(t), !0) }, a.gl_blendFunc = function (t, e) { return (this.gl_states.blendFunc0 !== t || this.gl_states.blendFunc1 !== e) && (this.gl_states.blendFunc0 = t, this.gl_states.blendFunc1 = e, this.gl.blendFunc(t, e), !0) }, a.gl_blendEquation = function (t) { this.gl_states.blendEQuation !== t && (this.gl_states.blendEQuation = t, this.gl.blendEquation(t)) }, a.gl_depthMask = function (t) { t !== this.gl_states.depthMask && (this.gl_states.depthMask = t, this.gl.depthMask(t)) }, a.gl_depthFunc = function (t) { t !== this.gl_states.depthFunc && (this.gl_states.depthFunc = t, this.gl.depthFunc(t)) }, a.gl_cullFace = function (t) { t !== this.gl_states.cullFace && (this.gl_states.cullFace = t, this.gl.cullFace(t)) }, a.gl_bindFramebuffer2 = function (t, e) { return e !== this.gl_states.framebuffer && (this.gl_states.framebuffer = e, this.gl.bindFramebuffer(t, e), !0) }, a.set_canvas_size = function (t, e) { this.render_width = t * this.pixel_ratio, this.render_height = e * this.pixel_ratio, this.canvas.width = this.render_width, this.canvas.height = this.render_height; var i = 0; for (i = 0; i < this.post_processes.length; i++)this.post_processes[i].resize(this.render_width, this.render_height); for (i = 0; i < this.render_targets.length; i++)this.render_targets[i].resize(this.render_width * this.render_targets[i].ratio, this.render_height * this.render_targets[i].ratio); this.on_canvas_size(this.render_width, this.render_height) }, a.on_canvas_size = function (t, e) { }, a.clear_screen = function () { return this.gl.clear(16640), this }, a.set_default_viewport = function () { return null === this.default_render_target ? (this.gl.bindFramebuffer(36160, this.frame_buffer_layer), null !== this.active_camera && this.gl.viewport(this.vp_left * this.render_width, this.vp_top * this.render_height, this.vp_width * this.render_width, this.vp_height * this.render_height)) : this.default_render_target.bind(), this }, a.use_geometry = function () { var t = null, e = 0, i = null, n = r.geometry.geometry_data; return a.activate_geometry_index_buffer = function () { var t, e, i, r, s; return a.reset_wireframe_index_buffer = function (a, _) { var l = []; for (l.length = 0, t = 0; t < _ - 1; t += 3)i = t + 0, r = t + 1, s = t + 2, l[e = l.length] = i, l[e + 1] = r, l[e + 2] = r, l[e + 3] = s, l[e + 4] = s, l[e + 5] = i; this.wireframe_index_buffer || (this.wireframe_index_buffer = o.gl_buffers.get(a)), a.bindBuffer(34963, this.wireframe_index_buffer), a.bufferData(34963, n.create_index_data(l), 35048), l.length = 0 }, a.bind_default_wireframe_indices = function () { this.wireframe_index_buffer || (this.reset_wireframe_index_buffer(null, 1e6), this.compile_attribute(this.default_color_attribute)), this.gl.bindBuffer(34963, this.wireframe_index_buffer) }, function (a, _) { if (a.index_data) { var l = this.gl; return a.index_needs_update && (null === a.index_buffer && (a.index_buffer = o.gl_buffers.get(l)), l.bindBuffer(34963, a.index_buffer), l.bufferData(34963, a.index_data, 35048)), _ ? a.index_needs_update || !a.w_index_data ? (function (a) { if (null !== a.index_buffer) for (a.w_index_data ? a.w_index_data.length < 2 * a.index_data.length && (a.w_index_data = ggeometry_data.create_index_data(2 * a.index_data.length)) : a.w_index_data = n.create_index_data(2 * a.index_data.length), e = 0, t = 0; t < a.index_data.length; t += 3)i = a.index_data[t + 0], r = a.index_data[t + 1], s = a.index_data[t + 2], a.w_index_data[e] = i, a.w_index_data[e + 1] = r, a.w_index_data[e + 2] = r, a.w_index_data[e + 3] = s, a.w_index_data[e + 4] = s, a.w_index_data[e + 5] = i, e += 6 }(a), a.w_index_buffer || (a.w_index_buffer = o.gl_buffers.get(l)), l.bindBuffer(34963, a.w_index_buffer), l.bufferData(34963, a.w_index_data, 35048)) : l.bindBuffer(34963, a.w_index_buffer) : l.bindBuffer(34963, a.index_buffer), a.index_needs_update = !1, !0 } return !!_ && (this.gl.bindBuffer(34963, this.wireframe_index_buffer), !0) } }(), a.update_geomerty_attribute = function (t, e) { if (null === e) return this.gl.disableVertexAttribArray(t), -1; var i = this.gl, r = 0; return i.enableVertexAttribArray(t), !0 === e.needs_update ? (null === e.buffer && (e.buffer = o.gl_buffers.get(i)), i.bindBuffer(34962, e.buffer), i.bufferData(34962, e.data, e.buffer_type, e.data_offset, e.data_length), r = 1, e.version += 1, e.needs_update = !1) : null !== e.buffer && i.bindBuffer(34962, e.buffer), i.vertexAttribPointer(t, e.item_size, e.data_type, !1, e.stride, e.offset), i.ANGLE_instanced_arrays.vertexAttribDivisorANGLE(t, e.divisor), r }, a.compile_geometry = (a.compile_attribute = function (t) { if (!t.compiled) return t.stride = t.stride || 0, t.offset = t.offset || 0, t.needs_update = t.needs_update || !1, t.array = t.array || null, t.data_type = t.data_type || 5126, t.buffer_type = t.buffer_type || 35044, t.version = t.version || 1, t.divisor = t.divisor || 0, t.array = t.array || null, t.data_offset = t.data_offset || 0, t.data_length = t.data_length || 0, t.data && (t.data_length = t.data.length, null !== t.buffer && void 0 !== t.buffer || (t.buffer = o.gl_buffers.get(this.gl)), this.gl.bindBuffer(34962, t.buffer), this.gl.bufferData(34962, t.data, t.buffer_type, t.data_offset, t.data_length)), t.compiled = !0, t }, a.use_geometry_attribute = function (t, e) { this.compile_attribute(e), this.update_geomerty_attribute(t, e) }, function (t, e) { if (!e.compiled) { for (aid in this.wireframe_index_buffer || (this.reset_wireframe_index_buffer(t, 1e6), this.compile_attribute(this.default_color_attribute)), e.attributes) this.compile_attribute(e.attributes[aid]); e.attributes.a_color_rw = e.attributes.a_color_rw || this.default_color_attribute, e.index_data && (null === e.index_buffer && (e.index_buffer = o.gl_buffers.get(t)), t.bindBuffer(34963, e.index_buffer), t.bufferData(34963, e.index_data, 35048)), e.compiled = !0 } }), function (r) { if (r.compiled || this.compile_geometry(this.gl, r), (t = this.active_shader).used_geo_id !== r.uuid) for (t.used_geo_id = r.uuid, e = 0; e < t.all_attributes.length; e++)i = t.all_attributes[e], r.attributes[i.name] ? this.update_geomerty_attribute(i.location, r.attributes[i.name]) : this.update_geomerty_attribute(i.location, null) } }(), a.use_shader = function (t, e) { var i; return this.last_shader_id != t.uuid && (null !== this.active_shader && this.active_shader.exit(this), t.compiled || r.webgl.shader.compile(this.gl, t, this.shader_parameters), this.gl.useProgram(t.program), t.enter(this), (i = t.uniforms.u_fog_params_rw) && (i.params[i.params_length] = this.fog_params, i.func.apply(t.gl, i.params)), (i = t.uniforms.u_fog_color_rw) && (i.params[i.params_length] = this.u_fog_color, i.func.apply(t.gl, i.params)), (i = t.uniforms.u_timer_rw) && (i.params[i.params_length] = this.timer, i.func.apply(t.gl, i.params)), this.active_shader = t, this.active_shader.camera_version = -1, this.last_shader_id = t.uuid, this.active_shader.used_geo_id = -100, !0) }; var l, u, h, c, d, m, f, g, v, w, x, y, b, E, T, A, z, M, L, I, k, S, R, F, N, C, G, P, j, O, D, q, U, B, H, X, K, Z, V, Y, W, Q, $, J, tt, et, it, rt, nt, at, st, ot, _t, lt, ut, ht, ct, dt = [34070, 34069, 34072, 34071, 34074, 34073]; a.update_texture = function (t) { var e = this.gl; if (null === t.gl_texture && (t.gl_texture = o.gl_textures.get(e)), e.bindTexture(t.target, t.gl_texture), 34067 === t.target) for (i = 0; i < t.source.length; i++)e.texImage2D(dt[i], 0, t.format, t.format, texture.format_type, t.source[i]); else null !== t.source && (t.source.src || t.source.getContext) ? e.texImage2D(t.target, 0, t.format, t.format, t.format_type, t.source) : e.texImage2D(t.target, 0, t.format, t.width, t.height, 0, t.format, t.format_type, t.source); for (p in t.parameters) e.texParameteri(t.target, p, t.parameters[p]); return t.generate_mipmap && e.generateMipmap(t.target), e.bindTexture(t.target, null), t.needs_update = !1, t.free_source(), t }, a.use_texture = function (t, e) { null !== t ? (t.needs_update && this.update_texture(t), null !== t.gl_texture ? (t.last_used_time = this.timer, this.texture_slots[e] !== t.uuid && (this.texture_slots[e] = t.uuid, this.gl.activeTexture(33984 + e), this.gl.bindTexture(t.target, t.gl_texture))) : this.use_texture(this.default_texture, e)) : this.use_texture(this.default_texture, e) }, a.use_direct_texture = function (t, e) { this.gl.activeTexture(33984 + e), this.gl.bindTexture(t.target, t.gl_texture) }, a.draw_textured_quad = (l = { item_size: 2, data: new Float32Array([-1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1]) }, u = r.webgl.shader.parse(_["textured-quad"]), h = n.vec4(), function (t, e, i, r, n) { h[0] = e, h[1] = i, h[2] = r, h[3] = n, this.use_geometry_attribute(0, l), this.use_shader(u), u.set_uniform("u_pos_size", h), this.gl_disable(2929), this.gl_disable(2884), this.use_texture(t, 0), this.gl.drawArrays(4, 0, 6) }), a.draw_full_quad = function () { this.gl.bindBuffer(34962, this.full_quad), this.gl.enableVertexAttribArray(0), this.gl.vertexAttribPointer(0, 2, 5126, !1, 0, 0), this.gl.drawArrays(4, 0, 6) }, a.apply_post_processes = function () { this.post_process_input = this.default_render_target.color_texture, this.post_target = this.default_render_target.swap, this.gl_disable(2929); for (var t = 0; t < this.post_processes.length; t++)post_process = this.post_processes[t], post_process.enabled && (post_process.apply(this, this.post_process_input, this.post_target), this.post_process_input = this.post_target.color_texture, this.post_target = this.post_target.swap); this.output_to_screen && (this.render_target_id = -1, this.gl.bindFramebuffer(36160, null), this.use_shader(r.effects.post_process.shader), this.gl.viewport(this.render_width * this.vp_left, this.render_height * this.vp_top, this.render_width * this.vp_width, this.render_height * this.vp_height), this.use_direct_texture(this.post_process_input, 0), this.draw_full_quad(), this.has_error = this.gl.getError(), this.has_error !== this.gl.NO_ERROR && console.error(this.has_error)), this.gl_enable(2929) }, a.render_light_shadows = (nt = {}, at = null, st = n.quat(), ot = n.vec4(), _t = n.vec3(), lt = n.vec3(), ut = n.vec4(), ht = 0, ct = 0, function (t, e, i, a) { at = function (t, e) { return (at = nt[e]) || ((at = new r.webgl.render_target(t, e, e)).attach_color(), at.attach_depth(), nt[e] = at), at }(this, t.shadow_map_size); var s, o, l, u = null, h = 0, p = 0, dt = (this.gl, !1); for (t.camera || (t.camera = { view: n.mat4(), view_inverse: n.mat4(), projection: n.mat4(), view_projection: n.mat4(), light_version: -1, camera_version: -1, version: 0 }, 0 === t.light_type ? (p = 2 * t.shadow_camera_distance, A = t.camera.projection, b = 1 / (-p - p), E = 1 / (-p - p), T = 1 / (.75 * -p - 5 * p), A[0] = -2 * b, A[1] = 0, A[2] = 0, A[3] = 0, A[4] = 0, A[6] = 0, A[7] = 0, A[8] = 0, A[9] = 0, A[5] = -2 * E, A[10] = 2 * T, A[11] = 0, A[12] = (-p + p) * b, A[13] = (p + -p) * E, A[14] = (5 * p + .75 * -p) * T, A[15] = 1) : 1 === t.light_type ? (p = 2.6179938779914944, A = t.camera.projection, b = 1 / Math.tan(p / 2), A[0] = b / 1, A[1] = 0, A[2] = 0, A[3] = 0, A[4] = 0, A[5] = b, A[6] = 0, A[7] = 0, A[8] = 0, A[9] = 0, A[11] = -1, A[12] = 0, A[13] = 0, A[15] = 0, 8 * t.range != null && 8 * t.range != 1 / 0 ? (b = 1 / (.5 - 8 * t.range), A[10] = (8 * t.range + .5) * b, A[14] = 2 * t.range * 8 * .5 * b) : (A[10] = -1, A[14] = -1), p = -1.5707963267948966, y = st, c = Math.sin(.5 * p), d = Math.sin(0), m = Math.sin(0), g = Math.cos(.5 * p), v = Math.cos(0), w = Math.cos(0), y[0] = c * v * w - g * d * m, y[1] = g * d * w + c * v * m, y[2] = g * v * m - c * d * w, y[3] = g * v * w + c * d * m, c = y[0], d = y[1], m = y[2], f = y[3], (x = c * c + d * d + m * m + f * f) > 0 && (x = 1 / Math.sqrt(x)), y[0] = c * x, y[1] = d * x, y[2] = m * x, y[3] = f * x, A = t.camera.view, b = (O = st)[0], E = O[1], T = O[2], z = O[3], k = b * (M = b + b), S = b * (L = E + E), R = b * (I = T + T), F = E * L, N = E * I, C = T * I, G = z * M, P = z * L, j = z * I, A[0] = 1 - (F + C), A[1] = S + j, A[2] = R - P, A[3] = 0, A[4] = S - j, A[5] = 1 - (k + C), A[6] = N + G, A[7] = 0, A[8] = R + P, A[9] = N - G, A[10] = 1 - (k + F), A[11] = 0) : 2 === t.light_type && (A = t.camera.projection, b = 1 / Math.tan(t.view_angle / 2), A[0] = b / 1, A[1] = 0, A[2] = 0, A[3] = 0, A[4] = 0, A[5] = b, A[6] = 0, A[7] = 0, A[8] = 0, A[9] = 0, A[11] = -1, A[12] = 0, A[13] = 0, A[15] = 0, 4 * t.range != null && 4 * t.range != 1 / 0 ? (b = 1 / (.1 - 4 * t.range), A[10] = (4 * t.range + .1) * b, A[14] = 2 * t.range * 4 * .1 * b) : (A[10] = -1, A[14] = -.2)), t.camera.world_position = new Float32Array(t.camera.view.buffer, 48, 3)), ((u = t.camera).light_version !== t.version || dt) && (1 === t.light_type ? (u.view[12] = t.world_position[0], u.view[13] = t.world_position[1], u.view[14] = t.world_position[2]) : (A = u.view, D = t.matrix_world, A[0] = D[0], A[1] = D[1], A[2] = D[2], A[3] = D[3], A[4] = D[4], A[5] = D[5], A[6] = D[6], A[7] = D[7], A[8] = D[8], A[9] = D[9], A[10] = D[10], A[11] = D[11], A[12] = D[12], A[13] = D[13], A[14] = D[14], A[15] = D[15]), dt = !0), (u.camera_version !== e.version || dt) && (0 === t.light_type && (p = -t.shadow_camera_distance, u.world_position[0] = e.fw_vector[0] * p + e.world_position[0], u.world_position[1] = e.fw_vector[1] * p + e.world_position[1], u.world_position[2] = e.fw_vector[2] * p + e.world_position[2]), dt = !0), dt && (A = u.view_inverse, D = u.view, b = D[0], E = D[1], T = D[2], z = D[3], q = D[4], U = D[5], B = D[6], H = D[7], X = D[8], K = D[9], Z = D[10], V = D[11], Y = D[12], W = D[13], Q = D[14], $ = D[15], (J = (k = b * U - E * q) * (it = Z * $ - V * Q) - (S = b * B - T * q) * (et = K * $ - V * W) + (R = b * H - z * q) * (tt = K * Q - Z * W) + (F = E * B - T * U) * (j = X * $ - V * Y) - (N = E * H - z * U) * (P = X * Q - Z * Y) + (C = T * H - z * B) * (G = X * W - K * Y)) && (J = 1 / J, A[0] = (U * it - B * et + H * tt) * J, A[1] = (T * et - E * it - z * tt) * J, A[2] = (W * C - Q * N + $ * F) * J, A[3] = (Z * N - K * C - V * F) * J, A[4] = (B * j - q * it - H * P) * J, A[5] = (b * it - T * j + z * P) * J, A[6] = (Q * R - Y * C - $ * S) * J, A[7] = (X * C - Z * R + V * S) * J, A[8] = (q * et - U * j + H * G) * J, A[9] = (E * j - b * et - z * G) * J, A[10] = (Y * N - W * R + $ * k) * J, A[11] = (K * R - X * N - V * k) * J, A[12] = (U * P - q * tt - B * G) * J, A[13] = (b * tt - E * P + T * G) * J, A[14] = (W * S - Y * F - Q * k) * J, A[15] = (X * F - K * S + Z * k) * J), A = u.view_projection, D = u.projection, rt = u.view_inverse, b = D[0], E = D[1], T = D[2], z = D[3], q = D[4], U = D[5], B = D[6], H = D[7], X = D[8], K = D[9], Z = D[10], V = D[11], Y = D[12], W = D[13], Q = D[14], $ = D[15], k = rt[0], S = rt[1], R = rt[2], F = rt[3], A[0] = k * b + S * q + R * X + F * Y, A[1] = k * E + S * U + R * K + F * W, A[2] = k * T + S * B + R * Z + F * Q, A[3] = k * z + S * H + R * V + F * $, k = rt[4], S = rt[5], R = rt[6], F = rt[7], A[4] = k * b + S * q + R * X + F * Y, A[5] = k * E + S * U + R * K + F * W, A[6] = k * T + S * B + R * Z + F * Q, A[7] = k * z + S * H + R * V + F * $, k = rt[8], S = rt[9], R = rt[10], F = rt[11], A[8] = k * b + S * q + R * X + F * Y, A[9] = k * E + S * U + R * K + F * W, A[10] = k * T + S * B + R * Z + F * Q, A[11] = k * z + S * H + R * V + F * $, k = rt[12], S = rt[13], R = rt[14], F = rt[15], A[12] = k * b + S * q + R * X + F * Y, A[13] = k * E + S * U + R * K + F * W, A[14] = k * T + S * B + R * Z + F * Q, A[15] = k * z + S * H + R * V + F * $), u.camera_version = e.version, u.light_version = t.version, u.version = e.version + t.version, at.bind(), this.gl_cullFace(1028), ht = 0, h = 0; h < i.length; h++)if (0 != (16 & (s = i[h]).material.flags)) { if (t.light_type > 0 && n.vec3.calc_distance(u.view[12], u.view[13], u.view[14], s.world_position[0], s.world_position[1], s.world_position[2]) - s.bounds_sphere > 3 * t.range) continue; ht++, o = s.material.shader, t.light_type > -1 && (o.default_shadow_map || (o.default_shadow_map = o.extend(_["render-shadow-map"], { fragment: !1 }), o.default_shadow_map.shadow_shader = !0), o = o.default_shadow_map), this.use_shader(o) && ((l = o.uniforms.u_view_projection_rw).params[l.params_length] = u.view_projection, l.func.apply(o.gl, l.params)), (l = o.uniforms.u_model_rw).params[l.params_length] = s.matrix_world, l.func.apply(o.gl, l.params), this.use_geometry(s.geometry), s.material.render_mesh(this, o, s) } if (ct = ht, a.length > 0) { for (this.gl_enable(3042), this.gl_blendFunc(770, 771), ht = 0, h = 0; h < a.length; h++)if (0 != (16 & (s = a[h]).material.flags)) { if (t.light_type > 0 && n.vec3.calc_distance(u.view[12], u.view[13], u.view[14], s.world_position[0], s.world_position[1], s.world_position[2]) - s.bounds_sphere > 3 * t.range) continue; ht++, o = s.material.shader, t.light_type > -1 && (o.default_shadow_map || (o.default_shadow_map = o.extend(_["render-shadow-map"], { fragment: !1 }), o.default_shadow_map.shadow_shader = !0), o = o.default_shadow_map), this.use_shader(o) && ((l = o.uniforms.u_view_projection_rw).params[l.params_length] = u.view_projection, l.func.apply(o.gl, l.params)), (l = o.uniforms.u_model_rw).params[l.params_length] = s.matrix_world, l.func.apply(o.gl, l.params), this.use_geometry(s.geometry), s.material.render_mesh(this, o, s) } ct += ht } if (ot[0] = t.shadow_intensity, ot[1] = 1 / t.shadow_map_size, ot[2] = t.shadow_bias, lt[0] = t.matrix_world[8], lt[1] = t.matrix_world[9], lt[2] = t.matrix_world[10], ot[3] = Math.cos(.5 * t.view_angle), 0 === t.light_type ? (_t[0] = lt[0] * t.range, _t[1] = lt[1] * t.range, _t[2] = lt[2] * t.range) : (_t[0] = t.world_position[0], _t[1] = t.world_position[1], _t[2] = t.world_position[2]), this.gl_cullFace(1029), this.set_default_viewport(), ct > 0) { for (this.receive_shadow_count = 0, 1 === t.light_type ? (ut[0] = 0, ut[1] = 2 * (t.attenuation[0] + t.attenuation[1]), ut[2] = 2 * t.attenuation[2], ut[3] = .95 * t.range) : 2 === t.light_type ? (ut[0] = 0, ut[1] = .75 * t.attenuation[1], ut[2] = .5 * t.attenuation[2], ut[3] = t.range, ut[0] = 1, ut[1] = 0, ut[2] = 0, ut[3] = t.range) : (ut[0] = 1, ut[1] = 0, ut[2] = 0, ut[3] = t.range), this.gl_blendFunc(1, 1), this.fw_rendering_mode || (this.gl_enable(3042), this.gl_depthMask(!1), this.gl_depthFunc(514), this.fw_rendering_mode = !0), this.gl_blendEquation(32779), this.use_direct_texture(at.color_texture, 0), this.use_direct_texture(at.depth_texture, 4), h = 0; h < i.length; h++)if (0 != (32 & (s = i[h]).material.flags)) { if (t.light_type > 0 && n.vec3.calc_distance(u.view[12], u.view[13], u.view[14], s.world_position[0], s.world_position[1], s.world_position[2]) - s.bounds_sphere > 2 * t.range) continue; this.receive_shadow_count++, o = s.material.shader, t.light_type > -1 && (o.default_shadow_receiver || (o.default_shadow_receiver = o.extend(_["receive-shadow"], { fragment: !1 }), o.default_shadow_receiver.shadow_shader = !0), o = o.default_shadow_receiver), this.use_shader(o) && ((l = o.uniforms.u_view_projection_rw).params[l.params_length] = e.view_projection, l.func.apply(o.gl, l.params)), (l = o.uniforms.u_shadow_map_rw).params[l.params_length] = 4, l.func.apply(o.gl, l.params), (l = o.uniforms.u_light_camera_matrix_rw).params[l.params_length] = u.view_projection, l.func.apply(o.gl, l.params), (l = o.uniforms.u_light_pos_rw).params[l.params_length] = _t, l.func.apply(o.gl, l.params), (l = o.uniforms.u_light_dir_rw).params[l.params_length] = lt, l.func.apply(o.gl, l.params), (l = o.uniforms.u_shadow_params_rw).params[l.params_length] = ot, l.func.apply(o.gl, l.params), (l = o.uniforms.u_shadow_attenuation_rw).params[l.params_length] = ut, l.func.apply(o.gl, l.params), (l = o.uniforms.u_model_rw) && (l.params[l.params_length] = s.matrix_world, l.func.apply(o.gl, l.params)), this.use_geometry(s.geometry), s.material.render_mesh(this, o, s) } if (a.length > 0) for (this.gl_depthFunc(513), h = 0; h < a.length; h++)if (0 != (32 & (s = a[h]).material.flags)) { if (t.light_type > 0 && n.vec3.calc_distance(u.view[12], u.view[13], u.view[14], s.world_position[0], s.world_position[1], s.world_position[2]) - s.bounds_sphere > 2 * t.range) continue; this.receive_shadow_count++, o = s.material.shader, t.light_type > -1 && (o.default_shadow_receiver || (o.default_shadow_receiver = o.extend(_["receive-shadow"], { fragment: !1 }), o.default_shadow_receiver.shadow_shader = !0), o = o.default_shadow_receiver), this.use_shader(o) && ((l = o.uniforms.u_view_projection_rw).params[l.params_length] = e.view_projection, l.func.apply(o.gl, l.params)), (l = o.uniforms.u_shadow_map_rw).params[l.params_length] = 4, l.func.apply(o.gl, l.params), (l = o.uniforms.u_light_camera_matrix_rw).params[l.params_length] = u.view_projection, l.func.apply(o.gl, l.params), (l = o.uniforms.u_light_pos_rw).params[l.params_length] = _t, l.func.apply(o.gl, l.params), (l = o.uniforms.u_light_dir_rw).params[l.params_length] = lt, l.func.apply(o.gl, l.params), (l = o.uniforms.u_shadow_params_rw).params[l.params_length] = ot, l.func.apply(o.gl, l.params), (l = o.uniforms.u_shadow_attenuation_rw).params[l.params_length] = ut, l.func.apply(o.gl, l.params), (l = o.uniforms.u_model_rw) && (l.params[l.params_length] = s.matrix_world, l.func.apply(o.gl, l.params)), this.use_geometry(s.geometry), s.material.render_mesh(this, o, s) } this.gl_blendEquation(32774), this.fw_rendering_mode && (this.gl_disable(3042), this.gl_depthFunc(513), this.gl_depthMask(!0), this.fw_rendering_mode = !1) } }); var mt = n.vec4(), pt = n.mat4(); pt.fill(0), pt[3] = 0, pt[15] = .5; var ft = n.mat4(); return a.render_single_mesh = function (e, i) { (t.use_shader(i.material.shader) || update_shading_lights) && (shader = t.active_shader, update_shading_lights = !1, shader.camera_version !== e.version && (shader.camera_version = e.version, uni = shader.uniforms.u_view_projection_rw, uni && (uni.params[uni.params_length] = e.view_projection, uni.func.apply(shader.gl, uni.params)), uni = shader.uniforms.u_view_rw, uni && (uni.params[uni.params_length] = e.view_inverse, uni.func.apply(shader.gl, uni.params)), uni = shader.uniforms.u_view_fw, uni && (uni.params[uni.params_length] = e.fw_vector, uni.func.apply(shader.gl, uni.params)), uni = shader.uniforms.u_view_sd, uni && (uni.params[uni.params_length] = e.sd_vector, uni.func.apply(shader.gl, uni.params)), uni = shader.uniforms.u_view_up, uni && (uni.params[uni.params_length] = e.up_vector, uni.func.apply(shader.gl, uni.params)))), uni = shader.uniforms.u_model_rw, uni && (uni.params[uni.params_length] = i.matrix_world, uni.func.apply(shader.gl, uni.params)), t.use_geometry(i.geometry), i.material.render_mesh(t, shader, i) }, a.render_scene = function (t, e, i, r, n) { if (this.has_error === this.gl.NO_ERROR) { this.last_shader_id = -1, this.render_target_id = -1, this.active_shader = null, this.texture_slots[0] = -1, this.texture_slots[1] = -1, this.texture_slots[2] = -1, this.flat_meshes = e, this.opuque_meshes = i, this.transparent_meshes = r, this.active_camera = t; var a, s, o, _, l, u = 0, h = 0, c = !1, d = 0; if (this.gl, _ = this.active_shader, this.set_default_viewport(), this.clear_screen(), this.fw_rendering_mode && (this.gl_disable(3042), this.gl_depthFunc(513), this.gl_depthMask(!0), this.fw_rendering_mode = !1), i.length > 0) for (this.light_pass_count = 0, this.lights_batch_size = 0, u = 0; u < n.length; u++)if (o = n[u], this.shading_lights[this.lights_batch_size++] = o, c = this.lights_batch_size === this.fws_num_lights || u === n.length - 1) { for (a = 0; a < i.length; a++)if (s = i[a], !(this.light_pass_count >= s.material.light_pass_limit)) { if (this.use_shader(s.material.shader) || c) { for (c = !1, (_ = this.active_shader).camera_version !== t.version && (_.camera_version = t.version, (l = _.uniforms.u_view_projection_rw) && (l.params[l.params_length] = t.view_projection, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_rw) && (l.params[l.params_length] = t.view_inverse, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_fw) && (l.params[l.params_length] = t.fw_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_sd) && (l.params[l.params_length] = t.sd_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_up) && (l.params[l.params_length] = t.up_vector, l.func.apply(_.gl, l.params))), d = s.material.lights_count, total_lights = 0, -1 === d && (d = this.lights_batch_size), h = 0; h < d; h++)null != (o = this.shading_lights[h]) && (0 === o.light_type ? (mt[0] = o.world_position[0], mt[1] = o.world_position[1], mt[2] = o.world_position[2], o.world_position[0] = 99999 * o.matrix_world[8], o.world_position[1] = 99999 * o.matrix_world[9], o.world_position[2] = 99999 * o.matrix_world[10], o.attenuation[3] = 1) : o.attenuation[3] = 0, (l = _.uniforms["u_light_material_rw" + h]).params[l.params_length] = o.light_material, l.func.apply(_.gl, l.params), (l = _.uniforms["u_light_matrix_rw" + h]).params[l.params_length] = o.matrix_world, l.func.apply(_.gl, l.params), 0 === o.light_type && (o.world_position[0] = mt[0], o.world_position[1] = mt[1], o.world_position[2] = mt[2])); for (h = d; h < this.fws_num_lights; h++)(l = _.uniforms["u_light_material_rw" + h]) && (l.params[l.params_length] = pt, l.func.apply(_.gl, l.params)), (l = _.uniforms["u_light_matrix_rw" + h]) && (l.params[l.params_length] = ft, l.func.apply(_.gl, l.params)); mt[0] = t.world_position[0], mt[1] = t.world_position[1], mt[2] = t.world_position[2], mt[3] = this.lights_batch_size, (l = _.uniforms.u_eye_position_rw) && (l.params[l.params_length] = mt, l.func.apply(_.gl, l.params)) } (l = _.uniforms.u_model_rw) && (l.params[l.params_length] = s.matrix_world, l.func.apply(_.gl, l.params)), this.use_geometry(s.geometry), s.material.render_mesh(this, _, s) } this.lights_batch_size = 0, this.light_pass_count++, n.length > this.fws_num_lights && (this.gl_blendFunc(1, 1), this.fw_rendering_mode || (this.gl_enable(3042), this.gl_depthMask(!1), this.gl_depthFunc(514), this.fw_rendering_mode = !0)) } for (this.fw_rendering_mode && (this.gl_disable(3042), this.gl_depthFunc(513), this.gl_depthMask(!0), this.fw_rendering_mode = !1), a = 0; a < e.length; a++)s = e[a], this.use_shader(s.material.shader) && (_ = this.active_shader).camera_version !== t.version && (_.camera_version = t.version, (l = _.uniforms.u_view_projection_rw) && (l.params[l.params_length] = t.view_projection, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_rw) && (l.params[l.params_length] = t.view_inverse, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_fw) && (l.params[l.params_length] = t.fw_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_sd) && (l.params[l.params_length] = t.sd_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_up) && (l.params[l.params_length] = t.up_vector, l.func.apply(_.gl, l.params))), (l = _.uniforms.u_model_rw) && (l.params[l.params_length] = s.matrix_world, l.func.apply(_.gl, l.params)), this.use_geometry(s.geometry), s.material.render_mesh(this, _, s); for (u = 0; u < n.length; u++)(o = n[u]).cast_shadows && this.render_light_shadows(o, t, i, r), this.texture_slots[0] = -1; if (r.length > 0) for (this.fw_rendering_mode && (this.gl_disable(3042), this.gl_depthFunc(513), this.gl_depthMask(!0), this.fw_rendering_mode = !1), a = 0; a < r.length; a++)if (4 & (s = r[a]).material.flags) { if (this.light_pass_count >= s.material.light_pass_limit) continue; for (this.light_pass_count = 0, this.lights_batch_size = 0, u = 0; u < n.length; u++)if (o = n[u], this.shading_lights[this.lights_batch_size++] = o, c = this.lights_batch_size === this.fws_num_lights || u === n.length - 1) { if (this.use_shader(s.material.shader) || c) { for ((_ = this.active_shader).camera_version !== t.version && (_.camera_version = t.version, (l = _.uniforms.u_view_projection_rw) && (l.params[l.params_length] = t.view_projection, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_rw) && (l.params[l.params_length] = t.view_inverse, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_fw) && (l.params[l.params_length] = t.fw_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_sd) && (l.params[l.params_length] = t.sd_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_up) && (l.params[l.params_length] = t.up_vector, l.func.apply(_.gl, l.params))), (l = _.uniforms.u_model_rw) && (l.params[l.params_length] = s.matrix_world, l.func.apply(_.gl, l.params)), d = s.material.lights_count, total_lights = 0, -1 === d && (d = this.lights_batch_size), h = 0; h < d; h++)null != (o = this.shading_lights[h]) && (0 === o.light_type ? (mt[0] = o.world_position[0], mt[1] = o.world_position[1], mt[2] = o.world_position[2], o.world_position[0] = 99999 * o.matrix_world[8], o.world_position[1] = 99999 * o.matrix_world[9], o.world_position[2] = 99999 * o.matrix_world[10], o.attenuation[3] = 1) : o.attenuation[3] = 0, (l = _.uniforms["u_light_material_rw" + h]).params[l.params_length] = o.light_material, l.func.apply(_.gl, l.params), (l = _.uniforms["u_light_matrix_rw" + h]).params[l.params_length] = o.matrix_world, l.func.apply(_.gl, l.params), 0 === o.light_type && (o.world_position[0] = mt[0], o.world_position[1] = mt[1], o.world_position[2] = mt[2])); for (h = d; h < this.fws_num_lights; h++)(l = _.uniforms["u_light_material_rw" + h]) && (l.params[l.params_length] = pt, l.func.apply(_.gl, l.params)), (l = _.uniforms["u_light_matrix_rw" + h]) && (l.params[l.params_length] = ft, l.func.apply(_.gl, l.params)); mt[0] = t.world_position[0], mt[1] = t.world_position[1], mt[2] = t.world_position[2], mt[3] = this.lights_batch_size, (l = _.uniforms.u_eye_position_rw) && (l.params[l.params_length] = mt, l.func.apply(_.gl, l.params)), 0 === this.light_pass_count ? (this.gl_enable(3042), this.gl_blendFunc(770, 771), this.gl_cullFace(1028), this.use_geometry(s.geometry), s.material.render_mesh(this, _, s), this.gl_cullFace(1029), this.use_geometry(s.geometry), s.material.render_mesh(this, _, s)) : (this.gl_blendFunc(770, 1), this.use_geometry(s.geometry), s.material.render_mesh(this, _, s)) } this.lights_batch_size = 0, this.light_pass_count++, n.length > this.fws_num_lights && (this.gl_blendFunc(1, 1), this.fw_rendering_mode || (this.gl_enable(3042), this.gl_depthMask(!1), this.gl_depthFunc(514), this.fw_rendering_mode = !0)) } } else this.use_shader(s.material.shader), (_ = this.active_shader).camera_version !== t.version && (_.camera_version = t.version, (l = _.uniforms.u_view_projection_rw) && (l.params[l.params_length] = t.view_projection, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_rw) && (l.params[l.params_length] = t.view_inverse, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_fw) && (l.params[l.params_length] = t.fw_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_sd) && (l.params[l.params_length] = t.sd_vector, l.func.apply(_.gl, l.params)), (l = _.uniforms.u_view_up) && (l.params[l.params_length] = t.up_vector, l.func.apply(_.gl, l.params))), (l = _.uniforms.u_model_rw) && (l.params[l.params_length] = s.matrix_world, l.func.apply(_.gl, l.params)), this.gl_enable(3042), this.gl_blendFunc(770, 771), this.use_geometry(s.geometry), s.material.render_mesh(this, _, s); this.fw_rendering_mode && (this.gl_disable(3042), this.gl_depthFunc(513), this.gl_depthMask(!0), this.fw_rendering_mode = !1), this.set_default_viewport(), null !== this.active_shader && this.active_shader.exit(this), null !== this.default_render_target && this.apply_post_processes() } }, (o = function (t) { var i = (t = t || {}).canvas; i || (i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).setAttribute("style", "position:absolute;width:100%;height:100%;left:0;top:0;box-sizing: border-box;"), this.priority = 5e3; var a = (t = e.merge_object(t, { alpha: !1, depth: !0, stencil: !0, antialias: !1, premultipliedAlpha: !1, preserveDrawingBuffer: !1, xrCompatible: !0 })).context || i.getContext("webgl", t); if (this.shader_parameters = { fws_num_lights: t.lights_count_per_pass || 4 }, null === a) throw null !== i.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context."); this.pixel_ratio = t.pixel_ratio || window.devicePixelRatio, i.addEventListener("webglcontextlost", function () { console.log("webglcontextlost", this) }, !1), i.addEventListener("webglcontextrestored", function () { console.log("webglcontextrestored", this) }, !1), a.OES_vertex_array_object = a.getExtension("OES_vertex_array_object"), a.OES_standard_derivatives = a.getExtension("OES_standard_derivatives"), a.WEBGL_depth_texture = a.getExtension("WEBGL_depth_texture"), a.ANGLE_instanced_arrays = a.getExtension("ANGLE_instanced_arrays"), a.OES_element_index_uint = a.getExtension("OES_element_index_uint"), this.gl_states = { depthMask: !1, blendFunc0: -1, blendFunc1: -1, framebuffer: void 0 }, this.gl_states_flags = new Uint8Array(65536), this.gl = a, this.canvas = i, this.render_target_id = 0, this.render_target1 = new r.webgl.render_target(this, 10, 10), this.render_target1.attach_depth_buffer().attach_color(), this.render_target1.clear_buffer = !1, this.default_render_target = this.render_target1, this.render_target2 = new r.webgl.render_target(this, 10, 10), this.render_target2.attach_depth_buffer(this.render_target1.depth_buffer).attach_color(), this.render_target2.clear_buffer = !1, this.render_target1.swap = this.render_target2, this.render_target2.swap = this.render_target1, this.post_processes = [], this.render_targets = [this.render_target1, this.render_target2], this.texture_slots = [-1, -1, -1, -1, -1, -2, -1, -1, -1], this.texture_updates = [], this.default_texture = new r.webgl.texture, this.default_texture.needs_update = !0, this.update_texture(this.default_texture), this.gl_enable(2929), this.gl_cullFace(1029), this.gl_enable(2884), this.gl.clearColor(0, 0, 0, 1), this.full_quad = o.gl_buffers.get(a), a.bindBuffer(34962, this.full_quad), a.bufferData(34962, new Float32Array([-1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1]), 35044, 0, 12), this.fws_num_lights = this.shader_parameters.fws_num_lights, this.shading_lights = []; for (var s = 0; s < this.shader_parameters.fws_num_lights; s++)this.shading_lights[s] = null; this.has_error = 0, this.light_pass_count = 0, this.lights_batch_size = 0, this.active_camera = null, this.frame_buffer_layer = null, this.default_color_attribute = { name: "a_color_rw", item_size: 4, data: new Float32Array(14366112) }, this.vp_left = 0, this.vp_top = 0, this.vp_width = 1, this.vp_height = 1, this.sbs_display = !1, this.sbs_depth = 2, this.default_color_attribute.data.fill(1), this.is_renderer = !0, this.active_camera = null, this.fog_params = n.vec3(0, 0, 0), this.fog_color = n.vec4(.165, .165, .165, .001), this.timer = 0, this.output_to_screen = !0, this.frame_eye_index = 0, this.render_width = this.canvas.width, this.render_height = this.canvas.height }).gl_buffers = new e.object_pooler(function (t) { return t.createBuffer() }), o.gl_textures = new e.object_pooler(function (t) { return t.createTexture() }), o }) }(_FM.fin, _FM.ge, _FM.math), function () { return function terrain(ecs, ge, math) { ge.terrain = {}; var WORKER_THREAD_MESSAGES = { REQUEST_REGION_MESH: 2e3, REQUEST_REGION_QT: 3e3, REQUEST_REGION_CQT: 3500 }; ge.terrain.processor = ge.define(function (proto, _super) { proto.setup_mesh_processor = function () { var i; return proto.regions_from_image_url = function (t, e, i, r, n, a, s) { var o = this; r = r || 1, ge.load_working_image_data(t, function (t, n, a) { for (var _ = 999999, l = -999999, u = 0, h = [], c = 0; c < t.length / 4; c++)(u = t[4 * c] / r) < _ && (_ = u), u > l && (l = u), h[c] = u; size = l - _, o.worker.postMessage([200, e, i, n, h, s || 1]) }, n, a) }, proto.regions_from_data = (i = 0, function (t, e, r, n, a, s) { if (s) for (i = 0; i < t.length; i++)t[i] *= s; this.worker.postMessage([200, e, r, n, t, a]) }), proto.update_terrain_parameters = function () { this.worker.postMessage([100, this.world_size, this.region_size, this.terrain_quality]), this.worker.postMessage([400, this.sun_direction[0] * this.world_size * this.region_size, this.sun_direction[1] * this.world_size * this.region_size, this.sun_direction[2] * this.world_size * this.region_size]) }, proto.generate_regions = function (t, e, i, r, n) { this.worker.postMessage([9999, t, e, i, r, n]) }, function () { var worker = ge.worker(function (thread) { var regions = {}, world_size, region_size, region_size1, region_size2, terrain_quality = 1, region_size_scale, region_size_scale1, reg_x, reg_z, reg, reg_key; console.log("regions", regions), regions.pool = [], regions.pool.free = function (t) { this.push(t) }, regions.pool.get = function () { return this.length > 0 ? this.pop() : { HP: {} } }; var PATCH_SIZE = 16, MIN_PATCH_SIZE = 2, MIN_FAN_DETAIL = 2, CQT_DETAIL = 0, ORIG_MIN_PATCH_SIZE = 0, WORKING_PATCH_SIZE = PATCH_SIZE, WORKING_MIN_PATCH_SIZE = MIN_PATCH_SIZE, vkey, vindex_width = 1200, vmap = new Uint8Array(0), vdata = new Float32Array(0), vindex_width2 = vindex_width / 2, check_vlevel_value = 0, time_start, rast_time; function check_vlevel(t, e) { return check_vlevel_value = vmap[(e + vindex_width2) * vindex_width + (t + vindex_width2)] } function set_vlevel(t, e, i) { vmap[vkey = (e + vindex_width2) * vindex_width + (t + vindex_width2)] = Math.min(vmap[vkey], i) } var output = new Float32Array(24e5), oi = 0, render_strips = (st = 0, function (t) { for (st = 0; st < region_size; st += 2 * t)set_vlevel(st, 0, t), set_vlevel(st, region_size, t), set_vlevel(0, st, t), set_vlevel(region_size, st, t) }), st, patches = {}, sun_x = 15e3, sun_y = 5500, sun_z = 15e3; thread[400] = function (t, e, i, r) { sun_x = e, sun_y = i, sun_z = r }, thread[100] = function (t, e, i, r) { world_size = e, region_size1 = (region_size = i) + 1, region_size2 = .5 * region_size, 0 === (terrain_quality = r) ? (PATCH_SIZE = 4, MIN_PATCH_SIZE = 1, MIN_DETAIL = 1, CQT_DETAIL = 4, MIN_FAN_DETAIL = 2) : 1 === terrain_quality && (PATCH_SIZE = 8, MIN_PATCH_SIZE = 2, CQT_DETAIL = 8, MIN_FAN_DETAIL = 2), 2 === terrain_quality ? (PATCH_SIZE = 16, MIN_PATCH_SIZE = 4, CQT_DETAIL = 12, MIN_FAN_DETAIL = 2) : 3 === terrain_quality ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 4, CQT_DETAIL = 9, MIN_FAN_DETAIL = 2) : 4 === terrain_quality ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 8, CQT_DETAIL = 24, MIN_FAN_DETAIL = 4) : 5 === terrain_quality ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 16, CQT_DETAIL = 32, MIN_FAN_DETAIL = 4) : 6 === terrain_quality && (PATCH_SIZE = 32, MIN_PATCH_SIZE = 16, CQT_DETAIL = 32, MIN_FAN_DETAIL = 8), ORIG_MIN_PATCH_SIZE = MIN_PATCH_SIZE; for (var n = 1; n <= region_size;)patches[n] = { i: 0, list: [] }, n *= 2; vindex_width2 = (vindex_width = 2 * region_size + 8) / 2, vkey = vindex_width * vindex_width, vmap.length < vkey && (vmap = new Uint8Array(vkey), vdata = new Float32Array(4 * vkey)) }, thread[200] = function () { var t, e, i, r, n, a; return function (s, o, _, l, u, h) { for (u = function (t, e) { var i = new Float32Array((e + 1) * (e + 1)); for (reg_z = 0; reg_z < e; reg_z++)for (reg_x = 0; reg_x < e; reg_x++)i[reg_z * (e + 1) + reg_x] = t[reg_z * e + reg_x]; for (reg_z = 0; reg_z < e; reg_z++)i[reg_z * (e + 1) + e] = t[reg_z * e + (e - 1)]; for (reg_x = 0; reg_x < e; reg_x++)i[e * (e + 1) + reg_x] = t[(e - 1) * e + reg_x]; return i[e * (e + 1) + e] = (t[(e - 1) * e + (e - 1)] + t[(e - 1) * e + (e - 1)]) / 2, i }(u, l), region_size_scale1 = 1 + (region_size_scale = region_size / h), a = Math.floor(l / region_size_scale), l += 1, reg_z = 0; reg_z < a; reg_z++)for (reg_x = 0; reg_x < a; reg_x++) { for ((reg = regions[reg_key = (reg_z + _) * world_size + (reg_x + o)] || regions.pool.get()).HP = {}, reg.QT = void 0, reg.data = reg.data || new Float32Array(region_size_scale1 * region_size_scale1), void 0 !== reg.size && reg.size !== region_size_scale1 && (reg.data = new Float32Array(region_size_scale1 * region_size_scale1)), reg.minh = 999999, reg.maxh = -999999, reg.rx = reg_x + o, reg.rz = reg_z + _, reg.x = reg.rx * region_size, reg.z = reg.rz * region_size, reg.scale = h, reg.size = region_size_scale1, i = reg_x * region_size_scale, e = 0; e < region_size_scale1; e++)for (r = (reg_z * region_size_scale + e) * l + i, n = e * region_size_scale1, t = 0; t < region_size_scale1; t++)ht = u[r + t] || 0, ht < reg.minh && (reg.minh = ht), ht > reg.maxh && (reg.maxh = ht), reg.data[n + t] = ht; regions[reg_key] = reg, reg.key = reg_key, thread.postMessage([s, reg_key, reg.rx, reg.rz, reg.minh, reg.maxh]) } console.log(a * a + " regions loaded") } }(); var H = function () { var t, e, i, r, n, a, s, o, _, l, u, h, c, d, m; return function (p, f) { return 1 === reg.scale ? reg.data[f * region_size1 + p] : (m = f * region_size1 + p, void 0 !== reg.HP[m] ? reg.HP[m] : (d = reg.data, _ = reg.size, e = p / reg.scale, t = f / reg.scale, n = (i = 0 | (e < 0 ? 0 : e >= _ ? _ - 1 : e)) === _ - 1 ? i : i + 1, a = (r = 0 | (t < 0 ? 0 : t >= _ ? _ - 1 : t)) === _ - 1 ? r : r + 1, p = e % 1, f = t % 1, l = d[i + r * _], u = d[n + r * _], h = d[i + a * _], c = d[n + a * _], s = ((u *= u) - (l *= l)) * p + l, o = (c * c - c * h) * p + h * h, reg.HP[m] = Math.sqrt((o - s) * f + s), reg.HP[m])) } }(), HH = function (t, e) { return t > -1 && t < region_size1 && e > -1 && e < region_size1 ? H(t, e) : (rs = region_size, _rx = 0, _rz = 0, t < 0 ? (_rx = -1, t = rs + t) : t > rs && (_rx = 1, t %= rs), e < 0 ? (_rz = -1, e = rs + e) : e > rs && (_rz = 1, e %= rs), reg_key = (reg.rz + _rz) * world_size + (reg.rx + _rx), temp_reg = reg, (reg = regions[reg_key]) ? (v = H(t, e), reg = temp_reg, v) : (reg = temp_reg, 0)) }, _rx, _rz, v, temp_reg, rs, reg_data, _fp, nx, ny, nz, p, i = 0, x, z, j = 0, s = 1, patch_index = 0, draw_fan = function () { var t, e, i, r, n = 0, a = [-1, 1, -.75, 1, -.5, 1, -.25, 1, 0, 1, .25, 1, .5, 1, .75, 1, 1, 1, 1, .75, 1, .5, 1, .25, 1, 0, 1, -.25, 1, -.5, 1, -.75, 1, -1, .75, -1, .5, -1, .25, -1, 0, -1, -.25, -1, -.5, -1, -.75, -1, -1, -1, -1, -.75, -1, -.5, -1, -.25, -1, 0, -1, .25, -1, .5, -1, .75, -1, 1], s = []; s[16] = !0, s[32] = !0, s[48] = !0, s[64] = !0; var o = a.length; return function (_, l, u, h) { for (t = a[0], e = a[1], n = h; n < o;)check_vlevel_value = vmap[(l + (r = a[n + 1]) * u + vindex_width2) * vindex_width + (_ + (i = a[n]) * u + vindex_width2)], (s[n] || check_vlevel_value < u) && (vmap[vkey = (l + vindex_width2) * vindex_width + (_ + vindex_width2)] = Math.min(vmap[vkey], u), output[oi] = _, output[oi + 2] = l, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (l + e * u + vindex_width2) * vindex_width + (_ + t * u + vindex_width2)] = Math.min(vmap[vkey], u), output[oi] = _ + t * u, output[oi + 2] = l + e * u, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (l + r * u + vindex_width2) * vindex_width + (_ + i * u + vindex_width2)] = Math.min(vmap[vkey], u), output[oi] = _ + i * u, output[oi + 2] = l + r * u, output[oi + 3] = patch_index, oi += 6, t = i, e = r), n += h } }(), check_for_edge_cases = !1, qii = 0, rg_QT = null, hh0, hh1, hh2, hh3, hh4; function eval_area_height(t, e, i, r, n) { hh0 = H(t, e), hh1 = H(t - i, e - i), hh2 = H(t + i, e - i), hh3 = H(t + i, e + i), hh4 = H(t - i, e + i); var a = qii; return output[a] = Math.max(Math.abs(.5 * (hh1 + hh2) - hh0), Math.abs(.5 * (hh4 + hh3) - hh0), Math.abs(.5 * (hh1 + hh4) - hh0), Math.abs(.5 * (hh2 + hh3) - hh0)), r > -1 && (output[r + n] = a), i > ORIG_MIN_PATCH_SIZE && (qii += 5, i *= .5, output[a] = Math.max(output[a], eval_area_height(t - i, e - i, i, a, 1), eval_area_height(t + i, e - i, i, a, 2), eval_area_height(t - i, e + i, i, a, 3), eval_area_height(t + i, e + i, i, a, 4))), output[a] } var _RSK = new Float32Array(1024), _si = 0, dd = 0, dlen = 0; function rasterize_region(t, e, i, r, n) { var a = 0; for (_RSK[_si = 0] = t, _RSK[_si + 1] = e, _RSK[_si + 2] = i, _RSK[_si + 3] = a, _si += 4; _si > 0;)t = _RSK[_si -= 4], e = _RSK[_si + 1], i = _RSK[_si + 2], a = _RSK[_si + 3], dd = r, i > WORKING_PATCH_SIZE || i > WORKING_MIN_PATCH_SIZE && n[a] > dd ? (i *= .5, _RSK[_si] = t + i, _RSK[_si + 1] = e + i, _RSK[_si + 2] = i, _RSK[_si + 3] = n[a + 4], _RSK[_si += 4] = t - i, _RSK[_si + 1] = e + i, _RSK[_si + 2] = i, _RSK[_si + 3] = n[a + 3], _RSK[_si += 4] = t + i, _RSK[_si + 1] = e - i, _RSK[_si + 2] = i, _RSK[_si + 3] = n[a + 2], _RSK[_si += 4] = t - i, _RSK[_si + 1] = e - i, _RSK[_si + 2] = i, _RSK[_si + 3] = n[a + 1], _si += 4) : ((p = patches[i]).list[p.i++] = t, p.list[p.i++] = e) } thread[2e3] = function () { var t; function e(t) { for (qii = 0, eval_area_height(region_size2, region_size2, region_size2, -1, 0), t.QT = new Float32Array(qii), i = 0; i < qii;)t.QT[i] = output[i++] } var r, n, a, o = function (r, n) { for (r.QT || e(r), rg_QT = r.QT, r.smap, s = WORKING_MIN_PATCH_SIZE; s <= WORKING_PATCH_SIZE; s *= 2)patches[s].i = 0; rasterize_region(region_size2, region_size2, region_size2, n, rg_QT), function () { for (s = WORKING_MIN_PATCH_SIZE, t = !1, patch_index = 0; s <= WORKING_PATCH_SIZE;) { for (p = patches[s], i = 0, j = p.i; i < j;)x = p.list[i++], z = p.list[i++], fd = 16, check_for_edge_cases && (s >= WORKING_MIN_PATCH_SIZE || WORKING_MIN_PATCH_SIZE >= MIN_PATCH_SIZE) && (t = !1, check_vlevel(x - s, z) < s ? t = !0 : check_vlevel(x + s, z) < s ? t = !0 : check_vlevel(x, z - s) < s ? t = !0 : check_vlevel(x, z + s) < s && (t = !0), t && (fd = s / check_vlevel_value, fd < 16 ? fd = Math.max(2, 8 / fd) : fd = 2, fd = Math.min(MIN_FAN_DETAIL, fd), WORKING_MIN_PATCH_SIZE > MIN_PATCH_SIZE && (fd = 2))), check_for_edge_cases ? draw_fan(x, z, s, fd) : (vmap[vkey = (z - s + vindex_width2) * vindex_width + (x - s + vindex_width2)] = Math.min(vmap[vkey], s), output[oi] = x - s, output[oi + 2] = z - s, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (z - s + vindex_width2) * vindex_width + (x + s + vindex_width2)] = Math.min(vmap[vkey], s), output[oi] = x + s, output[oi + 2] = z - s, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (z + s + vindex_width2) * vindex_width + (x + s + vindex_width2)] = Math.min(vmap[vkey], s), output[oi] = x + s, output[oi + 2] = z + s, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (z - s + vindex_width2) * vindex_width + (x - s + vindex_width2)] = Math.min(vmap[vkey], s), output[oi] = x - s, output[oi + 2] = z - s, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (z + s + vindex_width2) * vindex_width + (x + s + vindex_width2)] = Math.min(vmap[vkey], s), output[oi] = x + s, output[oi + 2] = z + s, output[oi + 3] = patch_index, oi += 6, vmap[vkey = (z + s + vindex_width2) * vindex_width + (x - s + vindex_width2)] = Math.min(vmap[vkey], s), output[oi] = x - s, output[oi + 2] = z + s, output[oi + 3] = patch_index, oi += 6), patch_index++; s *= 2 } }() }, _ = !1; thread[3e3] = function (t, i, r, n, a, s, o, _, l, u) { (reg = regions[r]) && (reg.QT || e(reg), j = reg.QT.length, u = (reg_data = u.byteLength < 4 * j ? new Float32Array(j) : new Float32Array(u)).buffer, reg_data.set(reg.QT, 0), this.postMessage([t, r, n, MIN_PATCH_SIZE, PATCH_SIZE, j, l, u], [u])) }, thread[1550] = function (t, e, i, r, n) { (reg = regions[e]) && (r -= reg.x, n -= reg.z, r += region_size2, n += region_size2, thread.postMessage([t, i, H(Math.floor(r), Math.floor(n))])) }, thread[3500] = function (t, r, n, a, s, o, _, l, u, h) { if (reg = regions[n]) { for (reg.QT || e(reg), rg_QT = reg.QT, qii = 0, function t(e, i, r, n, a, s, o) { var _ = qii; return s > -1 && (output[s + o] = _), output[_] = rg_QT[n], hh1 = H(e - r, i - r), hh2 = H(e + r, i - r), hh3 = H(e + r, i + r), hh4 = H(e - r, i + r), output[_ + 1] = hh1, output[_ + 2] = hh2, output[_ + 3] = hh3, output[_ + 4] = hh4, output[_ + 5] = Math.max(hh1, hh2, hh3, hh4), hh1 = H(e, i - r), hh2 = H(e, i + r), hh3 = H(e + r, i), hh4 = H(e - r, i), output[_ + 6] = hh1, output[_ + 7] = hh2, output[_ + 8] = hh3, output[_ + 9] = hh4, output[_ + 10] = H(e, i), output[_ + 5] = Math.max(output[_ + 5], output[_ + 10], hh1, hh2, hh3, hh4), qii += 11, r > WORKING_PATCH_SIZE || r > WORKING_MIN_PATCH_SIZE && rg_QT[n] > a ? (r *= .5, output[_ + 5] = Math.max(output[_ + 5], t(e - r, i - r, r, rg_QT[n + 1], a, _, 1), t(e + r, i - r, r, rg_QT[n + 2], a, _, 2), t(e - r, i + r, r, rg_QT[n + 3], a, _, 3), t(e + r, i + r, r, rg_QT[n + 4], a, _, 4)), output[_ + 5]) : output[_ + 5] }(region_size2, region_size2, region_size2, 0, Math.abs(a), -1, 0), j = qii, h = (reg_data = h.byteLength < 4 * j ? new Float32Array(j) : new Float32Array(h)).buffer, i = 0; i < qii;)reg_data[i] = output[i++]; this.postMessage([t, n, a, MIN_PATCH_SIZE, PATCH_SIZE, j, u, h], [h]) } }; var l = 2; return function (t, e, u, h, c, d, m, p, f, g) { if (reg = regions[u]) { if (a = h, function (t) { 0 === t ? (PATCH_SIZE = 4, MIN_PATCH_SIZE = 1, MIN_DETAIL = 1, CQT_DETAIL = 4, MIN_FAN_DETAIL = 2) : 1 === t && (PATCH_SIZE = 8, MIN_PATCH_SIZE = 2, CQT_DETAIL = 8, MIN_FAN_DETAIL = 2), 2 === t ? (PATCH_SIZE = 16, MIN_PATCH_SIZE = 4, CQT_DETAIL = 12, MIN_FAN_DETAIL = 2) : 3 === t ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 4, CQT_DETAIL = 9, MIN_FAN_DETAIL = 2) : 4 === t ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 8, CQT_DETAIL = 24, MIN_FAN_DETAIL = 4) : 5 === t ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 16, CQT_DETAIL = 32, MIN_FAN_DETAIL = 4) : 6 === t ? (PATCH_SIZE = 32, MIN_PATCH_SIZE = 16, CQT_DETAIL = 32, MIN_FAN_DETAIL = 8) : 7 === t ? (PATCH_SIZE = 64, MIN_PATCH_SIZE = 32, CQT_DETAIL = 32, MIN_FAN_DETAIL = 16) : 8 === t ? (PATCH_SIZE = 128, MIN_PATCH_SIZE = 64, CQT_DETAIL = 128, MIN_FAN_DETAIL = 32) : 9 === t && (PATCH_SIZE = 256, MIN_PATCH_SIZE = 32, CQT_DETAIL = 128, MIN_FAN_DETAIL = 64) }(e), check_for_edge_cases = !0, a < 0 ? (a = Math.abs(a), check_for_edge_cases = !1) : a > 1e3 && (check_for_edge_cases = !1), WORKING_PATCH_SIZE = PATCH_SIZE, WORKING_MIN_PATCH_SIZE = MIN_PATCH_SIZE, a > 32 && (WORKING_PATCH_SIZE *= 2, WORKING_MIN_PATCH_SIZE *= 2), time_start = Date.now(), vmap.fill(255), _ = !1, m & l && (_ = !0), _ || render_strips(MIN_PATCH_SIZE), oi = 0, o(reg, a), function (t, e, a, o, l) { if (i = t, s = PATCH_SIZE, _) for (; i < e;)x = output[i], z = output[i + 2], 222 !== vmap[vkey = ((n = z * l + o) + vindex_width2) * vindex_width + ((r = x * l + a) + vindex_width2)] ? (vmap[vkey] = 222, vdata[vkey *= 4] = H(x, z), reg.minh = Math.min(reg.minh, vdata[vkey]), reg.maxh = Math.max(reg.maxh, vdata[vkey])) : vkey *= 4, output[i + 1] = vdata[vkey], output[i] = r, output[i + 2] = n, i += 6; else for (; i < e;)x = output[i], z = output[i + 2], 222 !== vmap[vkey = ((n = z * l + o) + vindex_width2) * vindex_width + ((r = x * l + a) + vindex_width2)] ? (vmap[vkey] = 222, vdata[vkey *= 4] = H(x, z), nx = HH(x - s, z) - HH(x + s, z), ny = 2 * s, nz = HH(x, z - s) - HH(x, z + s), (_fp = nx * nx + ny * ny + nz * nz) > 0 && (_fp = 1 / Math.sqrt(_fp)), nx = .5 * (nx * _fp + 1) * 255, ny = .5 * (ny * _fp + 1) * 255, nz = .5 * (nz * _fp + 1) * 255, vdata[vkey + 1] = nx, vdata[vkey + 2] = ny, vdata[vkey + 3] = nz, reg.minh = Math.min(reg.minh, vdata[vkey]), reg.maxh = Math.max(reg.maxh, vdata[vkey])) : vkey *= 4, output[i + 1] = vdata[vkey], output[i + 3] = vdata[vkey + 1], output[i + 4] = vdata[vkey + 2], output[i + 5] = vdata[vkey + 3], output[i] = r, output[i + 2] = n, i += 6 }(0, oi, 0, 0, 1), j = 3 * Math.floor(oi / 6), g = (reg_data = g.byteLength < 4 * j ? new Float32Array(j) : new Float32Array(g)).buffer, i = 0, j = 0, _) for (; i < oi;)reg_data[j] = output[i + 2] * region_size1 + output[i], reg_data[j + 1] = output[i + 1], reg_data[j + 2] = output[i + 3], reg.minh = Math.min(reg.minh, reg_data[j + 1]), reg.maxh = Math.max(reg.maxh, reg_data[j + 1]), i += 6, j += 3; else for (; i < oi;)reg_data[j] = output[i + 2] * region_size1 + output[i], reg_data[j + 1] = output[i + 1], _fp = output[i + 3] << 16 | output[i + 4] << 8 | output[i + 5], reg_data[j + 2] = _fp / (1 << 24), reg.minh = Math.min(reg.minh, reg_data[j + 1]), reg.maxh = Math.max(reg.maxh, reg_data[j + 1]), i += 6, j += 3; rast_time = Date.now() - time_start, this.postMessage([t, u, h, reg.minh, reg.maxh, j, f, g], [g]) } } }(), thread.onmessage = function (t) { this[t.data[0]].apply(this, t.data) }, eval("(" + worker_overloaded.toString() + ")(thread)"), thread[9999] = function () { var t, e, i, r, n, a, s, o, _, l, u, h, c, d, m, p, f = function () { var t = {}; function e(t, e, i) { this.x = t, this.y = e, this.z = i } e.prototype.dot2 = function (t, e) { return this.x * t + this.y * e }, e.prototype.dot3 = function (t, e, i) { return this.x * t + this.y * e + this.z * i }; var i, r, n, a, s, o, _, l, u, h = [new e(1, 1, 0), new e(-1, 1, 0), new e(1, -1, 0), new e(-1, -1, 0), new e(1, 0, 1), new e(-1, 0, 1), new e(1, 0, -1), new e(-1, 0, -1), new e(0, 1, 1), new e(0, -1, 1), new e(0, 1, -1), new e(0, -1, -1)], c = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180], d = new Array(512), m = new Array(512); function p(t) { return t * t * t * (t * (6 * t - 15) + 10) } function f(t, e, i) { return (1 - i) * t + i * e } return t.seed = function (t) { for (t > 0 && t < 1 && (t *= 65536), (t = Math.floor(t)) < 256 && (t |= t << 8), i = 0; i < 256; i++)r = 1 & i ? c[i] ^ 255 & t : c[i] ^ t >> 8 & 255, d[i] = d[i + 256] = r, m[i] = m[i + 256] = h[r % 12] }, t.perlin = function (t, e) { return n = Math.floor(t), a = Math.floor(e), t -= n, e -= a, s = m[(n &= 255) + d[a &= 255]].dot2(t, e), o = m[n + d[a + 1]].dot2(t, e - 1), _ = m[n + 1 + d[a]].dot2(t - 1, e), l = m[n + 1 + d[a + 1]].dot2(t - 1, e - 1), u = p(t), f(f(s, _, u), f(o, l, u), p(e)) }, t }(), g = 0; return function (v, w, x, y, b, E) { for (f.seed(w.seed), h = w.offset_x, c = w.offset_z, d = w.height_scale, e = w.layers, p = 0; p < b; p++)for (m = 0; m < b; m++) { for (i = m + h * (b - 1), r = p + c * (b - 1), _ = 0, g = 0; g < e.length; g++) { for (t = e[g], s = t.base_roughness, o = 1, n = 0, a = 0; a < t.octaves; a++)n += (f.perlin(i / b * s, r / b * s) / 2 + .5) * o, s *= t.roughness, o *= t.persistence; _ += n * t.strength } l = Math.max(l, _), u = Math.min(u, _), output[p * b + m] = _ * d } this[200](200, x, y, b, output, E) } }() }, [this.worker_overloaded]); this.worker = worker, this.worker.processor = this, this.update_reg_bounds = function (t) { t.rad = (t.maxh - t.minh) / 2 * 1, t.y = t.minh + t.rad, t.a_minx = Math.min(t.x - this.region_size_half, t.x + this.region_size_half), t.a_miny = Math.min(t.y - t.rad, t.y + t.rad), t.a_minz = Math.min(t.z - this.region_size_half, t.z + this.region_size_half), t.a_maxx = Math.max(t.x - this.region_size_half, t.x + this.region_size_half), t.a_maxy = Math.max(t.y - t.rad, t.y + t.rad), t.a_maxz = Math.max(t.z - this.region_size_half, t.z + this.region_size_half) }, this.worker[100] = function (t, e) { }, this.worker[200] = function (t, e, i, r, n, a) { var s = this.processor.regions[e] || { key: e, last_time: 0, detail: -1, reg_x: i, reg_z: r, state: 0, req_detail: -1, type: 1, visibled: !0 }; for (var o in s.state = 0, s.detail = -1, s.reg_detail = -1, s.maxh = a, s.minh = n, s.x = i * this.processor.region_size * 1, s.z = r * this.processor.region_size * 1, this.processor.update_reg_bounds(s), this.processor.regions[e] = s, this.processor.hosts) this.processor.hosts[o].on_new_region(s) }, this.worker[300] = function (t, e, i) { (reg = this.processor.regions[e]) && (reg.CQT = new Int16Array(i)) }, this.worker[2300] = function (t, e, i, r) { (reg = this.processor.regions[e]) && (console.log(i, r), reg.smap = new ge.webgl.texture(void 0, void 0, void 0, new Uint8Array(r), void 0, i, i), reg.smap.enable_clamp_to_edge()) }, this.worker[1550] = function (t, e, i) { this.processor.query_heights[e] = i }, this.query_height = function (t, e, i) { reg_x = Math.floor(e / this.region_size + .5), reg_z = Math.floor(i / this.region_size + .5), reg_key = reg_z * this.world_size + reg_x, reg = this.regions[reg_key], this.query_heights[t] = -1 / 0, reg && this.worker.postMessage([1550, reg.key, t, e, i]) }, worker.request_region = function () { var t = new fin.queue, e = [new ArrayBuffer(1), new ArrayBuffer(1), new ArrayBuffer(1)], i = []; console.log("reg_data_buffers", e); var r = 0; function n() { for (r = 0; r < e.length;) { if (e[r].byteLength > 0) return r; r++ } return -1 } var a = 0; worker[2e3] = function (r, n, a, s, o, _, l, u) { (reg = this.processor.regions[n]).minh = s, reg.maxh = o, this.processor.update_reg_bounds(reg), this.processor.hosts[i[l]].on_region_data(reg, new Float32Array(u), _, a), e[l] = u, t.size() > 0 && this.region_parked_request(t.dequeue()) }, worker[2010] = function (i, r, n, a, s, o, _, l) { e[_] = l, t.size() > 0 && this.region_parked_request(t.dequeue()) }, worker[3e3] = function (r, n, a, s, o, _, l, u) { this.processor.hosts[i[l]].on_region_qt(this.processor.regions[n], new Float32Array(u), _, s, o, a), e[l] = u, t.size() > 0 && this.region_parked_request(t.dequeue()) }, worker[3500] = function (r, n, a, s, o, _, l, u) { this.processor.hosts[i[l]].on_region_cqt(this.processor.regions[n], new Float32Array(u), _, s, o, a), e[l] = u, t.size() > 0 && this.region_parked_request(t.dequeue()) }; var s = new fin.object_pooler(function () { return { host_id: 0, param1: [null, null, null, null, null, null, null, null, null, null], param2: [null] } }); return console.log("request_pool", s), worker.region_parked_request = function (r) { (a = n()) > -1 ? (i[a] = r.host_id, r.param1[8] = a, r.param1[9] = e[a], r.param2[0] = e[a], this.postMessage(r.param1, r.param2), r.param1[9] = null, r.param2[0] = null, s.free(r)) : t.enqueue(r) }, function (r, o, _, l, u, h) { if (2 !== o.state) return o; var c = s.get(); return c.param1[0] = r, c.param1[1] = o.terrain_quality || this.processor.terrain_quality, c.param1[2] = o.key, c.param1[3] = o.req_detail, c.param1[4] = _, c.param1[5] = l, c.param1[6] = u, c.param1[7] = h, (a = n()) > -1 ? (i[a] = o.host_id, c.param1[8] = a, c.param1[9] = e[a], c.param2[0] = e[a], this.postMessage(c.param1, c.param2), c.param1[5] = null, c.param2[0] = null, s.free(c)) : (c.host_id = o.host_id, t.enqueue(c)), o } }(), this.worker.onmessage = function (t) { this[t.data[0]].apply(this, t.data) } } }(); var reg, reg_x, reg_z, reg_key, i = 0, render_item = null; function ge_terrain_processor(t) { t = t || {}, this.region_size = t.region_size || 512, this.world_size = t.world_size || 8192, this.region_size_width = this.region_size + 1, this.region_size_half = .5 * this.region_size, this.regions = {}, this.world_size_half = .5 * this.world_size, this.timer = 0, this.last_validate_time = 0, this.last_updated_time = 0, this.terrain_quality = t.terrain_quality || 4, this.sun_direction = t.sun_direction || [.5, .5, .3], this.worker_overloaded = "var worker_overloaded=function(thread){}", t.worker && (this.worker_overloaded = "var worker_overloaded=" + t.worker.toString()), this.setup_mesh_processor(), this.def_regions_from_image_url = t.regions_from_image_url, this.on_initialized = t.on_initialized || null, this.initialized = !1, this.initialize(), this.hosts = {}, this.query_heights = {} } return proto.initialize = function () { if (this.update_terrain_parameters(), this.def_regions_from_image_url) for (i = 0; i < this.def_regions_from_image_url.length; i++)this.regions_from_image_url.apply(this, this.def_regions_from_image_url[i]); null !== this.on_initialized && this.on_initialized(this), this.initialized = !0 }, proto.add_host = function (t) { t.host_id = ge.guidi(), this.hosts[t.host_id] = t }, ge_terrain_processor }); var glsl = ge.webgl.shader.create_chunks_lib("/*chunk-default-material*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nuniform mat4 u_view_projection_rw;\n\nuniform vec4 reg_pos;\nuniform vec3 cam_reg_pos;\n\nuniform vec3 u_terrain_scale;\n\n\n\n\nvarying vec4 v_position_rw;\nvarying vec3 v_normal_rw;\nvarying vec2 v_uv_rw;\nvarying mat3 v_tbn_matrix;\n\n\n<?=chunk('mat3-transpose')?>\n\nvoid vertex(void){\n  v_position_rw.z=floor(a_position_rw.x/cam_reg_pos.z);\n  v_position_rw.x=floor(mod(a_position_rw.x,cam_reg_pos.z));\n  v_position_rw.y=a_position_rw.y;  \n\n\n  v_normal_rw.x = fract(a_position_rw.z);\n  v_normal_rw.y = fract(a_position_rw.z* 256.0);  \n  v_normal_rw.z = fract(a_position_rw.z * 65536.0);  \n\n\n   v_normal_rw.x = (v_normal_rw.x * 2.0) - 1.0;\n  v_normal_rw.y = (v_normal_rw.y * 2.0) - 1.0;\n  v_normal_rw.z = (v_normal_rw.z * 2.0) - 1.0;  \n\n\n  v_position_rw.w=1.0; \n  \n  //v_position_rw.xyz+=(v_normal_rw*u_terrain_scale);\n\n  v_uv_rw=v_position_rw.xz/cam_reg_pos.z;        \n  \n  //v_uv_rw+=0.5;\n\n  v_position_rw.xyz*=u_terrain_scale;\n  \n //  v_position_rw.xz-=((cam_reg_pos.z)*0.5);\n  // v_position_rw.xz*=reg_pos.w;\n\n  //v_position_rw.xz*=0.99;\n  v_position_rw.xz+=reg_pos.xz;   \n // v_position_rw.y=0.0;\n\n \n\n  gl_Position = u_view_projection_rw *v_position_rw;\n\n // v_uv_rw=v_position_rw.xz;        \n // v_uv_rw/=(cam_reg_pos.z);    \n  v_normal_rw=normalize(v_normal_rw);\n\n}\n\n<?=chunk('precision')?>\n\nuniform mat4 u_object_material_rw;\nuniform vec4 u_eye_position_rw;\nuniform vec4 reg_pos;\nuniform vec3 cam_reg_pos;\n\nvarying vec4 v_position_rw;\nvarying vec3 v_normal_rw;\nvarying vec2 v_uv_rw;\nvarying mat3 v_tbn_matrix;\n\n<?=chunk('global-render-system-lighting')?>\n\n<?=chunk('global-render-system-fog-effect')?>\n\n\nuniform vec4 land_color;\n\nuniform sampler2D u_texture_tiles_rw;\nuniform sampler2D u_normalmap_tiles_rw;\nuniform sampler2D u_shadow_map_rw;\n\nuniform vec2 u_tile_size_rw;\nuniform vec4 u_texture_repeat_rw;\nuniform vec4 u_normalmap_repeat_rw;\n\nfloat tile_size;\nvec2 tile_uv;\nvec2 uv=vec2(0);\nfloat tile_offset;\n\nvec4 mix_texture_tiles(vec4 tile1,vec4 tile2,vec4 tile3,vec4 tile4,vec3 normal);\nvec3 mix_normal_tiles(vec3 tile1,vec3 tile2,vec3 tile3,vec3 tile4,vec3 normal);\n\nvec4 read_tile(sampler2D texture,float tile_repeat, float tx,float ty);\n\nvec3 mix_normal_tiles(vec3 tile1,vec3 tile2,vec3 tile3,vec3 tile4,vec3 normal){\n\n\n\treturn mix(tile1,tile4,abs(normal.x));\n}\n\nvec4 mix_texture_tiles(vec4 tile1,vec4 tile2,vec4 tile3,vec4 tile4,vec3 normal){\n\treturn mix(tile4,tile2,0.5);\n}\n\n\nvec4 read_tile(sampler2D texture,float tile_repeat, float tx,float ty){\n\n    uv.x=mod(v_uv_rw.x*tile_repeat,tile_size-(tile_offset*2.0));\n    uv.y=mod(v_uv_rw.y*tile_repeat,tile_size-(tile_offset*2.0));\n    uv.x+=tx*tile_size+tile_offset;\n    uv.y+=ty*tile_size+tile_offset;\n    return texture2D(texture, uv);\n}\n\n\n\nvec2 texelSize=vec2(1.0/128.0,1.0/128.0);\nfloat sample_smap(vec2 coords){\t\n\tvec2 pixelPos = coords / texelSize + vec2(0.5);\n\tvec2 fracPart = fract(pixelPos);\n\tvec2 startTexel = (pixelPos - fracPart) * texelSize;\n\tfloat blTexel = texture2D(u_shadow_map_rw, startTexel).r;\n\tfloat brTexel = texture2D(u_shadow_map_rw, startTexel + vec2(texelSize.x, 0.0)).r;\n\tfloat tlTexel = texture2D(u_shadow_map_rw, startTexel + vec2(0.0, texelSize.y)).r;\n\tfloat trTexel = texture2D(u_shadow_map_rw, startTexel + texelSize).r;\n\tfloat mixA = mix(blTexel, tlTexel, fracPart.y);\n\tfloat mixB = mix(brTexel, trTexel, fracPart.y);\n\treturn mix(mixA, mixB, fracPart.x);\n}\n\n\n\nfloat sample_smap_pcf(vec2 coords)\n{\n\tconst float NUM_SAMPLES = 3.0;\n\tconst float SAMPLES_START = (NUM_SAMPLES - 1.0) / 2.0;\n\tconst float NUM_SAMPLES_SQUARED = NUM_SAMPLES * NUM_SAMPLES;\n\tfloat result = 0.0;\n\tfor (float y = -SAMPLES_START; y <= SAMPLES_START; y += 1.0)\n\t{\n\t\tfor (float x = -SAMPLES_START; x <= SAMPLES_START; x += 1.0)\n\t\t{\n\t\t\tvec2 coordsOffset = vec2(x, y) * texelSize;\n\t\t\tresult += sample_smap(coords + coordsOffset);\n\t\t}\n\t}\n\treturn result / NUM_SAMPLES_SQUARED;\n}\n\n\n\n\nvoid fragment(void) {\t\n\ntile_size=u_tile_size_rw.x;\ntile_offset=u_tile_size_rw.y;\n\n\n\n\n  \n\tvec4 tile1=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.x, 0.0,0.0);\n\tvec4 tile2=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.y, 1.0,0.0);\n\tvec4 tile3=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.z, 0.0,1.0);\n\tvec4 tile4=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.w, 1.0,1.0);\n\n\tvec3 norm1=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.x, 0.0,0.0).xyz - 1.0);\n\tvec3 norm2=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.y, 1.0,0.0).xyz - 1.0);\n\tvec3 norm3=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.z, 0.0,1.0).xyz - 1.0);\n\tvec3 norm4=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.w, 1.0,1.0).xyz - 1.0);\n\n\n\n\t\n\tvec3 normal= mix_normal_tiles(norm1,norm2,norm3,norm4,v_normal_rw);\n\tnormal=normalize(v_normal_rw+normal);\n\n\t vec3 fws_direction_to_eye = normalize(u_eye_position_rw.xyz - v_position_rw.xyz);\t\t\n\tvec3 total_light=get_render_system_lighting(u_object_material_rw,v_position_rw.xyz,\n\tnormal,\n\tfws_direction_to_eye);\n\t\n\t//*texture2D(u_shadow_map_rw, v_uv_rw).r;\t\n\n\t\n\n\n\tgl_FragColor = vec4((total_light)*(land_color.xyz), u_object_material_rw[0].w)*\t\n\tmix_texture_tiles(tile1,tile2,tile3,tile4,normal);\n\n\tgl_FragColor*=sample_smap_pcf(v_uv_rw);\n\t//gl_FragColor = texture2D(u_shadow_map_rw, v_uv_rw);\n\n\t//gl_FragColor=mix_fog_color(gl_FragColor);\n\t//gl_FragColor=texture2D(u_texture_tiles_rw, v_uv_rw);\n\t//gl_FragColor=vec4(1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*chunk-default-patch-material*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nuniform mat4 u_view_projection_rw;\n\nvarying vec4 v_position_rw;\nvarying vec3 v_normal_rw;\nvarying vec2 v_uv_rw;\nvarying mat3 v_tbn_matrix;\n\n\n<?=chunk('mat3-transpose')?>\n\nvoid vertex(void){\n  v_position_rw.z=floor(a_position_rw.x/cam_reg_pos.z);\n  v_position_rw.x=floor(mod(a_position_rw.x,cam_reg_pos.z));\n  v_position_rw.y=a_position_rw.y;  \n\n\n  v_normal_rw.x = fract(a_position_rw.z);\n  v_normal_rw.y = fract(a_position_rw.z* 256.0);  \n  v_normal_rw.z = fract(a_position_rw.z * 65536.0);  \n\n\n   v_normal_rw.x = (v_normal_rw.x * 2.0) - 1.0;\n  v_normal_rw.y = (v_normal_rw.y * 2.0) - 1.0;\n  v_normal_rw.z = (v_normal_rw.z * 2.0) - 1.0;  \n\n\n  v_position_rw.w=1.0; \n  \n  //v_position_rw.xyz+=(v_normal_rw*u_terrain_scale);\n\n  v_uv_rw=v_position_rw.xz/cam_reg_pos.z;        \n  \n  //v_uv_rw+=0.5;\n\n  v_position_rw.xyz*=u_terrain_scale;\n  \n //  v_position_rw.xz-=((cam_reg_pos.z)*0.5);\n  // v_position_rw.xz*=reg_pos.w;\n\n  //v_position_rw.xz*=0.99;\n  v_position_rw.xz+=reg_pos.xz;   \n // v_position_rw.y=0.0;\n\n \n\n  gl_Position = u_view_projection_rw *v_position_rw;\n\n // v_uv_rw=v_position_rw.xz;        \n // v_uv_rw/=(cam_reg_pos.z);    \n  v_normal_rw=normalize(v_normal_rw);\n\n}\n\n<?=chunk('precision')?>\n\nuniform mat4 u_object_material_rw;\nuniform vec4 u_eye_position_rw;\nuniform vec4 reg_pos;\nuniform vec3 cam_reg_pos;\n\nvarying vec4 v_position_rw;\nvarying vec3 v_normal_rw;\nvarying vec2 v_uv_rw;\nvarying mat3 v_tbn_matrix;\n\n<?=chunk('global-render-system-lighting')?>\n\n<?=chunk('global-render-system-fog-effect')?>\n\n\nuniform vec4 land_color;\n\nuniform sampler2D u_texture_tiles_rw;\nuniform sampler2D u_normalmap_tiles_rw;\nuniform sampler2D u_shadow_map_rw;\n\nuniform vec2 u_tile_size_rw;\nuniform vec4 u_texture_repeat_rw;\nuniform vec4 u_normalmap_repeat_rw;\n\nfloat tile_size;\nvec2 tile_uv;\nvec2 uv=vec2(0);\nfloat tile_offset;\n\nvec4 mix_texture_tiles(vec4 tile1,vec4 tile2,vec4 tile3,vec4 tile4,vec3 normal);\nvec3 mix_normal_tiles(vec3 tile1,vec3 tile2,vec3 tile3,vec3 tile4,vec3 normal);\n\nvec4 read_tile(sampler2D texture,float tile_repeat, float tx,float ty);\n\nvec3 mix_normal_tiles(vec3 tile1,vec3 tile2,vec3 tile3,vec3 tile4,vec3 normal){\n\n\n\treturn mix(tile1,tile4,abs(normal.x));\n}\n\nvec4 mix_texture_tiles(vec4 tile1,vec4 tile2,vec4 tile3,vec4 tile4,vec3 normal){\n\treturn mix(tile4,tile2,0.5);\n}\n\n\nvec4 read_tile(sampler2D texture,float tile_repeat, float tx,float ty){\n\n    uv.x=mod(v_uv_rw.x*tile_repeat,tile_size-(tile_offset*2.0));\n    uv.y=mod(v_uv_rw.y*tile_repeat,tile_size-(tile_offset*2.0));\n    uv.x+=tx*tile_size+tile_offset;\n    uv.y+=ty*tile_size+tile_offset;\n    return texture2D(texture, uv);\n}\n\n\n\nvec2 texelSize=vec2(1.0/128.0,1.0/128.0);\nfloat sample_smap(vec2 coords){\t\n\tvec2 pixelPos = coords / texelSize + vec2(0.5);\n\tvec2 fracPart = fract(pixelPos);\n\tvec2 startTexel = (pixelPos - fracPart) * texelSize;\n\tfloat blTexel = texture2D(u_shadow_map_rw, startTexel).r;\n\tfloat brTexel = texture2D(u_shadow_map_rw, startTexel + vec2(texelSize.x, 0.0)).r;\n\tfloat tlTexel = texture2D(u_shadow_map_rw, startTexel + vec2(0.0, texelSize.y)).r;\n\tfloat trTexel = texture2D(u_shadow_map_rw, startTexel + texelSize).r;\n\tfloat mixA = mix(blTexel, tlTexel, fracPart.y);\n\tfloat mixB = mix(brTexel, trTexel, fracPart.y);\n\treturn mix(mixA, mixB, fracPart.x);\n}\n\n\n\nfloat sample_smap_pcf(vec2 coords)\n{\n\tconst float NUM_SAMPLES = 3.0;\n\tconst float SAMPLES_START = (NUM_SAMPLES - 1.0) / 2.0;\n\tconst float NUM_SAMPLES_SQUARED = NUM_SAMPLES * NUM_SAMPLES;\n\tfloat result = 0.0;\n\tfor (float y = -SAMPLES_START; y <= SAMPLES_START; y += 1.0)\n\t{\n\t\tfor (float x = -SAMPLES_START; x <= SAMPLES_START; x += 1.0)\n\t\t{\n\t\t\tvec2 coordsOffset = vec2(x, y) * texelSize;\n\t\t\tresult += sample_smap(coords + coordsOffset);\n\t\t}\n\t}\n\treturn result / NUM_SAMPLES_SQUARED;\n}\n\n\n\n\nvoid fragment(void) {\t\n\ntile_size=u_tile_size_rw.x;\ntile_offset=u_tile_size_rw.y;\n\n\n\n\n  \n\tvec4 tile1=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.x, 0.0,0.0);\n\tvec4 tile2=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.y, 1.0,0.0);\n\tvec4 tile3=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.z, 0.0,1.0);\n\tvec4 tile4=read_tile(u_texture_tiles_rw,u_texture_repeat_rw.w, 1.0,1.0);\n\n\tvec3 norm1=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.x, 0.0,0.0).xyz - 1.0);\n\tvec3 norm2=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.y, 1.0,0.0).xyz - 1.0);\n\tvec3 norm3=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.z, 0.0,1.0).xyz - 1.0);\n\tvec3 norm4=(2.0 * read_tile(u_normalmap_tiles_rw,u_normalmap_repeat_rw.w, 1.0,1.0).xyz - 1.0);\n\n\n\n\t\n\tvec3 normal= mix_normal_tiles(norm1,norm2,norm3,norm4,v_normal_rw);\n\tnormal=normalize(v_normal_rw+normal);\n\n\t vec3 fws_direction_to_eye = normalize(u_eye_position_rw.xyz - v_position_rw.xyz);\t\t\n\tvec3 total_light=get_render_system_lighting(u_object_material_rw,v_position_rw.xyz,\n\tnormal,\n\tfws_direction_to_eye);\n\t\n\t//*texture2D(u_shadow_map_rw, v_uv_rw).r;\t\n\n\t\n\n\n\tgl_FragColor = vec4((total_light)*(land_color.xyz), u_object_material_rw[0].w)*\t\n\tmix_texture_tiles(tile1,tile2,tile3,tile4,normal);\n\n\tgl_FragColor*=sample_smap_pcf(v_uv_rw);\n\t//gl_FragColor = texture2D(u_shadow_map_rw, v_uv_rw);\n\n\t//gl_FragColor=mix_fog_color(gl_FragColor);\n\t//gl_FragColor=texture2D(u_texture_tiles_rw, v_uv_rw);\n\t//gl_FragColor=vec4(1.0);\n}\n\n\n\n\n\n\n\n\n\n\n/*chunk-oclusion*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nuniform mat4 u_view_projection_rw;\nuniform vec3 reg_pos;\nuniform vec3 cam_reg_pos;\n\nvoid vertex(void){\n  gl_Position.z=floor(a_position_rw.x/cam_reg_pos.z);\n  gl_Position.x=floor(mod(a_position_rw.x,cam_reg_pos.z));\n  gl_Position.y=a_position_rw.y; \n  gl_Position.w=1.0;     \n  gl_Position.xz+=reg_pos.xz;    \n  gl_Position = u_view_projection_rw *gl_Position;\n}\n\n<?=chunk('precision')?>\nuniform vec4 land_color;\nvoid fragment(void) {\t\n\tgl_FragColor=land_color/255.0;\n\n}\n\n\n\n\n\n\n\n\n"); ge.terrain.material = ge.define(function (t, e) { function i(t) { t = t || {}, e.apply(this, [t]), math.vec3.set(this.ambient, .5, .5, .5), math.vec3.set(this.specular, 0, 0, 0), this.flags += 32, this.texture_tiles = null, this.normalmap_tiles = null, this.tile_size = math.vec2(512, 0), this.texture_repeat = math.vec4(t.tile_repeat || [8, 8, 8, 8]), this.normalmap_repeat = math.vec4(1, 1, 1, 1), this.shader = i.shader, t.normalmap_tiles ? this.normalmap_tiles = ge.webgl.texture.create_tiled_texture(t.normalmap_tiles, t.material.tile_size || 512, t.material.texture_size || 1024, t.material.texture_size || 1024) : this.normalmap_tiles = new ge.webgl.texture, t.texture_tiles ? (this.texture_tiles = ge.webgl.texture.create_tiled_texture(t.texture_tiles, t.tile_size || 512, t.texture_size || 1024, t.texture_size || 1024), this.texture_tiles.enable_clamp_to_edge()) : (this.texture_tiles = new ge.webgl.texture, this.texture_tiles.tile_sizef = 1, this.texture_tiles.tile_offsetf = 1), void 0 !== t.transparent && this.set_tansparency(t.transparent), t.shader && (this.shader = this.shader.extend(t.shader)) } return t.render_mesh = function (t, e, i) { i.renderer ? (1024 & this.flags ? t.gl_disable(2929) : t.gl_enable(2929), 0 != (2048 & this.flags) ? t.gl_disable(2884) : t.gl_enable(2884), e.set_uniform("u_object_material_rw", this.object_material), this.tile_size[0] = this.texture_tiles.tile_sizef, this.tile_size[1] = this.texture_tiles.tile_offsetf, e.set_uniform("u_tile_size_rw", this.tile_size), e.set_uniform("u_texture_repeat_rw", this.texture_repeat), e.set_uniform("u_normalmap_repeat_rw", this.normalmap_repeat), t.use_texture(this.texture_tiles, 0), t.use_texture(this.normalmap_tiles, 1), e.set_uniform("u_normalmap_tiles_rw", 1), i.render_terrain(t, e)) : i.renderer = t }, i.shader = ge.webgl.shader.parse(glsl["default-material"]), i }, ge.shading.shaded_material), ge.terrain.material.oclusion = ge.define(function (t, e) { function i(t) { t = t || {}, e.apply(this, [t]), this.shader = i.shader, t.shader && (this.shader = this.shader.extend(t.shader)), this.flags += 2 } return t.render_mesh = function (t, e, i) { i.renderer ? (1024 & this.flags ? t.gl_disable(2929) : t.gl_enable(2929), 0 != (2048 & this.flags) ? t.gl_disable(2884) : t.gl_enable(2884), i.render_terrain(t, e)) : i.renderer = t }, i.shader = ge.webgl.shader.parse(glsl.oclusion), i }, ge.shading.material), ge.terrain.mesh = ge.define(function (t, e) { return t.update = function () { var e, r; t.validate_regions = function () { if (!(this.timer - this.last_validate_time < 5)) for (e in this.last_validate_time = this.timer, this.regions) (r = this.regions[e]).state > 0 && this.timer - r.last_time > 2 && (r.last_time = this.timer, r.buffer && (ge.renderer.gl_buffers.free(r.buffer), r.buffer = void 0, r.detail = -1, this.on_region_dispose(r))) }, t.request_region = function (t, e) { t.detail !== e && 2 !== t.state && (t.req_detail = e, t.state = 2, this.requested_regions[this.rqi++] = t), t.buffer && (this.on_region_activated(t), this.regions_to_render[this.ri++] = t), t.last_time = this.timer }, t.update_terrain_frustum = function () { var t, e, i, r, n, a, s, o, _ = 0; return function (l, u, h) { if (s = this.processor, o = s.region_size, reg_x = (this.cam_reg_x + (l + .5)) * o, reg_z = (this.cam_reg_z + (u + .5)) * o, h > .5) { if (r = h * o, t = Math.min(reg_x - r, reg_x + r), e = -400, i = Math.min(reg_z - r, reg_z + r), fmaxx = Math.max(reg_x - r, reg_x + r), fmaxy = this.draw_distance, fmaxz = Math.max(reg_z - r, reg_z + r), this.camera._frustum_aabb(t, e, i, fmaxx, fmaxy, fmaxz)) return h *= .5, this.update_terrain_frustum(l - h, u - h, h), this.update_terrain_frustum(l + h, u - h, h), this.update_terrain_frustum(l - h, u + h, h), void this.update_terrain_frustum(l + h, u + h, h) } else if (reg_x = this.cam_reg_x + (l + .5), reg_z = this.cam_reg_z + (u + .5), reg_key = reg_z * s.world_size + reg_x, (a = s.regions[reg_key]) && (n = this.regions[reg_key], this.camera._frustum_aabb(a.a_minx, a.a_miny, a.a_minz, a.a_maxx, a.a_maxy, a.a_maxz))) { if (_ = function (t, e, i) { return Math.abs(Math.sqrt(t * t + e * e + i * i)) }(this.camera.world_position[0] - a.x, this.camera.world_position[1] - a.y, this.camera.world_position[2] - a.z), n.distance = _, _ - s.region_size_half > this.draw_distance) return; if (this.region_margin > 1 && (0 !== Math.abs(a.reg_x % this.region_margin) || 0 !== Math.abs(a.reg_z % this.region_margin))) return; -1 !== this.fixed_detail ? this.request_region(n, this.fixed_detail) : n.distance < s.region_size ? this.request_region(n, this.detail_levels[0]) : (_ = Math.min(_ / this.quality_distance, 1), this.request_region(n, this.detail_levels[Math.floor((this.detail_levels.length - 1) * _)])) } } }(); var n = function (t, e) { return t.distance - e.distance }, a = 0; return function (t, e) { this.camera = t, this.timer = e; var r = this.processor; if (!((a = e - this.last_updated_time) < this.time_step_size)) { if (this.last_updated_time = e - a % this.time_step_size, this.camera_version = this.camera.version, this.cam_reg_x = Math.floor(this.camera.world_position[0] / r.region_size + .5), this.cam_reg_z = Math.floor(this.camera.world_position[2] / r.region_size + .5), this.cam_reg = this.regions[this.cam_reg_z * this.processor.world_size + this.cam_reg_x], this.cam_reg && (r.query_heights[-1024] > -1 / 0 && (0 === this.camera_pos_y ? this.camera_pos_y = r.query_heights[-1024] : this.camera_pos_y += (r.query_heights[-1024] - this.height_on_camera) % 42, this.height_on_camera = r.query_heights[-1024], r.query_heights[-1024] = -1 / 0, this.camera_pos_y = Math.max(this.height_on_camera, this.camera_pos_y)), this.camera_pos_x === this.camera.world_position[0] && this.camera_pos_z === this.camera.world_position[2] || (this.camera_pos_x = this.camera.world_position[0], this.camera_pos_z = this.camera.world_position[2], r.query_height(-1024, this.camera_pos_x, this.camera_pos_z)), this.camera_vel_y -= .1 * this.camera_vel_y, this.camera_vel_y = Math.max(0, this.camera_vel_y)), this.update_requested = !1, this.last_updated_time = e, this.ri = 0, this.rqi = 0, this.er = 0, this.update_terrain_frustum(0, 0, this.region_distance * this.region_margin), this.rqi > 0) if (this.requested_regions = fin.merge_sort(this.requested_regions, this.rqi, n), i = 0, this.region_margin > 1) for (; i < this.rqi;)r.worker.request_region(5e3, this.requested_regions[i++], this.region_margin, this.region_offset, this.cam_reg_z, this.cam_reg_x).last_time = e; else for (; i < this.rqi;)r.worker.request_region(2e3, this.requested_regions[i++], this.cam_reg_x, this.cam_reg_z, this.reg_req_flags).last_time = e; i = 0, this.validate_regions() } } }(), t.on_new_region = function (t) { return this.regions[t.key] ? (this.regions[t.key].reg_detail = 0, this.regions[t.key].detail = 0) : this.regions[t.key] = { key: t.key, host_id: this.host_id, req_detail: 0, terrain_quality: this.terrain_quality, last_time: 0 }, this.regions[t.key] }, t.on_region_dispose = function (t) { }, t.on_region_activated = function (t) { }, t.on_region_data = function (t, e, i, r) { var n = this.regions[t.key]; if (n.state = 1, this.renderer) { if (n.ds = 0, n.di = i / 3, n.detail = r, n.buffer = n.buffer || ge.renderer.gl_buffers.get(this.renderer.gl), this.renderer.gl.bindBuffer(34962, n.buffer), this.renderer.gl.bufferData(34962, e, 35048, 0, i), this.on_region_activated(n), this.region_margin > 1) { var a = this.processor.region_size_half * this.region_margin; t.a_minx = Math.min(t.x - a, t.x + a), t.a_minz = Math.min(t.z - a, t.z + a), t.a_maxx = Math.max(t.x - a, t.x + a), t.a_maxz = Math.max(t.z - a, t.z + a) } return n } }, t.on_region_render = function (t, e, i) { }, t.render_terrain = function () { var t, e, i, r = math.vec4(), n = math.vec3(), a = (new Float32Array(4), new Uint32Array(1)), s = (new Uint8Array(a.buffer), 0); return function (a, o) { for (n[0] = this.cam_reg_x * this.processor.region_size, n[1] = this.cam_reg_z * this.processor.region_size, (i = o.uniforms.cam_reg_pos).params[i.params_length] = n, i.func.apply(o.gl, i.params), n[2] = this.processor.region_size + 1, a.use_texture(a.default_texture, 2), (i = o.uniforms.u_shadow_map_rw) && (i.params[i.params_length] = 2, i.func.apply(o.gl, i.params)), (i = o.uniforms.u_terrain_scale) && (i.params[i.params_length] = this.terrian_scale, i.func.apply(o.gl, i.params)), this.time_start = Date.now(), a.bind_default_wireframe_indices(), this.tri_count = 0, s = 0, this.region_max_tris = 0, this.rendered_regions = 0; s < this.ri;)t = this.regions_to_render[s++], e = this.processor.regions[t.key], t.last_time = this.timer, this.region_offset > 0 && Math.floor(Math.abs(this.cam_reg_x - e.reg_x) + Math.abs(this.cam_reg_z - e.reg_z)) < this.region_offset || t.buffer && (this.tri_count += t.di, this.region_max_tris = Math.max(this.region_max_tris, t.di), this.region_margin > 1 ? (r[0] = e.x - this.processor.region_size_half * this.region_margin, r[2] = e.z - this.processor.region_size_half * this.region_margin) : (r[0] = e.x - this.processor.region_size_half, r[2] = e.z - this.processor.region_size_half), r[1] = 0, r[3] = this.region_margin, a.gl.bindBuffer(34962, t.buffer), a.gl.vertexAttribPointer(0, 3, 5126, !1, 12, 0), (i = o.uniforms.reg_pos).params[i.params_length] = r, i.func.apply(o.gl, i.params), this.on_region_render(t, a, o), this.wireframe && ((i = o.uniforms.land_color) && (i.params[i.params_length] = this.wire_color, i.func.apply(o.gl, i.params)), a.gl.drawElements(1, 2 * t.di, 5125, 2 * t.ds * 4)), this.shaded && (e.smap ? a.use_texture(e.smap, 2) : a.use_texture(a.default_texture, 2), (i = o.uniforms.land_color) && (i.params[i.params_length] = this.shaded_color, i.func.apply(o.gl, i.params)), a.gl.drawArrays(4, t.ds, t.di)), this.rendered_regions++); this.render_time = Date.now() - this.time_start } }(), function (t) { t = t || {}, e.apply(this, [t]), this.geometry = ge.geometry.geometry_data.create({ vertices: new Float32Array(0) }), this.material = t.material || new ge.terrain.material, this.processor = t.processor, this.regions = {}, this.processor.add_host(this), this.camera_version = -121, this.terrian_scale = math.vec3(t.terrian_scale), this.ri = 0, this.rqi = 0, this.regions = {}, this.region_max_tris = 0, this.camera_pos_x = 1 / 0, this.camera_pos_z = 1 / 0, this.camera_pos_y = 0, this.camera_vel_y = 0, this.timer = 0, this.terrain_quality = t.terrain_quality || 4, this.last_validate_time = 0, this.last_updated_time = 0, this.fixed_detail = -1, this.region_offset = t.region_offset || 0, this.region_margin = t.region_margin || 1, this.rendered_regions = 0, void 0 !== t.fixed_detail && (this.fixed_detail = t.fixed_detail), this.region_distance = t.region_distance || 4, this.draw_distance = t.draw_distance || 2e3, this.quality_distance = t.quality_distance || 1500, this.detail_levels = t.detail_levels || [1, 2, 6, 12, 20], this.height_on_camera = 0, this.time_step_size = t.time_step_size || 1 / 15, this.shaded_color = math.vec4(t.shaded_color || [1, 1, 1, 1]), this.wire_color = math.vec4(t.wire_color || [2, 2, 2, 1]), this.wireframe = t.wireframe || !1, this.shaded = !0, void 0 !== t.shaded && (this.shaded = t.shaded), this.regions_to_render = [], this.requested_regions = [], this.reg_req_flags = 0 } }, ge.geometry.mesh), ge.terrain.collision_mesh = ge.define(function (t, e) { var i, r, n, a; return t.on_new_patch = function (t) { }, t.on_region_data = (t.on_region_data, function (t, e, s, o) { var _ = this.regions[t.key]; if (!_.patches) { for (_.patches = [], i = t.x - this.processor.region_size_half, r = t.z - this.processor.region_size_half, n = 0; n < s; n += 3)a = e[n + 2], _.patches[a] || (_.patches[a] = []), _.patches[a].push(Math.floor(e[n] % (this.processor.region_size + 1)) * this.mesh_scale, e[n + 1] * this.mesh_scale, Math.floor(e[n] / (this.processor.region_size + 1)) * this.mesh_scale); for (n = 0; n < _.patches.length; n++)this.on_new_patch(_.patches[n], i, r) } }), function (t) { t = t || {}, e.apply(this, [t]), this.reg_req_flags = 2, this.mesh_scale = .9965 } }, ge.terrain.mesh), ge.terrain.land_mesh = ge.define(function (t, e) { var i, r; return t.update = (i = t.update, r = [null, null], function (t, e) { r[0] = t, r[1] = e, i.apply(this, r), this.cm.update(t, e) }), function (t) { (t = t || {}).terrian_scale = [1, 1, 1], t.processor = new ge.terrain.processor(t), e.apply(this, [t]), this.cm = new ge.terrain.collision_mesh({ processor: t.processor, quality_distance: 2e3, draw_distance: 7e3, fixed_detail: 32, region_distance: 8, terrain_quality: 8, wireframe: !1, shaded: !1, time_step_size: .2 }) } }, ge.terrain.mesh), ge.terrain.patch_mesh = ge.define(function (t, e) { ge.terrain.patch_material = ge.define(function (t, e) { return function (t) { t = t || {}, e.apply(this, [t]), this.flags += 2 } }, ge.shading.shaded_material); var i, r = 1200, n = new Uint8Array(0), a = new Float32Array(0), s = {}, o = r / 2, _ = 0; function l(t, e) { return _ = n[(e + o) * r + (t + o)] } for (var u = 1; u <= 1024;)s[u] = { i: 0, list: [] }, u *= 2; o = (r = 2056) / 2, i = r * r, n.length < i && (n = new Uint8Array(i), a = new Float32Array(4 * i)); var h, c, d, m, f, g, v, w, y = new Float32Array(6e5), b = 0, E = 0, T = 4, A = 16, M = 4; function L(t, e) { return g[e * v + t] } var I = function () { var t, e, a, s, l = 0, u = [-1, 1, -.75, 1, -.5, 1, -.25, 1, 0, 1, .25, 1, .5, 1, .75, 1, 1, 1, 1, .75, 1, .5, 1, .25, 1, 0, 1, -.25, 1, -.5, 1, -.75, 1, -1, .75, -1, .5, -1, .25, -1, 0, -1, -.25, -1, -.5, -1, -.75, -1, -1, -1, -1, -.75, -1, -.5, -1, -.25, -1, 0, -1, .25, -1, .5, -1, .75, -1, 1], h = []; h[16] = !0, h[32] = !0, h[48] = !0, h[64] = !0; var c = u.length; return function (d, m, p, f) { for (t = u[0], e = u[1], l = f; l < c;)_ = n[(m + (s = u[l + 1]) * p + o) * r + (d + (a = u[l]) * p + o)], (h[l] || _ < p) && (n[i = (m + o) * r + (d + o)] = Math.min(n[i], p), y[b] = d, y[b + 2] = m, y[b + 3] = N, b += 6, n[i = (m + e * p + o) * r + (d + t * p + o)] = Math.min(n[i], p), y[b] = d + t * p, y[b + 2] = m + e * p, y[b + 3] = N, b += 6, n[i = (m + s * p + o) * r + (d + a * p + o)] = Math.min(n[i], p), y[b] = d + a * p, y[b + 2] = m + s * p, y[b + 3] = N, b += 6, t = a, e = s), l += f } }(); var k = new Float32Array(1024), S = 0, R = 0, F = 0; var N = 0, C = !0, G = !1; function P() { for (u = T, G = !1, N = 0; u <= A;) { for (p = s[u], R = 0, j = p.i; R < j;)x = p.list[R++], z = p.list[R++], fd = 16, C && u >= T && (G = !1, l(x - u, z) < u ? G = !0 : l(x + u, z) < u ? G = !0 : l(x, z - u) < u ? G = !0 : l(x, z + u) < u && (G = !0), G && (fd = u / _, fd < 16 ? fd = Math.max(2, 8 / fd) : fd = 2, fd = Math.min(M, fd))), C ? I(x, z, u, fd) : (i = (z - u + o) * r + (x - u + o), n[i] = Math.min(n[i], u), y[b] = x - u, y[b + 2] = z - u, y[b + 3] = N, b += 6, i = (z - u + o) * r + (x + u + o), n[i] = Math.min(n[i], u), y[b] = x + u, y[b + 2] = z - u, y[b + 3] = N, b += 6, i = (z + u + o) * r + (x + u + o), n[i] = Math.min(n[i], u), y[b] = x + u, y[b + 2] = z + u, y[b + 3] = N, b += 6, i = (z - u + o) * r + (x - u + o), n[i] = Math.min(n[i], u), y[b] = x - u, y[b + 2] = z - u, y[b + 3] = N, b += 6, i = (z + u + o) * r + (x + u + o), n[i] = Math.min(n[i], u), y[b] = x + u, y[b + 2] = z + u, y[b + 3] = N, b += 6, i = (z + u + o) * r + (x - u + o), n[i] = Math.min(n[i], u), y[b] = x - u, y[b + 2] = z + u, y[b + 3] = N, b += 6), N++; u *= 2 } } function O(t, e, s, _, l) { for (R = t, u = A; R < e;)x = y[R], z = y[R + 2], _xx = x * l + s, _zz = z * l + _, i = (_zz + o) * r + (_xx + o), 222 !== n[i] ? (n[i] = 222, a[i *= 4] = L(x, z), nx = L(x - u, z) - L(x + u, z), ny = 2 * u, nz = L(x, z - u) - L(x, z + u), _fp = nx * nx + ny * ny + nz * nz, _fp > 0 && (_fp = 1 / Math.sqrt(_fp)), nx *= _fp, ny *= _fp, nz *= _fp, a[i + 1] = nx, a[i + 2] = ny, a[i + 3] = nz) : i *= 4, y[R + 1] = a[i], y[R + 3] = a[i + 1], y[R + 4] = a[i + 2], y[R + 5] = a[i + 3], y[R] = _xx, y[R + 2] = _zz, R += 6 } return function (t) { t = t || {}, e.apply(this, [t]), this.geometry = new ge.geometry.geometry_data, this.position = this.geometry.add_attribute("a_position_rw", { item_size: 3, data: new Float32Array(0), stride: 32 }), this.geometry.add_attribute("a_normal_rw", { item_size: 3, stride: 32, offset: 12 }), this.geometry.add_attribute("a_uv_rw", { item_size: 2, stride: 32, offset: 24 }), this.material = t.material || new ge.terrain.patch_material; var i = this, r = t.divisor || 1; ge.load_working_image_data(t.url, function (e, a, o) { i.hdata = new Float32Array((t.size + 1) * (t.size + 1)); for (var _ = 0; _ < e.length / 4; _++)i.hdata[_] = e[4 * _] / r; for (i.data_size = t.size, g = i.hdata, v = i.data_size, E = 0, function t(e, i, r, n, a) { h = L(e, i), c = L(e - r, i - r), d = L(e + r, i - r), m = L(e + r, i + r), f = L(e - r, i + r); var s = E; return y[s] = Math.max(Math.abs(.5 * (c + d) - h), Math.abs(.5 * (f + m) - h), Math.abs(.5 * (c + f) - h), Math.abs(.5 * (d + m) - h)), n > -1 && (y[n + a] = s), r > T && (E += 5, r *= .5, y[s] = Math.max(y[s], t(e - r, i - r, r, s, 1), t(e + r, i - r, r, s, 2), t(e - r, i + r, r, s, 3), t(e + r, i + r, r, s, 4))), y[s] }(w = v / 2, w, w, -1, 0), i.QT = new Float32Array(E), _ = 0; _ < E;)i.QT[_] = y[_++]; b = 0, n.fill(255), y.fill(0), function (t, e, i, r, n) { var a = 0; for (k[S = 0] = t, k[S + 1] = e, k[S + 2] = i, k[S + 3] = a, S += 4; S > 0;)t = k[S -= 4], e = k[S + 1], i = k[S + 2], a = k[S + 3], F = r, i > A || i > T && n[a] > F ? (i *= .5, k[S] = t + i, k[S + 1] = e + i, k[S + 2] = i, k[S + 3] = n[a + 4], k[S += 4] = t - i, k[S + 1] = e + i, k[S + 2] = i, k[S + 3] = n[a + 3], k[S += 4] = t + i, k[S + 1] = e - i, k[S + 2] = i, k[S + 3] = n[a + 2], k[S += 4] = t - i, k[S + 1] = e - i, k[S + 2] = i, k[S + 3] = n[a + 1], S += 4) : (p = s[i], p.list[p.i++] = t, p.list[p.i++] = e) }(w, w, w, t.details, i.QT), P(), O(0, b, 0, 0, 1), i.position.data = new Float32Array(b / 6 * 8); var l = 0; for (_ = 0; _ < b; _ += 6)i.position.data[l] = y[_], i.position.data[l + 1] = y[_ + 1], i.position.data[l + 2] = y[_ + 2], i.position.data[l + 3] = y[_ + 3], i.position.data[l + 4] = y[_ + 4], i.position.data[l + 5] = y[_ + 5], i.position.data[l + 6] = i.position.data[l] / v, i.position.data[l + 7] = i.position.data[l + 2] / v, l += 8; i.draw_count = l / 8, i.position.data_length = l, i.position.needs_update = !0, console.log(y), console.log(i) }, t.size, t.size) } }, ge.geometry.mesh) } }()(_FM.ecs, _FM.ge, _FM.math), function (t, e, i, r) { i.register_component("ge_renderable", t.define(function (t, e) { function i(t, e, i, r) { this.entity = e, this.items = t.items || [], this.version = 0, this.layers = 0, this.set_layer(t.layer || 1) } return t.set_layer = function (t) { return t = Math.pow(2, t), this.layers & t || (this.layers |= t), this }, t.unset_layer = function (t) { return t = Math.pow(2, t), 0 != (this.layers & t) && (this.layers &= ~t), this }, t.update_bounds = function (t) { }, i.validate = function (t) { t.app.use_system("ge_render_system") }, i }, i.component)), i.register_component("ge_update", t.define(function (t, e) { function i(t, e, i, r) { this.before_update = t.before_update, this.after_update = t.after_update } return i.validate = function (t) { t.app.use_system("ge_render_system") }, i }, i.component)), i.register_system("ge_render_system", t.define(function (i, n) { function a(t, e) { return t.view_position[2] + t.transparent_layer - (e.view_position[2] + e.transparent_layer) } function s(t, e) { return t.suid = t.material.shader.uuid, e.suid = e.material.shader.uuid, t.material.shader.uuid - e.material.shader.uuid } var o, _, l, u = { mesh: null, material: null }; return i.step = function () { this.app.timer - this.fps_timer > 1 && (this.fps = this.fps_counter, this.fps_timer = this.app.timer - (this.app.timer - this.fps_timer) % this.step_size, this.fps_counter = 0), this.fps_counter++; var e, i, n, o, _ = 0, l = this.camera.ge_camera, h = !1; (this.camera_version !== l.version || this.app.timer - this.list_refereshed_timer > 4 * this.step_size) && (h = !0, this.meshes.length = 0, this.lights.length = 0, this.list_refereshed_timer = this.app.timer, this.camera_version = l.version); var c = 0, d = 0, m = 0, p = 0; if (h) { for (p = 0; p < this.multi_material_meshes.length; p++)this.multi_material_meshes.pool.free(this.multi_material_meshes.data[p]); this.multi_material_meshes.clear() } for (; null !== (e = this.app.iterate_entities("ge_update"));)e.ge_update.before_update && e.ge_update.before_update(this.app.timer); for (; null !== (e = this.app.iterate_entities("ge_renderable"));)for (i = e.ge_transform, o = e.ge_renderable, _ = 0; _ < o.items.length; _++) { if (n = o.items[_], 0 === i.require_update && 0 === n.require_update || (n.update_world_transform(i.position_world, i.scale_world, i.rotation_world), n.version = (1 + (0 | n.version)) % 99999, n.update_bounds(n.matrix_world, i), 1024 === n.item_type && n.initialize_item(), n.require_update = 0), h) if (n.render_list && n.render_list(), 4 === n.item_type && (2 & n.flags || 2 & n.material.flags)) if (n.has_multi_materials) for (p = 0; p < n.material.length; p++)u.mesh = n, u.material = n.material[p], this.meshes[d++] = this.multi_material_meshes.pool.get(u); else this.meshes[d++] = n; else if (8 === n.item_type && 2 & n.flags) n.enabled && (this.lights[c++] = n); else if (n.bounds && l.aabb_aabb(n.bounds) && l.frustum_aabb(n.bounds)) if (r.vec3.transform_mat4(n.view_position, n.world_position, l.view_inverse), 4 === n.item_type) if (n.has_multi_materials) for (p = 0; p < n.material.length; p++)u.mesh = n, u.material = n.material[p], this.meshes[d++] = this.multi_material_meshes.pool.get(u); else this.meshes[d++] = n; else 8 === n.item_type && n.enabled && (this.lights[c++] = n); o.version = (1 + (0 | o.version)) % 99999 } for (; null !== (e = this.app.iterate_entities("ge_update"));)e.ge_update.after_update && e.ge_update.after_update(this.app.timer); if (this.renderer_ready) { if (h) { for (this.meshes.length > 0 && t.merge_sort(this.meshes, this.meshes.length, s), this.flat_meshes.length = 0, this.opuque_meshes.length = 0, this.transparent_meshes.length = 0, c = 0, d = 0, m = 0, this.pickable_meshes.length = 0, _ = this.meshes.length; --_ > -1;)128 & (n = this.meshes[_]).material.flags ? (n.transparent_layer = 1e5 * n.material.transparent_layer, this.transparent_meshes[m++] = n) : 2 & n.material.flags ? this.flat_meshes[c++] = n : this.opuque_meshes[d++] = n, this.picking_mouse_x > -1 && 2048 & n.flags && (this.pickable_meshes[this.pickable_meshes.length] = n); this.transparent_meshes.length > 0 && t.merge_sort(this.transparent_meshes, this.transparent_meshes.length, a) } _ = this.meshes.length, this.renderer.timer = this.app.timer, this.renderer.render_scene(l, this.flat_meshes, this.opuque_meshes, this.transparent_meshes, this.lights), this.pickable_meshes.length > 0 && this.process_pickable_meshes() } }, i.resize = function () { var t = this.host.getBoundingClientRect(); this.renderer.set_canvas_size(t.width, t.height), this.camera.ge_camera.update_aspect(t.width / t.height) }, i.setup_host = function (t) { this.host = t, this.host.appendChild(this.renderer.canvas), setTimeout(function (t) { t.resize(), t.renderer_ready = !0 }, 50, this) }, i.process_pickable_meshes = (o = new Uint32Array(1), _ = new Uint8Array(o.buffer), l = new Float32Array(4), i.new_pick_color_id = function () { return o[0] = this.picking_color_id, _[3] = 255, l[0] = _[0], l[1] = _[1], l[2] = _[2], l[3] = _[3], uni = shader.uniforms.u_color_id_rw, uni.params[uni.params_length] = l, uni.func.apply(shader.gl, uni.params), this.picking_color_id += 32, o[0] }, function () { var t, e, i, r = this.renderer, n = 0, a = r.active_camera; for (r.render_target2.bind() && r.gl.clear(16384), r.gl_depthFunc(514), n = 0; n < this.pickable_meshes.length; n++)(e = this.pickable_meshes[n]).material.shader.pickable || (e.material.shader.pickable = e.material.shader.extend("<?=chunk('precision')?>\nuniform vec4 u_color_id_rw;\nvoid fragment(void) {\ngl_FragColor=u_color_id_rw/255.0;\n}", { fragment: !1 })), r.use_shader(e.material.shader.pickable) && (t = r.active_shader).camera_version !== a.version && (t.camera_version = a.version, (i = t.uniforms.u_view_projection_rw) && (i.params[i.params_length] = a.view_projection, i.func.apply(t.gl, i.params)), (i = t.uniforms.u_view_rw) && (i.params[i.params_length] = a.view_inverse, i.func.apply(t.gl, i.params)), (i = t.uniforms.u_view_fw) && (i.params[i.params_length] = a.fw_vector, i.func.apply(t.gl, i.params)), (i = t.uniforms.u_view_sd) && (i.params[i.params_length] = a.sd_vector, i.func.apply(t.gl, i.params)), (i = t.uniforms.u_view_up) && (i.params[i.params_length] = a.up_vector, i.func.apply(t.gl, i.params))), e.picking_color_id ? (o[0] = e.picking_color_id, _[3] = 255, l[0] = _[0], l[1] = _[1], l[2] = _[2], l[3] = _[3], (i = t.uniforms.u_color_id_rw).params[i.params_length] = l, i.func.apply(t.gl, i.params), e.picking_color_id = o[0]) : (o[0] = this.picking_color_id, _[3] = 255, l[0] = _[0], l[1] = _[1], l[2] = _[2], l[3] = _[3], (i = t.uniforms.u_color_id_rw).params[i.params_length] = l, i.func.apply(t.gl, i.params), e.picking_color_id = o[0], this.picking_color_id += 32), (i = t.uniforms.u_model_rw).params[i.params_length] = e.matrix_world, i.func.apply(t.gl, i.params), r.use_geometry(e.geometry), e.material.render_mesh(r, t, e); if (r.gl_depthFunc(513), this.picking_mouse_x > -1) { this.picking_mouse_x *= r.pixel_ratio, this.picking_mouse_y *= r.pixel_ratio, this.picking_mouse_y = r.render_height - this.picking_mouse_y, r.gl.readPixels(this.picking_mouse_x, this.picking_mouse_y, 1, 1, 6408, 5121, _); var s = o[0]; for (this.picking_mouse_x = -1, this.picking_mouse_y = -1, this.picked_mesh = null, n = 0; n < this.pickable_meshes.length; n++)if ((e = this.pickable_meshes[n]).is_picked = !1, this.picked_mesh = e, e.picking_color_id === s) { this.on_mesh_picked.params[0] = e, e.is_picked = !0, this.on_mesh_picked.trigger_params(); break } } }), function (i) { n.apply(this, arguments), this.priority = 1e4, this.renderer = new e.renderer(i.renderer); var r = this; this.scene_render = new e.event(this), this.renderer.clear_screen = function (t) { return function () { return t.apply(this), r.scene_render.trigger_params(), this } }(this.renderer.clear_screen), this.renderer_ready = !1, console.log("ge_render_system", this), this.lights = [], this.meshes = [], this.flat_meshes = [], this.opuque_meshes = [], this.transparent_meshes = [], this.camera_version = -1, this.list_refereshed_timer = 0, this.fps_counter = 0, this.fps_timer = 0, this.fps = 0, this.pickable_meshes = [], this.picking_color_id = 4096, this.picking_mouse_x = -1, this.picking_mouse_y = -1, this.on_mesh_picked = new e.event(this, [null]), r.multi_material_meshes = new e.array, r.multi_material_meshes.pool = new t.object_pooler_ext(function () { return {} }, function (t, e) { return t.material = e.material, t.matrix_world = e.mesh.matrix_world, t.world_position = e.mesh.world_position, t.bounds_sphere = e.mesh.bounds_sphere, t.flags = e.mesh.flags, t.geometry = e.mesh.geometry, t.view_position = e.mesh.view_position, t.draw_offset = e.mesh.draw_offset, t.draw_count = e.mesh.draw_count, r.multi_material_meshes.push(t), t }), this.multi_material_meshes.pool.on_free = function (t) { t.material = void 0, t.matrix_world = void 0, t.world_position = void 0, t.bounds_sphere = 0, t.flags = 0, t.geometry = void 0, t.view_position = void 0, t.draw_offset = void 0, t.draw_count = void 0 }, this.camera = i.camera || this.app.create_entity({ components: { ge_transform: {}, ge_transform_controller: {}, ge_camera: {} } }), this.setup_host(i.host) } }, i.system)) }(_FM.fin, _FM.ge, _FM.ecs, _FM.math), function (t, e, i, r) { i.register_component("skeleton_item", t.define(function (t, e) { var i = []; function n(t, e, i, r) { this.entity = e, this.app = i, this.skinned_joints = [], this.joints = [], this.joints_names = [], this.display = t.display; var n = this; this.on_joint_display = t.on_joint_display, t.joints.forEach(function (e, i) { n.add_joint(e, i, t.all_skin_joints, t.pre_scale) }) } return t.add_joint = function (t, e, n, a) { var s = this.app.create_entity({ components: { ge_transform: { position: t.position || t.pos, rotation: t.rotation || t.rot, scale: t.scale } } }); return t.eular && s.ge_transform.rotate_eular(t.eular[0], t.eular[1], t.eular[2]), a && r.vec3.multiply(s.ge_transform.position, s.ge_transform.position, a), Object.assign(s, { name: t.name || "joint" + e, length: 0, parent: null, skin_index: n ? e : t.skin_index }), void 0 !== t.skin_index && (s.skin_index = t.skin_index), void 0 === s.skin_index && (s.skin_index = -1), s.skin_index > -1 && (s.bind_transform = s.bind_transform || r.dquat(), s.joint_transform = s.joint_transform || r.dquat(), t.bind_pos && 16 === t.bind_pos.length ? (s.set_bind_pos = !1, r.mat4.copy(i, t.bind_pos), a && (i[12] *= a[0], i[13] *= a[1], i[14] *= a[2]), r.dquat.from_mat4(s.bind_transform, i)) : s.set_bind_pos = !0), void 0 !== t.pn && (t.pr = this[t.pn].index), void 0 === t.pr && e > 0 ? (s.ge_transform.parent = this.joints[e - 1].ge_transform, s.parent = this.joints[e - 1]) : t.pr > -1 && (s.ge_transform.parent = this.joints[t.pr].ge_transform, s.parent = this.joints[t.pr]), s.index = this.joints.length, this[s.name] = s, this.joints[this.joints.length] = s, s.skin_index > -1 && (this.skinned_joints[s.skin_index] = s), s }, n.validate = function (t) { t.app.use_system("skeleton_system") }, n }, i.component)), i.register_system("skeleton_system", t.define(function (t, i) { var n, a, s, o, _, l, u, h, c, d, m, p, f, g, v, w, x, y, b, E = r.dquat(); t.step = function () { var t, e, i, r = 0; for (this.skeletons_count = 0; null !== (t = this.app.iterate_entities("skeleton_item"));)for (e = t.skeleton_item, t.ge_transform, this.skeletons[this.skeletons_count++] = e, e.initialized || this.initialize_skeleton(e), r = 0; r < e.skinned_joints.length; r++)(i = e.skinned_joints[r]) && 0 !== i.ge_transform.require_update && ((n = E)[0] = i.ge_transform.rotation_world[0], n[1] = i.ge_transform.rotation_world[1], n[2] = i.ge_transform.rotation_world[2], n[3] = i.ge_transform.rotation_world[3], a = .5 * i.ge_transform.position_world[0], s = .5 * i.ge_transform.position_world[1], o = .5 * i.ge_transform.position_world[2], _ = n[0], l = n[1], u = n[2], h = n[3], n[4] = a * h + s * u - o * l, n[5] = s * h + o * _ - a * u, n[6] = o * h + a * l - s * _, n[7] = -a * _ - s * l - o * u, n = i.joint_transform, c = E, d = i.bind_transform, a = c[0], s = c[1], o = c[2], m = c[3], p = c[4], f = c[5], g = c[6], v = c[7], _ = d[0], l = d[1], u = d[2], h = d[3], w = d[4], x = d[5], y = d[6], b = d[7], n[0] = a * h + m * _ + s * u - o * l, n[1] = s * h + m * l + o * _ - a * u, n[2] = o * h + m * u + a * l - s * _, n[3] = m * h - a * _ - s * l - o * u, n[4] = a * b + m * w + s * y - o * x + p * h + v * _ + f * u - g * l, n[5] = s * b + m * x + o * w - a * y + f * h + v * l + g * _ - p * u, n[6] = o * b + m * y + a * x - s * w + g * h + v * u + p * l - f * _, n[7] = m * b - a * w - s * x - o * y + v * h - p * _ - f * l - g * u) }, t.setup_skeleton_display = function (t) { var i = new e.shading.shaded_material({ ambient: [.25, .25, .25], wireframe: !1, cast_shadows: !0 }); i.shader = i.shader.extend("\n\nuniform vec4 u_joint_qr;\nuniform vec3 u_bone_start;\nuniform vec3 u_bone_end;\n<?=chunk('quat-dquat')?>\n\nvoid vertex(){\n  super_vertex();\n   v_position_rw=vec4(a_position_rw,1.0);\n  float len=length((u_bone_end-u_bone_start));\n  v_position_rw.xz*=min(len,1.0);\n  v_position_rw.y*=len;\n  v_position_rw.xyz=quat_transform(u_joint_qr,v_position_rw.xyz);\n  v_position_rw.xyz+=u_bone_start;\n  gl_Position=u_view_projection_rw*v_position_rw;\n\n}\n\n"), i.complete_render_mesh = function (t, e, i) { var r, n, a, s; for (r = 0; r < i.sk_system.skeletons_count; r++)if ((s = i.sk_system.skeletons[r]).display) for (n = 0; n < s.joints.length; n++)(a = s.joints[n]) && a.ge_transform.parent && (e.set_uniform("u_bone_end", a.ge_transform.position_world), e.set_uniform("u_bone_start", a.ge_transform.parent.position_world), e.set_uniform("u_joint_qr", a.ge_transform.parent.rotation_world), s.on_joint_display && s.on_joint_display(a, e, this), t.gl.drawElements(this.final_draw_type, this.final_draw_count, 5125, 0)) }; var r = e.geometry.shapes.cube({ width: 3, depth: 3 }); for (T = 0; T < r.attributes.a_position_rw.data.length; T += 3)r.attributes.a_position_rw.data[T + 1] > .3 && (r.attributes.a_position_rw.data[T] *= .15, r.attributes.a_position_rw.data[T + 2] *= .15); r.scale_position_rotation(.1, 1, .1, 0, .5, 0, 0, 0, 0); var n = new e.geometry.mesh({ material: i, geometry: r, flags: 2 }); n.sk_system = this, t.root.ge_renderable.items.push(n) }, t.initialize_skeleton = function (t) { t.initialized || (this.set_bind_pos(t), t.initialized = !0) }; var T = 0, A = r.vec3(); function z(t) { i.apply(this, arguments), this.skeletons = [], this.skeletons_count = 0 } return t.set_bind_pos = function (t) { for (T = 0; T < t.joints.length; T++)joint = t.joints[T], joint.skin_index > -1 && joint.set_bind_pos && (r.dquat.from_quat_pos(joint.bind_transform, joint.ge_transform.rotation_world, joint.ge_transform.position_world), r.dquat.invert(joint.bind_transform, joint.bind_transform)), void 0 !== joint.ge_transform.parent ? (r.vec3.subtract(A, joint.ge_transform.position_world, joint.ge_transform.parent.position_world), joint.length = r.vec3.get_length(A)) : joint.length = r.vec3.get_length(joint.ge_transform.position_world) }, t.set_zero_pos = function (t) { for (T = 0; T < t.joints.length; T++)joint = t.joints[T], joint.set_bind_pos = !0, void 0 !== joint.ge_transform.parent && (r.vec3.subtract(joint.ge_transform.position, joint.ge_transform.position_world, joint.ge_transform.parent.position_world), joint.ge_transform.rotation[0] = 0, joint.ge_transform.rotation[1] = 0, joint.ge_transform.rotation[2] = 0, joint.ge_transform.rotation[3] = 1) }, t.validate = function (t) { this.priority = t.use_system("ge_transform_system").priority + 100, this.setup_skeleton_display(t) }, z.mesh = e.define(function (t, e) { var i, n, a, s, o, _, l = (i = r.quat(), n = r.quat(), a = null, s = null, o = null, _ = 0, function (t, e, r) { for (s = r.skeleton_item, _ = 0; _ < s.skinned_joints.length; _++)o = s.skinned_joints[_], a = o.joint_transform, i[0] = a[0], i[1] = a[1], i[2] = a[2], i[3] = a[3], n[0] = a[4], n[1] = a[5], n[2] = a[6], n[3] = a[7], e.set_uniform("joint_qr[" + _ + "]", i), e.set_uniform("joint_qd[" + _ + "]", n) }); return t.initialize_item = function () { var t; this.item_type = 4, this.geometry.attributes.a_joints_indices || console.log(skin_geometry), (t = this.material).shader.skin_shader || (t.shader = t.shader.extend(glsl["skinned-mesh"]), t.on_before_render.add(l), t.shader.skin_shader = !0) }, function (t) { t = t || {}, e.apply(this, [t]), this.skeleton_item = t.skeleton_item } }, e.renderable), z.skin_material = function (t) { return t }, z }, i.system)) }(_FM.fin, _FM.ge, _FM.ecs, _FM.math), function (t, e, i, r) { i.register_component("animations_player", t.define(function (t, e) { function i(t, e, i, r) { this.entity = e, this.clock = 0, this.animations = t.animations || [], this.anim_data = new Float32Array(512) } return i.validate = function (t) { t.app.use_system("animation_system") }, i }, i.component)), i.register_system("animation_system", t.define(function (t, e) { var i, n, a, s, o, _, l, u, h, c, d, m, p, f = new Float32Array(4); return t.run_animation = function (t, e, g) { for (f.fill(0), i = 0; i < t.blocks.length; i++)if (e >= (n = t.blocks[i]).time && e <= n.time + n.length) { if (s = (e - n.time) / n.length, c = n.frames, a = n.fr_size || 1, n.flat) d = Math.floor(c.length / a) - 1, m = 1 / d, u = Math.floor(d * s), h = (u + 1) * a, p = m * u, u *= a, _ = (s - p) / (p + m - p), a++, u -= 1, h -= 1; else { for (a++, o = 0; o <= c.length; o += a) { if (o > 0 && s >= _ && s <= c[o] + 1e-6) { l = o; break } _ = c[o] } h = l, _ = (s - c[u = l - a]) / (c[h] - c[u]) } for (2 === a ? f[0] = c[u + 1] + (c[h + 1] - c[u + 1]) * _ : 3 === a ? (f[0] = c[u + 1] + (c[h + 1] - c[u + 1]) * _, f[1] = c[u + 2] + (c[h + 2] - c[u + 2]) * _) : 4 === a ? (f[0] = c[u + 1] + (c[h + 1] - c[u + 1]) * _, f[1] = c[u + 2] + (c[h + 2] - c[u + 2]) * _, f[2] = c[u + 3] + (c[h + 3] - c[u + 3]) * _) : 5 === a && r.quat.ss(f, c[u + 1], c[u + 2], c[u + 3], c[u + 4], c[h + 1], c[h + 2], c[h + 3], c[h + 4], _), o = 0; o < a - 1; o++)g[n.oi + o] += f[o] } }, t.step = function () { for (var t, e, i, r = 0; null !== (t = this.app.iterate_entities("animations_player"));) { for (t.ge_transform, (e = t.animations_player).anim_data.fill(0), r = 0; r < e.animations.length; r++)(i = e.animations[r]).duration = i.duration || 1, this.run_animation(i, e.clock % i.duration / i.duration, e.anim_data); e.clock += this.app.current_time_delta } }, t.validate = function (t) { this.priority = t.use_system("ge_transform_system").priority - 50 }, function (t) { e.apply(this, arguments) } }, i.system)) }(_FM.fin, _FM.ge, _FM.ecs, _FM.math), function (t, e, i, r) { i.register_system("particles_system", t.define(function (e, i) { function r(t) { i.apply(this, arguments), this.emitters = {}, this.base_emitter = r.emitter, this.clock = 0 } return e.step = function () { for (var t in this.emitters) this.emitters[t].update(this.app.timer, this.app.current_time_delta) }, e.validate = function (t) { this.priority = t.use_system("ge_transform_system").priority - 50 }, e.add_emitter = function (t, e) { return e.is_emitter || (e = new r.emitter(e)), this.emitters[t] = e, e }, r.emitter = t.define(function (e) { var i, r, n, a, s, o, _; return e.create_instance = function (t) { var e = this.use_instance(this.instances.get()); return t && Object.assign(e, t), this.active_instances.enqueue(e), e }, e.update_particle = function (t, e) { }, e.use_particle = function (t, e) { return t[0] = 1, t[1] = .1, t }, e.update = (s = [], o = 0, _ = 0, function (t, e) { for (this.pi = 0, (a = this.active_instances.size()) < this.active_instances._oldestIndex && this.active_instances.realign(); a > 0;) { if (r = this.active_instances.dequeue(), o = r.pi, i = r.rate, r.life > 0) { if (t - r.last_clock > r.emit_delay) { if (i > 1) for (; i > 0 && o < r.max_particles;)(n = this.use_particle(this.particles.get(), r))[0] = t, r.active_particles[o++] = n, i--; else o < r.max_particles && ((n = this.use_particle(this.particles.get(), r))[0] = t, r.active_particles[o++] = n); r.last_clock = t } r.life -= r.life_decay * e, this.active_instances.enqueue(r) } else this.instances.free(r); for (_ = 0; o > 0;)(n = r.active_particles[--o])[1] < 0 || t - n[0] < n[1] ? (s[_++] = n, this.active_particles[this.pi++] = n, this.update_particle(n, r, e)) : this.particles.free(n); for (o = 0; _ > 0;)r.active_particles[o++] = s[--_]; r.pi = o, a-- } }), e.create_particle = function () { return new Float32Array(this.particle_size) }, e.use_instance = function (t) { return t }, function (e) { var i = this; this.is_emitter = !0, this.instances = new t.object_pooler(function () { return { max_particles: 10, last_clock: 0, emit_delay: .2, life: 1, life_decay: 0, active_particles: [], pi: 0, rate: 1 } }), this.active_instances = new t.queue, this.active_particles = [], this.pi = 0, this.particle_size = 2, this.particles = new t.object_pooler(function () { return i.create_particle() }), e && Object.assign(this, e), this.particles.refs = {} } }), r }, i.system)), i.register_system("worker_particles_system", t.define(function (i, r) { i.step = function () { for (var t in this.emitters) this.emitters[t].update(this.app.timer, this.app.current_time_delta) }; var n = { init: function (t) { t.is_function = function (t) { return !!(t && t.constructor && t.call && t.apply) }, t.define = function (t, e) { e = e || Object; var i = {}; Object.assign(i, e.prototype); var r = t(i, e); return r.super_class = e, r.prototype = Object.create(e.prototype), Object.assign(r.prototype, i), r }, t.rg = function (t, e) { null !== t && t.forEach(e) }, t.parse_args_from_func = function (e) { var i; return t.rg(e.match(/function.*\(.*\)/), function (t) { (i = t.replace(/function.*\(/, "").replace(")", "").split(",")).forEach(function (t, e) { i[e] = t.trim() }) }), i || [] }, t.prep_worker = function () { var e, i = []; for (var r in t) this.is_function(t[r]) && (e = t[r].toString()).indexOf("[native code]") < 0 && (console.log(r, t.parse_args_from_func(e)), i.push(e)); t.postMessage(["prep_worker", [i]]) }, t.onmessage = function (t) { this[t.data[0]].apply(this, t.data[1]) } }, queue: function (t) { t.queue = t.define(function (t) { return t.size = function () { return this._newestIndex - this._oldestIndex }, t.enqueue = function (t) { this._storage[this._newestIndex] = t, this._newestIndex++ }, t.realign = function () { let t = this.size(), e = 0; for (e = 0; e < t; e++)this._storage[e + 1] = this._storage[this._oldestIndex + e]; for (e = this._oldestIndex; e < this._newestIndex; e++)this._storage[e] = void 0; this._oldestIndex = 1, this._newestIndex = this._oldestIndex + t }, t.dequeue = function () { if (this._oldestIndex !== this._newestIndex) { var t = this._storage[this._oldestIndex]; return this._storage[this._oldestIndex] = void 0, this._oldestIndex++, t } }, t.peek = function () { return this._storage[this._oldestIndex] }, function () { this._oldestIndex = 1, this._newestIndex = 1, this._storage = {} } }) }, object_pooler: function (t) { t.object_pooler = t.define(function (t) { return t.get = function (t) { return this.freed > 0 ? this.reuse ? this.reuse(this.free_objects[--this.freed], t) : this.free_objects[--this.freed] : this.allocated >= this.pool_size ? null : (this.allocated++, this.creator(t)) }, t.free = function (t) { this.free_objects[this.freed++] = t }, function (t, e, i) { this.creator = t, this.reuse = e, this.allocated = 0, this.freed = 0, this.pool_size = i || 1 / 0, this.free_objects = [] } }) }, ping_pong_array: function (t) { t.ping_pong_array = t.define(function (t) { var e; return t.swap = function () { e = this[this.ping_name], this[this.ping_name] = this[this.pong_name], this[this.pong_name] = e, e = void 0 }, function (t, e) { this.ping_name = t, this.pong_name = e, this[t] = [], this[e] = [] } }) } }; function a(e, i, r) { return r ? i.forEach(function (i) { i && (t.is_function(i) ? e.push("(" + r(i.toString()) + ")(self)") : e.push("(" + r(n[i].toString()) + ")(self)")) }) : i.forEach(function (i) { i && (t.is_function(i) ? e.push("(" + i.toString() + ")(self)") : e.push("(" + n[i].toString() + ")(self)")) }), e } return n.init_emitter = function (t) { t.def = { particle_size: 4 }; var e, i, r = 0, n = 0, a = 0, s = 0, o = 0, _ = 0, l = 1; t.particles_pool = new t.object_pooler(function (t) { return new Float32Array(t) }), t.instances_pool = new t.object_pooler(function () { return e = { last_emit_time: 0, emit_delay: .2, life: 0, life_start: 0, id: l++ }, t.instances_pool.ref[e.id] = e, e }), t.instances_pool.ref = {}, t.active_particles = new t.ping_pong_array("queue", "updates"), t.active_instances = new t.ping_pong_array("queue", "updates"); var u, h = 0, c = 0, d = 0, m = 0; t.run_command = function (t, e, i) { }, t.trigger_emitter = function (t) { }, t.use_instance = function (t, e, i) { return t }, t.use_particle = function (t, e) { return t }, t.queue_particle = function (t, e, n) { return (i = this.particles_pool.get(this.def.particle_size))[0] = e, i[1] = r + t, i[2] = n, this.active_particles.queue[this.pi++] = i, i }, t.pi = 0, t.ii = 0, t.time = 0, t.time_delta = 0, t.onmessage = function (t) { for (h = 0, this.data = new Float32Array(t.data[0]), u = this.data, d = u[h++]; h < d;)c = u[h++], 100 === (m = u[h++]) ? (r = u[h], this.time = r, a = r - n, this.time_delta = a, n = r) : 200 === m ? ((e = this.instances_pool.get()).type = u[h], e.life = u[h + 1], e.emit_delay = u[h + 2], e.life_start = r, e.last_emit_time = r - 2 * e.emit_delay, this.use_instance(e, u, h + 3), this.active_instances.queue[this.ii++] = e) : this.run_command(m, u, h), h += c; for (s = 0; this.ii > 0;)e = this.active_instances.queue[--this.ii], this.active_instances.queue[this.ii] = void 0, e.life < 0 || r - e.life_start < e.life ? (r - e.last_emit_time > e.emit_delay && (e.last_emit_time = r, this.trigger_emitter(e)), this.active_instances.updates[s++] = e) : this.instances_pool.free(e); this.ii = s, this.active_instances.swap(), _ = 0; for (var o = this.active_particles; this.pi > 0;)i = o.queue[--this.pi], o.queue[this.pi] = void 0, r - i[1] > 0 ? i[2] < 0 || r - i[1] < i[2] ? (e = this.instances_pool.ref[i[0]], this.update_particle(i, e, a), o.updates[_++] = i) : this.particles_pool.free(i) : (r - i[1] > 0 && (i[1] = r), o.updates[_++] = i); this.pi = _, o.swap(), this.submit_data(u) }, t.submit_data = function (t) { for (h = 2, o = this.def.particle_size, _ = this.pi; _ > 0;)for (i = this.active_particles.queue[--_], t[h++] = this.instances_pool.ref[i[0]].type, t[h++] = (r - i[1]) / i[2], s = 2; s < o; s++)t[h++] = i[s]; t[0] = h, t[1] = o, this.postMessage([this.data.buffer], [this.data.buffer]) } }, n.generic_emitter = function (t) { var e; t.def.particle_size = 10, t.on_particle_update = function (t, e, i) { }, t.update_particle = function (t, e, i) { t[3] += t[6] * i, t[4] += t[7] * i, t[5] += t[8] * i, t[7] -= t[8] * i, this.on_particle_update(t, e, i) }, t.use_instance = function (t, e, i) { t.x = e[i], t.y = e[i + 1], t.z = e[i + 2], t.particle_life = e[i + 3] }, t.trigger_emitter = function (t) { (e = this.queue_particle(0, t.id, t.particle_life))[3] = t.x, e[4] = t.y, e[5] = t.z, e[6] = 3 * (Math.random() - .5), e[7] = 2 * Math.random() + 1, e[8] = 3 * (Math.random() - .5), e[9] = -.8 }, console.log(t) }, i.define_emitter = function (t, e, i) { e = e || {}; var r = a([], ["init", "queue", "object_pooler", "ping_pong_array", "init_emitter"], function (t) { return t.replace("//[em_def]", "Object.assign(em.def," + JSON.stringify(e) + ");") }); a(r, i); var n = function (t) { return new Worker(window.URL.createObjectURL(new Blob([t.join(";")]))) }(r); e.data_size = e.data_size || 102400, Object.assign(n, e), n.is_working = !0, n.data = new Float32Array(e.data_size), n.command_data = new Float32Array(5120), n.ci = 0, n.system = this, n.data_callback = !1, n.on_data = e.on_data || function (t, e, i) { }, n.onmessage = function (t) { this.data = new Float32Array(t.data[0]), this.data_callback = !0, this.on_data(this.data, 2, this.data[0]), this.data_callback = !1 }; var s = 0; return n.push_command = function (t) { for (this.command_data[this.ci++] = t.length - 1, s = 0; s < t.length; s++)this.command_data[this.ci++] = t[s] }, n.update = function (t, e) { if (!this.data_callback && this.data.buffer.byteLength > 0) { for (this.data[1] = 1, this.data[2] = 100, this.data[3] = t, this.data[4] = e, s = 0, this.data[0] = this.ci + 4; s < this.ci;)this.data[s + 4] = this.command_data[s++]; this.postMessage([this.data.buffer], [this.data.buffer]), this.ci = 0 } }, this.emitters[t] = n, n }, i.validate = function (t) { this.priority = t.use_system("ge_transform_system").priority - 50 }, i.create_quad_particle_emitter = function () { var t, i = new e.shading.material({ shader: e.shading.material.shader.extend("\nattribute vec4 a_particle_pos_rw;\nvarying vec4 v_particle_pos_rw;\nvec4 att_position(void){\n    return vec4(((a_position_rw.xyz)+a_particle_pos_rw.xyz),1.0);\n}\nvoid vertex(){\n\tsuper_vertex();\nv_particle_pos_rw=a_particle_pos_rw;\n\n}\nvarying vec4 v_particle_pos_rw;\nvoid fragment(){\n\tsuper_fragment();\n}\n") }); i.complete_render_mesh = (t = i.complete_render_mesh, function (e, i, r) { r.emitter.renderer = e, this.instances_count = r.geometry.instances_count, this.instances_count > 0 && t.apply(this, [e, i, r]) }); var r = e.geometry.geometry_data.create({ vertices: new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, -.5, 0, .5, .5, 0, -.5, .5, 0]), attr: { a_particle_pos_rw: { item_size: 4, buffer_type: 35048, divisor: 1 } } }); return r.instances_count = -1, r.create_emitter = function (t) { this.emitter = t.define_emitter("quad_particle_emitter", {}, ["generic_emitter", function (t) { t.submit_data = function (t) { for (var e = 0, i = this.pi; i > 0;)par = this.active_particles.queue[--i], t[e++] = par[3], t[e++] = par[4], t[e++] = par[5], t[e++] = 1; t[t.length - 1] = e, this.postMessage([this.data.buffer], [this.data.buffer]) } }]), this.emitter.on_data = function (t) { this.renderer && (null === this.geo.attributes.a_particle_pos_rw.buffer && (this.geo.attributes.a_particle_pos_rw.buffer = this.renderer.gl.createBuffer()), this.renderer.gl.bindBuffer(34962, this.geo.attributes.a_particle_pos_rw.buffer), this.renderer.gl.bufferData(34962, t, 35048, 0, t[t.length - 1]), this.geo.instances_count = t[t.length - 1] / 4) }, this.emitter.geo = this }, function (t) { r.emitter || r.create_emitter(this); var n = new e.geometry.mesh({ geometry: r, material: i }); return n.emitter = r.emitter, n } }(), i.create_point_particle_emitter = function () { var t = new e.shading.material({ shader: e.webgl.shader.parse("\n<?=chunk('precision')?>\n\nattribute vec4 a_position_rw;\n\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\n\nvoid vertex(void){\n\n  gl_Position=u_view_projection_rw*vec4(a_position_rw.xyz,1.0);\n  gl_PointSize =5.0;\n\n\n\n\n}\n<?=chunk('precision')?>\n\nvoid fragment(void) {\n    gl_FragColor =vec4(1.0);\n}\n\n\n") }); t.render_mesh = function (t, e, i) { i.emitter.renderer = t, i.geometry.instances_count > 0 && (t.gl.enable(3042), t.gl.blendFunc(770, 771), t.gl.depthMask(!1), t.use_texture(this.texture, 0), t.gl.bindBuffer(34962, i.emitter.a_particle_pos_buffer), t.gl.vertexAttribPointer(0, 4, 5126, !1, 16, 0), t.gl.drawArrays(0, 0, i.geometry.instances_count), t.gl.disable(3042), t.gl.depthMask(!0)) }; var i = e.geometry.geometry_data.create({ vertices: new Float32Array(0), vertex_size: 4 }); return i.instances_count = -1, i.create_emitter = function (t) { this.emitter = t.define_emitter("quad_particle_emitter", {}, ["generic_emitter", function (t) { t.submit_data = function (t) { for (var e = 0, i = this.pi; i > 0;)par = this.active_particles.queue[--i], t[e++] = par[3], t[e++] = par[4], t[e++] = par[5], t[e++] = 1; t[t.length - 1] = e, this.postMessage([this.data.buffer], [this.data.buffer]) } }]), this.emitter.on_data = function (t) { this.renderer && (this.a_particle_pos_buffer || (this.a_particle_pos_buffer = this.renderer.gl.createBuffer()), this.renderer.gl.bindBuffer(34962, this.a_particle_pos_buffer), this.renderer.gl.bufferData(34962, t, 35048, 0, t[t.length - 1]), this.geo.instances_count = t[t.length - 1] / 4) }, this.emitter.geo = this }, function (r) { i.emitter || i.create_emitter(this); var n = new e.geometry.mesh({ geometry: i, material: t }); return n.emitter = i.emitter, n } }(), i.create_point_particle_emitter = function () { var t = new e.shading.material({ shader: e.webgl.shader.parse("\n<?=chunk('precision')?>\n\nattribute vec4 a_position_rw;\n\nuniform vec4 u_texture_sets_rw[10];\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\n\nvarying float v_life_rw;\nvarying float v_life_blend;\nvarying vec4 v_texture_set_rw;\nvarying vec2 v_texture_coord1_rw;\nvarying vec2 v_texture_coord2_rw;\n\nvoid vertex(void){\n\nv_life_rw= fract(a_position_rw.w);\n\n  int texture_set =int(fract(a_position_rw.w * 256.0)*255.0);\n  float size = (fract(a_position_rw.w * 65536.0)*255.0)*5.0;\n\n  v_texture_set_rw=u_texture_sets_rw[texture_set];\n\n  gl_Position=u_view_projection_rw*(u_model_rw*vec4(a_position_rw.xyz,1.0));\n\n \n\n\n\n    float d=v_texture_set_rw.z/v_texture_set_rw.w;\n\n    float lf=((1.0-v_life_rw)/(1.0/d));\ngl_PointSize =size/gl_Position.w;\n\n    v_life_blend=fract(lf);\n\n    v_texture_coord1_rw=vec2(floor(lf)*v_texture_set_rw.w,0.0);\n    v_texture_coord2_rw=vec2(v_texture_coord1_rw.x+v_texture_set_rw.w,v_texture_coord1_rw.y);\n\n    v_texture_coord2_rw=v_texture_coord1_rw;\n\n\n\n\n}\n<?=chunk('precision')?>\nuniform sampler2D u_texture_rw;\n\nvarying float v_life_rw;\nvarying float v_life_blend;\nvarying vec4 v_texture_set_rw;\nvarying vec2 v_texture_coord1_rw;\nvarying vec2 v_texture_coord2_rw;\n\nvec2 rotcoord(vec2 c,vec2 p,float r){\n\n\nreturn vec2((cos(r) * (p.x-c.x)  + sin(r) * (p.y-c.y))+c.x,               (cos(r) * (p.y-c.y)  - sin(r) * (p.x-c.x))+c.y );\n\n return vec2(cos(r) * (p.x)  + sin(r) * (p.y),               cos(r) * (p.y)  - sin(r) * (p.x) );\n\n\n//return p;\n \n}\nvoid fragment(void) {\n     vec2 coords =gl_PointCoord*v_texture_set_rw.w+v_texture_set_rw.xy;\n\ngl_FragColor =mix( texture2D(u_texture_rw, coords+v_texture_coord1_rw),\n    texture2D(u_texture_rw, coords+v_texture_coord2_rw),v_life_blend);\ngl_FragColor= texture2D(u_texture_rw, coords+v_texture_coord1_rw);\n//gl_FragColor.g=gl_FragColor.r;\n//gl_FragColor.b=gl_FragColor.r;\n\n//gl_FragColor.rgb*=vec3(8.0);\n\n//gl_FragColor.rgb = vec3(1.0 - gl_FragColor.r,1.0 -gl_FragColor.g,1.0 -gl_FragColor.b);\ngl_FragColor.w*=0.2;\n//gl_FragColor=vec4(1.0);\n}\n\n\n"), transparent_layer: 100 }); t.render_mesh = function (t, e, i) { if (i.emitter.renderer = t, i.emitter.instances_count > 0) { for (t.gl_enable(3042), t.gl_blendFunc(770, 771), t.gl_depthMask(!1), t.use_texture(this.texture, 0), t.gl.bindBuffer(34962, i.emitter.a_particle_pos_buffer), t.gl.vertexAttribPointer(0, 4, 5126, !1, 16, 0), t.use_texture(i.texture, 0), s = 0; s < i.texture_sets.length; s++)e.set_uniform("u_texture_sets_rw[" + s + "]", i.texture_sets[s]); t.gl.drawArrays(i.draw_type, 0, i.emitter.instances_count), t.gl_disable(3042), t.gl_depthMask(!0) } }; var i = e.geometry.geometry_data.create({ vertices: new Float32Array(0), vertex_size: 4 }); return function (r) { var n = new e.geometry.mesh({ geometry: i, material: t }); if (n.emitter = this.define_emitter("point_particle_emitter", { on_data: function (t) { this.renderer && (this.a_particle_pos_buffer || (this.a_particle_pos_buffer = this.renderer.gl.createBuffer()), this.renderer.gl.bindBuffer(34962, this.a_particle_pos_buffer), this.renderer.gl.bufferData(34962, t, 35048, 0, t[t.length - 1]), this.instances_count = t[t.length - 1] / 4) } }, ["generic_emitter", function (t) { var e, i, r = new Uint32Array(1), n = new Uint8Array(4); t.pack_life_texture_size = function (t, e) { }, t.submit_data = function (t) { for (e = 0, i = this.pi; i > 0;)par = this.active_particles.queue[--i], t[e++] = par[3], t[e++] = par[4], t[e++] = par[5], n[0] = (this.time - par[1]) / par[2] * 255, n[1] = 0, n[2] = 10, this.pack_life_texture_size(n, par), r[0] = n[0] << 16 | n[1] << 8 | n[2], t[e++] = r[0] / (1 << 24); t[t.length - 1] = e, this.postMessage([this.data.buffer], [this.data.buffer]) } }, r.emitter]), n.texture = r.texture, n.texture_sets = [], r.texture && (this.texture = r.texture, r.texture_sets)) { var a = r.texture.width, s = r.texture.height; r.texture_sets.forEach(function (t, e) { (t = new Float32Array(t))[0] /= a, t[1] /= s, t[2] /= a, t[3] /= s, n.texture_sets.push(t) }) } return n.emitter.emit_intance = function () { }, n.draw_type = 0, console.log(n), n } }(), function (t) { r.apply(this, arguments), this.emitters = {} } }, i.system)) }(_FM.fin, _FM.ge, _FM.ecs, _FM.math), function (t, e) { t.active_mesh = t.define(function (t, i) { var r = e.quat(), n = e.vec3(); return t.update_world_transform = function (t, i, a) { e.quat.mult(r, a, this.rotation), e.mat4.from_quat(this.matrix_world, r), n[0] = i[0] * this.scale[0], n[1] = i[1] * this.scale[1], n[2] = i[2] * this.scale[2], e.mat4.scale(this.matrix_world, n), this.matrix_world[12] = t[0] + this.position[0], this.matrix_world[13] = t[1] + this.position[1], this.matrix_world[14] = t[2] + this.position[2] }, function (t) { t = t || {}, i.apply(this, [t]), this.position = e.vec3(t.position), this.scale = e.vec3(t.scale || [1, 1, 1]), this.rotation = e.quat(t.rotation), t.rotate && e.quat.rotate_eular(this.rotation, t.rotate[0], t.rotate[1], t.rotate[2]) } }, t.geometry.mesh) }(_FM.ge, _FM.math), function (t, e) { t.effects = {}; var r = t.webgl.shader.create_chunks_lib("/*chunk-pp-default*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nconst vec2 madd=vec2(0.5,0.5);\nvarying vec2 v_uv_rw;\nvoid vertex()\n{\n    gl_Position = vec4(a_position_rw.xy,0.0,1.0);\t\n\tv_uv_rw = a_position_rw.xy*madd+madd;  \n}\n<?=chunk('precision')?>\nuniform sampler2D u_texture_input_rw;\nvarying vec2 v_uv_rw;\nvoid fragment(void){\t\ngl_FragColor = texture2D(u_texture_input_rw, v_uv_rw) ;\t\n\n\n}\n\n\n\n/*chunk-pp-picture-adjustment*/\n\nuniform mat3 u_pa_params;\n\nvoid fragment(){\t\n\tvec4 c = texture2D(u_texture_input_rw, v_uv_rw);\n    if (c.a > 0.0) {\n\n\t\t\n    }\n        float gamma=u_pa_params[0].x;\n\t\tfloat contrast=u_pa_params[0].y;\n\t\tfloat saturation=u_pa_params[0].z;\n\t\tfloat brightness=u_pa_params[1].x;\n\t\tfloat red=u_pa_params[1].y;\n\t\tfloat green=u_pa_params[1].z;\n\t\tfloat blue=u_pa_params[2].x;\n\t\t\n        //c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1.0 / gamma));\n        rgb = mix(vec3(0.5), mix(vec3(dot(vec3(0.2125, 0.7154, 0.0721), rgb)), rgb, saturation), contrast);\n        rgb.r *= red;\n        rgb.g *= green;\n        rgb.b *= blue;\n\n        c.rgb = rgb * brightness;        \n     //   c.rgb *= c.a;\n\n\n\tfloat alpha=u_pa_params[2].y;\n    gl_FragColor = c * alpha;\n}\n\n\n/*chunk-pp-fxaa*/\n\nuniform vec3 u_inverse_filter_texture_size;\nuniform vec3 u_fxaa_params;\n\nvoid fragment(void){\t\n\tfloat R_fxaaSpanMax=u_fxaa_params.x;\n\tfloat R_fxaaReduceMin=u_fxaa_params.y;\n\tfloat R_fxaaReduceMul=u_fxaa_params.z;\t\n\tvec2 texCoordOffset = u_inverse_filter_texture_size.xy;\n\tvec3 luma = vec3(0.299, 0.587, 0.114);\t\n\tfloat lumaTL = dot(luma, texture2D(u_texture_input_rw, v_uv_rw.xy + (vec2(-1.0, -1.0) * texCoordOffset)).xyz);\n\tfloat lumaTR = dot(luma, texture2D(u_texture_input_rw, v_uv_rw.xy + (vec2(1.0, -1.0) * texCoordOffset)).xyz);\n\tfloat lumaBL = dot(luma, texture2D(u_texture_input_rw, v_uv_rw.xy + (vec2(-1.0, 1.0) * texCoordOffset)).xyz);\n\tfloat lumaBR = dot(luma, texture2D(u_texture_input_rw, v_uv_rw.xy + (vec2(1.0, 1.0) * texCoordOffset)).xyz);\n\tfloat lumaM  = dot(luma, texture2D(u_texture_input_rw, v_uv_rw.xy).xyz);\n\n\tvec2 dir;\n\tdir.x = -((lumaTL + lumaTR) - (lumaBL + lumaBR));\n\tdir.y = ((lumaTL + lumaBL) - (lumaTR + lumaBR));\n\t\n\tfloat dirReduce = max((lumaTL + lumaTR + lumaBL + lumaBR) * (R_fxaaReduceMul * 0.25), R_fxaaReduceMin);\n\tfloat inverseDirAdjustment = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n\t\n\tdir = min(vec2(R_fxaaSpanMax, R_fxaaSpanMax), \n\t\tmax(vec2(-R_fxaaSpanMax, -R_fxaaSpanMax), dir * inverseDirAdjustment)) * texCoordOffset;\n\n\tvec3 result1 = (1.0/2.0) * (\n\t\ttexture2D(u_texture_input_rw, v_uv_rw.xy + (dir * vec2(1.0/3.0 - 0.5))).xyz +\n\t\ttexture2D(u_texture_input_rw, v_uv_rw.xy + (dir * vec2(2.0/3.0 - 0.5))).xyz);\n\n\tvec3 result2 = result1 * (1.0/2.0) + (1.0/4.0) * (\n\t\ttexture2D(u_texture_input_rw, v_uv_rw.xy + (dir * vec2(0.0/3.0 - 0.5))).xyz +\n\t\ttexture2D(u_texture_input_rw, v_uv_rw.xy + (dir * vec2(3.0/3.0 - 0.5))).xyz);\n\n\tfloat lumaMin = min(lumaM, min(min(lumaTL, lumaTR), min(lumaBL, lumaBR)));\n\tfloat lumaMax = max(lumaM, max(max(lumaTL, lumaTR), max(lumaBL, lumaBR)));\n\tfloat lumaResult2 = dot(luma, result2);\n\t\n\nif(lumaResult2 < lumaMin || lumaResult2 > lumaMax)\n\t\tgl_FragColor = vec4(result1, 1.0);\n\telse\n\t\tgl_FragColor = vec4(result2, 1.0);\n\nif(v_uv_rw.x<0.5){\n    gl_FragColor=texture2D(u_texture_input_rw, v_uv_rw);\n}\nelse {\n\t\ngl_FragColor.rgb*=0.75;\n}\n\n}\n\n\n\n/*chunk-pp-glow*/\nuniform sampler2D u_glow_emission_rw;\nuniform vec3 u_glow_params_rw;\n\nvoid fragment(void){\t\n\nvec4 cBase = texture2D(u_texture_input_rw, v_uv_rw);\n\tvec4 cOver = texture2D(u_glow_emission_rw, v_uv_rw);\t\t\t\n\tvec4 blend = cBase + cOver * u_glow_params_rw.z;\n    blend = vec4(1.0) - exp(-blend * u_glow_params_rw.x);\n    blend = pow(blend, vec4(1.0 / u_glow_params_rw.y));\n\tgl_FragColor =blend;\n\n}\n\n/*chunk-pp-blur*/\n\nuniform vec2 u_offset_rw;\nuniform vec3 u_blurKernel_rw;\nvoid fragment(){\t\n\tvec3 A = u_blurKernel_rw.x* texture2D(u_texture_input_rw, v_uv_rw - u_offset_rw).xyz;\n\tvec3 B = u_blurKernel_rw.y* texture2D(u_texture_input_rw, v_uv_rw).xyz;\n\tvec3 C = u_blurKernel_rw.z* texture2D(u_texture_input_rw, v_uv_rw + u_offset_rw).xyz;\n\tvec3 color = A + B + C;\n\tgl_FragColor = vec4(color, 1);\t\n\t\n}\n\n\n\n/*chunk-pp-emission*/\nuniform vec4 u_bright_threshold_rw;\nvoid fragment(){\t\n\t vec4 color = texture2D(u_texture_input_rw, v_uv_rw);        \t\t\n\t float luminance = dot(color.rgb, u_bright_threshold_rw.xyz );\n\t luminance+=(color.a+u_bright_threshold_rw.w);\t\t \n\t gl_FragColor = luminance* color;\n}\n\n\n\n\n\n\n\n\n/*chunk-pp-bloom*/\nuniform sampler2D u_glow_emission_rw;\nuniform vec3 u_glow_params_rw;\n\nvoid fragment(void){\t\n\nvec4 cBase = texture2D(u_texture_input_rw, v_uv_rw);\n\tvec4 cOver = texture2D(u_glow_emission_rw, v_uv_rw);\t\t\t\n\tvec4 blend = cBase + cOver * u_glow_params_rw.z;\n    blend = vec4(1.0) - exp(-blend * u_glow_params_rw.x);\n    blend = pow(blend, vec4(1.0 / u_glow_params_rw.y));\n\tgl_FragColor =blend;\n\n}\n\n/*chunk-pp-bloom-blur*/\n\nuniform vec2 u_offset_rw;\nuniform vec3 u_blurKernel_rw;\nvoid fragment(){\t\n\tvec3 A = u_blurKernel_rw.x* texture2D(u_texture_input_rw, v_uv_rw - u_offset_rw).xyz;\n\tvec3 B = u_blurKernel_rw.y* texture2D(u_texture_input_rw, v_uv_rw).xyz;\n\tvec3 C = u_blurKernel_rw.z* texture2D(u_texture_input_rw, v_uv_rw + u_offset_rw).xyz;\n\tvec3 color = A + B + C;\n\tgl_FragColor = vec4(color, 1);\t\n\t\n}\n\n\n\n/*chunk-pp-bloom-emission*/\nuniform vec4 u_bright_threshold_rw;\nvoid fragment(){\t\n\t vec4 color = texture2D(u_texture_input_rw, v_uv_rw);        \t\t\n\t float luminance = dot(color.rgb, u_bright_threshold_rw.xyz );\n\t luminance+=(color.a+u_bright_threshold_rw.w);\t\t \n\t gl_FragColor =  color*luminance;\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*chunk-glow-material*/\nvoid vertex(void){\nsuper_vertex();\n}\n\nvoid fragment(void) {\nsuper_fragment();\n\ngl_FragColor.rgb*=1.1;\n}\n\n\n\n\n\n/*chunk-skybox*/\n<?=chunk('precision')?>\nattribute vec4 a_position_rw;\nvarying vec4 v_position_rw;\n\nvoid vertex(){\n  v_position_rw = a_position_rw;\n  gl_Position = a_position_rw;\n  gl_Position.z = 1.0;\n}\n\n\n<?=chunk('precision')?>\nuniform mat4 u_view_projection_matrix_rw;\nuniform vec4 u_sun_params_rw;\nvarying vec4 v_position_rw;\nvec3 fragPosition;\n\nconst float turbidity = 10.0;\nconst float reileigh = 2.0;\nconst float mieCoefficient = 0.005;\nconst float mieDirectionalG = 0.8;\n\nconst float e = 2.71828182845904523536028747135266249775724709369995957;\nconst float pi = 3.141592653589793238462643383279502884197169;\n\nconst float n = 1.0003;// refractive index of air\nconst float N = 2.545E25; // number of molecules per unit volume for air at\n\t\t\t\t\t\t\t\t\t\t\t\nconst float pn = 0.035;\n// wavelength of used primaries, according to preetham\nconst vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\n\nconst vec3 K = vec3(0.686, 0.678, 0.666);\nconst float v = 4.0;\n\nconst float rayleighZenithLength = 8.4E3;\nconst float mieZenithLength = 1.25E3;\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\nconst float EE = 1000.0;\n\nfloat sunAngularDiameterCos =u_sun_params_rw.w; // 0.999956;\n\nconst float cutoffAngle = pi/1.95;\nconst float steepness = 1.5;\n\nvec3 simplifiedRayleigh() {\n\treturn 0.0005 / vec3(94, 40, 18);\n}\n\nfloat rayleighPhase(float cosTheta) {\n\treturn (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));\n}\n\nvec3 totalMie(vec3 lambda, vec3 K, float T) {\n\tfloat c = (0.2 * T ) * 10E-18;\n\treturn 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;\n}\n\nfloat hgPhase(float cosTheta, float g) {\n\treturn (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\n}\n\nfloat sunIntensity(float zenithAngleCos) {\t\n\treturn EE * max(0.0, 1.0 - pow(e, -((cutoffAngle - acos(zenithAngleCos))/steepness)));\n}\n\nfloat A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\nfloat W = 1000.0;\n\nvec3 Uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\n<?=chunk('global-render-system-fog-effect')?>\n\nvoid fragment(void) {\n\t\n   fragPosition=(u_view_projection_matrix_rw * v_position_rw).xyz;\n\tvec3 sunPosition=u_sun_params_rw.xyz;\n\tfloat sunfade = 1.0 - clamp(1.0 - exp(sunPosition.y), 0.0, 1.0);\n\tfloat reileighCoefficient = reileigh - (1.0 * (1.0-sunfade));\n\tvec3 sunDirection = normalize(sunPosition);\n\tfloat sunE = sunIntensity(dot(sunDirection, up));\n\tvec3 betaR = simplifiedRayleigh() * reileighCoefficient;\n\n\t// mie coefficients\n\tvec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\n\n\t// optical length\n\t// cutoff angle at 90 to avoid singularity in next formula.\n\tfloat zenithAngle = acos(max(0.0, dot(up, normalize(fragPosition))));\n\tfloat sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\n\tfloat sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\n\n\t// combined extinction factor\n\tvec3 Fex = exp(-(betaR * sR + betaM * sM));\n\n\t// in scattering\n\tfloat cosTheta = dot(normalize(fragPosition), sunDirection);\n\n\tfloat rPhase = rayleighPhase(cosTheta * 0.5+0.5);\n\tvec3 betaRTheta = betaR * rPhase;\n\n\tfloat mPhase = hgPhase(cosTheta, mieDirectionalG);\n\tvec3 betaMTheta = betaM * mPhase;\n\n\tvec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));\n\tLin *= mix(vec3(1.0),pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, sunDirection),5.0),0.0,1.0));\n\n\t//nightsky\n\tvec3 direction = normalize(fragPosition);\n\tfloat theta = acos(direction.y); // elevation --\x3e y-axis, [-pi/2, pi/2]\n\tfloat phi = atan(direction.z, direction.x); // azimuth --\x3e x-axis [-pi/2, pi/2]\n\tvec2 uv = vec2(phi, theta) / vec2(2.0*pi, pi) + vec2(0.5, 0.0);\n\tvec3 L0 = vec3(0.1) * Fex;\n\n\t// composition + solar disc\n\tfloat sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);\n\tL0 += (sunE * 19000.0 * Fex)*sundisk;\n\n\tvec3 whiteScale = 1.0/Uncharted2Tonemap(vec3(W));\n\n\tvec3 texColor = (Lin+L0);\n\ttexColor *= 0.04 ;\n\ttexColor += vec3(0.0,0.001,0.0025)*0.3;\n\n\tvec3 curr = Uncharted2Tonemap(texColor);\n\tvec3 color = curr*whiteScale;\n\n\tvec3 retColor = pow(color,vec3(1.0/(1.2+(1.2*sunfade))));\n\n\tgl_FragColor = vec4(retColor, 1.0);\n\tgl_FragColor=mix_fog_color(gl_FragColor);\n\t\n}\n\n\n\n\n\n/*chunk-skybox2*/\n<?=chunk('precision')?>\nattribute vec4 a_position_rw;\nvarying vec4 v_position_rw;\n\nvoid vertex(){\n  v_position_rw = a_position_rw;\n  gl_Position = a_position_rw;\n  gl_Position.z = 1.0;\n}\n\n\n<?=chunk('precision')?>\nuniform mat4 u_view_projection_matrix_rw;\nuniform vec4 u_sun_params_rw;\nvarying vec4 v_position_rw;\n\n\nconst float depolarizationFactor=0.067;\nconst float luminance=1.0;\nconst float mieCoefficient=0.00335;\nconst float mieDirectionalG=0.787;\nconst vec3 mieKCoefficient=vec3(0.686,0.678,0.666);\nconst float mieV=4.012;\nconst float mieZenithLength=500.0;\nconst float numMolecules=2.542e+25;\nconst vec3 primaries=vec3(6.8e-7,5.5e-7,4.5e-7);\nconst float rayleigh=1.0;\nconst float rayleighZenithLength=615.0;\nconst float refractiveIndex=1.000317;\nconst float sunAngularDiameterDegrees=0.00758;\nconst float sunIntensityFactor=1111.0;\nconst float sunIntensityFalloffSteepness=0.98;\nconst float tonemapWeighting=9.50;\nconst float turbidity=1.25;\n\nconst float PI = 3.141592653589793238462643383279502884197169;\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\n\nvec3 totalRayleigh(vec3 lambda)\n{\n\treturn (8.0 * pow(PI, 3.0) * pow(pow(refractiveIndex, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * depolarizationFactor)) / (3.0 * numMolecules * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * depolarizationFactor));\n}\n\nvec3 totalMie(vec3 lambda, vec3 K, float T)\n{\n\tfloat c = 0.2 * T * 10e-18;\n\treturn 0.434 * c * PI * pow((2.0 * PI) / lambda, vec3(mieV - 2.0)) * K;\n}\n\nfloat rayleighPhase(float cosTheta)\n{\n\treturn (3.0 / (16.0 * PI)) * (1.0 + pow(cosTheta, 2.0));\n}\n\nfloat henyeyGreensteinPhase(float cosTheta, float g)\n{\n\treturn (1.0 / (4.0 * PI)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0 * g * cosTheta + pow(g, 2.0), 1.5));\n}\n\nfloat sunIntensity(float zenithAngleCos)\n{\n\tfloat cutoffAngle = PI / 1.95; // Earth shadow hack\n\treturn sunIntensityFactor * max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos)) / sunIntensityFalloffSteepness)));\n}\n\n// Whitescale tonemapping calculation, see http://filmicgames.com/archives/75\n// Also see http://blenderartists.org/forum/showthread.php?321110-Shaders-and-Skybox-madness\nconst float A = 0.15; // Shoulder strength\nconst float B = 0.50; // Linear strength\nconst float C = 0.10; // Linear angle\nconst float D = 0.20; // Toe strength\nconst float E = 0.02; // Toe numerator\nconst float F = 0.30; // Toe denominator\nvec3 Uncharted2Tonemap(vec3 W)\n{\n\treturn ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n}\n\n\n\nvoid fragment(void) {\n\t\n  vec3 fragPosition=normalize((u_view_projection_matrix_rw * v_position_rw).xyz);\n  // In-scattering\t\n\tvec3 sunDirection=u_sun_params_rw.xyz;\n\n\n  //float sunfade = 1.0 - clamp(1.0 - exp(((sunDirection*4500000.0).y / 450000.0)), 0.0, 1.0);\n\n  float sunfade = 1.0 - clamp(1.0 - exp(sunDirection.y), 0.0, 1.0);\n\tfloat rayleighCoefficient = rayleigh - (1.0 * (1.0 - sunfade));\n\tvec3 betaR = totalRayleigh(primaries) * rayleighCoefficient;\n\t\n\t// Mie coefficient\n\tvec3 betaM = totalMie(primaries, mieKCoefficient, turbidity) * mieCoefficient;\n\t\n\t// Optical length, cutoff angle at 90 to avoid singularity\n\tfloat zenithAngle = acos(max(0.0, dot(UP, fragPosition)));\n\tfloat denom = cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253);\n\tfloat sR = rayleighZenithLength / denom;\n\tfloat sM = mieZenithLength / denom;\n\t\n\t// Combined extinction factor\n\tvec3 Fex = exp(-(betaR * sR + betaM * sM));\n\t\n\t\n\tfloat cosTheta = dot(fragPosition, sunDirection);\n\tvec3 betaRTheta = betaR * rayleighPhase(cosTheta * 0.5 + 0.5);\n\tvec3 betaMTheta = betaM * henyeyGreensteinPhase(cosTheta, mieDirectionalG);\n\tfloat sunE = sunIntensity(dot(sunDirection, UP));\n\tvec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex), vec3(1.5));\n\tLin *= mix(vec3(1.0), pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex, vec3(0.5)), clamp(pow(1.0 - dot(UP, sunDirection), 5.0), 0.0, 1.0));\n\t\n\t// Composition + solar disc\n\tfloat sunAngularDiameterCos = cos(sunAngularDiameterDegrees);\n\tfloat sundisk = smoothstep(sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta);\n\tvec3 L0 = vec3(0.1) * Fex;\n\tL0 += sunE * 19000.0 * Fex * sundisk;\n\tvec3 texColor = Lin + L0;\n\ttexColor *= 0.04;\n\ttexColor += vec3(0.0, 0.001, 0.0025) * 0.3;\n\t\n\t// Tonemapping\n\tvec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(tonemapWeighting));\n\tvec3 curr = Uncharted2Tonemap((log2(2.0 / pow(luminance, 4.0))) * texColor);\n\tvec3 color = curr * whiteScale;\n\tvec3 retColor = pow(color, vec3(1.0 / (1.2 + (1.2 * sunfade))));\n\n\tgl_FragColor = vec4(retColor, 1.0);\n}\n}"); t.effects.post_process = t.define(function (e) { function i(e) { this.guid = fin.guidi(), this.shader = e || t.effects.post_process.shader, this.on_apply || (this.on_apply = null), this.enabled = !0, this.post_shading = !1 } i.shader = t.webgl.shader.parse(r["pp-default"]), e.resize = function (t, e) { }, e.bind_output = function (t, e) { null === e ? (t.gl.bindFramebuffer(36160, null), t.gl.viewport(0, 0, t.render_width, t.render_height)) : e.bind() }; var n = [null, null, null]; return e.apply = function (t, e, i) { t.use_shader(this.shader), this.bind_output(t, i), null !== this.on_apply && (n[0] = t, n[1] = e, n[2] = i, e = this.on_apply.apply(this, n)), t.use_direct_texture(e, 0), t.draw_full_quad() }, e.on_apply = function (t, e, i) { return e }, i }), t.effects.post_process.fxaa = t.define(function (i, n) { function a(e) { e = e || {}, n.apply(this), this.shader = t.effects.post_process.fxaa.shader, this.span_max = 16, this.reduce_min = 1 / 256, this.reduce_mul = 1 / 8, this.enabled = !0, void 0 !== e.enabled && (this.enabled = e.enabled), fin.merge_object(e, this) } a.shader = t.effects.post_process.shader.extend(r["pp-fxaa"]); var s = e.vec3(), o = e.vec3(); return i.on_apply = function (t, e, i) { return s[0] = 1 / e.width, s[1] = 1 / e.height, this.shader.set_uniform("u_inverse_filter_texture_size", s), o[0] = this.span_max, o[1] = this.reduce_min, o[2] = this.reduce_mul, this.shader.set_uniform("u_fxaa_params", o), e }, a }, t.effects.post_process), t.effects.post_process.picture_adjustment = t.define(function (i, n) { function a(e) { e = e || {}, n.apply(this), this.shader = t.effects.post_process.picture_adjustment.shader, this.gamma = 1, this.contrast = 1, this.saturation = 1, this.brightness = 1, this.red = 1, this.green = 1, this.blue = 1, this.alpha = 1, fin.merge_object(e, this) } a.shader = t.effects.post_process.shader.extend(r["pp-picture-adjustment"]); var s = e.mat3(); return i.on_apply = function (t, e, i) { return s[0] = this.gamma, s[1] = this.contrast, s[2] = this.saturation, s[3] = this.brightness, s[4] = this.red, s[5] = this.green, s[6] = this.blue, s[7] = this.alpha, this.shader.set_uniform("u_pa_params", s), e }, a }, t.effects.post_process), t.effects.post_process.blank = t.define(function (t, e) { return t.on_apply = function (t, e, i) { return e }, function (t) { t = t || {}, e.apply(this), Object.assign(this, t), t.on_init && t.on_init.apply(this) } }, t.effects.post_process), t.effects.post_process.bloom = t.define(function (n, a) { function s(t) { t = t || {}, a.apply(this), fin.merge_object(t, this), this.resolution = t.resolution || .5, this.resolution_last = this.resolution, this.blur_quality = t.blur_quality || 9, this.u_bright_threshold_rw = e.vec4(t.bright_threshold || [.2627, .678, .0593, -.95]), this.blend_exposure = t.blend_exposure || 3, this.blend_gamma = t.blend_gamma || .5, this.blend_factor = t.blend_factor || 3, this.u_offset_rw = e.vec2(), this.blur_kernel = e.vec3(5 / 16, .375, 5 / 16) } var o = e.vec3(); return n.apply = function (e, r, n) { this.targets || (this.targets = [new t.webgl.render_target(e, e.render_width * this.resolution, e.render_height * this.resolution), new t.webgl.render_target(e, e.render_width * this.resolution, e.render_height * this.resolution)], this.targets[0].attach_color().color_texture.enable_linear_interpolation(), this.targets[1].attach_color().color_texture.enable_linear_interpolation()), this.targets[0].bind(), e.use_shader(t.effects.post_process.bloom.emission), e.use_direct_texture(r, 0), e.active_shader.set_uniform("u_bright_threshold_rw", this.u_bright_threshold_rw), e.draw_full_quad(), e.use_shader(t.effects.post_process.bloom.blur_shader), e.active_shader.set_uniform("u_blurKernel_rw", this.blur_kernel); for (var a = 0; i < this.blur_quality; i++)a = i % 2, this.targets[a].bind(), e.use_direct_texture(this.targets[0 === a ? 1 : 0].color_texture, 0), 0 === a ? (this.u_offset_rw[0] = 1 / (r.width / i), this.u_offset_rw[1] = 0) : (this.u_offset_rw[1] = 1 / (r.height / i), this.u_offset_rw[0] = 0), e.active_shader.set_uniform("u_offset_rw", this.u_offset_rw), e.draw_full_quad(); this.bind_output(e, n), e.use_direct_texture(r, 0), e.use_shader(t.effects.post_process.bloom.shader), e.active_shader.set_uniform("u_glow_emission_rw", 5), o[0] = this.blend_exposure, o[1] = this.blend_gamma, o[2] = this.blend_factor, e.active_shader.set_uniform("u_glow_params_rw", o), e.use_direct_texture(this.targets[a].color_texture, 5), e.draw_full_quad() }, s.shader = t.effects.post_process.shader.extend(r["pp-bloom"]), s.blur_shader = t.effects.post_process.shader.extend(r["pp-bloom-blur"]), s.emission = t.effects.post_process.shader.extend(r["pp-bloom-emission"]), s }, t.effects.post_process) }(_FM.ge, _FM.math), function (t, e, i, r) { var n = i.webgl.shader.create_chunks_lib("/*chunk-points*/\n<?=chunk('precision')?>\nattribute vec3 a_point_position_rw;\nattribute vec4 a_point_color_rw;\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\n\nvarying vec3 point_color_v;\n\nvoid vertex(){\t    \n    gl_Position = u_view_projection_rw*u_model_rw* vec4(a_point_position_rw,1.0);\t\n    point_color_v=a_point_color_rw.xyz;  \n    gl_PointSize =a_point_color_rw.w;\n}\n<?=chunk('precision')?>\n\nvarying vec3 point_color_v;\nvoid fragment(void) {\t        \ngl_FragColor.xyz=point_color_v;\ngl_FragColor.w=1.0;\n}\n\n\n\n/*chunk-lines*/\n\n<?=chunk('precision')?>\nattribute vec3 a_line_position_rw;\nattribute vec3 a_line_color_rw;\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\n\nvarying vec3 line_color_v;\n\nvoid vertex(){\t    \n    gl_Position = u_view_projection_rw*u_model_rw* vec4(a_line_position_rw,1.0);\t\n    line_color_v=a_line_color_rw.xyz;  \n}\n<?=chunk('precision')?>\n\nvarying vec3 line_color_v;\nvoid fragment(void) {\t        \ngl_FragColor.xyz=line_color_v;\ngl_FragColor.w=1.0;\n}\n\n\n\n/*chunk-triangles*/\n\n<?=chunk('precision')?>\nattribute vec3 a_triangle_position_rw;\nattribute vec3 a_triangle_color_rw;\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\n\nvarying vec3 triangle_color_v;\n\nvoid vertex(){\t    \n    gl_Position = u_view_projection_rw*u_model_rw* vec4(a_triangle_position_rw,1.0);\t\n    triangle_color_v=a_triangle_color_rw.xyz;  \n}\n<?=chunk('precision')?>\n\nvarying vec3 triangle_color_v;\nvoid fragment(void) {\t        \ngl_FragColor.xyz=triangle_color_v;\ngl_FragColor.w=1.0;\n}\n\n\n\n/*chunk-aabbs*/\n\n<?=chunk('precision')?>\nattribute vec3 a_position_rw;\nattribute vec3 a_box_position_rw;\nattribute vec3 a_box_size_rw;\nattribute vec3 a_box_color_rw;\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\nvarying vec3 v_box_color_rw;\nvoid vertex(){\n    vec4 pos;\n    pos.xyz=a_position_rw*a_box_size_rw;    \n    pos.xyz+=a_box_position_rw;\n    pos.w=1.0;    \n    v_box_color_rw=a_box_color_rw;\n    gl_Position = u_view_projection_rw*u_model_rw*pos;\t\n\n}\n<?=chunk('precision')?>\nvarying vec3 v_box_color_rw;\nvoid fragment(void) {\t\ngl_FragColor=vec4(v_box_color_rw,0.5);\n}\n\n\n\n\n\n\n\n/*chunk-aabbs-solid*/\n\n<?=chunk('precision')?>\nattribute vec4 a_position_rw;\nattribute vec3 a_box_position_rw;\nattribute vec3 a_box_size_rw;\nattribute vec3 a_box_color_rw;\n\nuniform mat4 u_view_projection_rw;\nuniform mat4 u_model_rw;\nvarying vec3 v_box_color_rw;\n\n\nvoid vertex(){\n    vec4 p;\n    p.xyz=a_position_rw.xyz*a_box_size_rw;    \n    p.xyz+=a_box_position_rw;\n    p.w=1.0;        \n    v_box_color_rw=a_box_color_rw;\n    gl_Position = u_view_projection_rw*u_model_rw*p;\t\n}\n<?=chunk('precision')?>\nvarying vec3 v_box_color_rw;\nvoid fragment(void) {\t\ngl_FragColor=vec4(v_box_color_rw,1.0);\n}\n"); i.debug = {}, i.debug.points = i.define(function (t, e) { var r, a, s, o, _, l = new i.shading.material; return l.shader = i.webgl.shader.parse(n.points), l.render_mesh = function (t, e, i) { i.points_count < 1 || t.gl.drawArrays(0, 0, i.points_count) }, t.clear = function () { this.points_position.i = 0, this.points_count = 0 }, t.add = (r = 0, a = 1, s = 1, o = 1, _ = 10, t.add_vec3 = function (t, e, i, r, n) { a = e, s = i, o = r, _ = n, this.add(t[0], t[1], t[2], a, s, o, _) }, function (t, e, i, n, l, u, h) { a = n, s = l, o = u, _ = h, r = this.points_position.i, this.points_position.data[r] = t, this.points_position.data[r + 1] = e, this.points_position.data[r + 2] = i, this.points_position.data[r + 3] = n, this.points_position.data[r + 4] = l, this.points_position.data[r + 5] = u, this.points_position.data[r + 6] = h, this.points_position.i += 7, this.points_position.data_length = this.points_position.i, this.points_position.needs_update = !0, this.points_count = this.points_position.i / 7, this.draw_count = this.points_count }), t.update_bounds = function (t) { }, function (t) { t = t || {}, e.apply(this, [t]), t.max_points = t.max_points || 1e3, this.geometry = new i.geometry.geometry_data, this.points_position = this.geometry.add_attribute("a_point_position_rw", { item_size: 3, data: new Float32Array(3 * t.max_points), stride: 28 }), this.points_color = this.geometry.add_attribute("a_point_color_rw", { item_size: 4, stride: 28, offset: 12 }), this.points_position.i = 0, this.points_count = 0, this.material = new i.shading.material, this.material.shader = l.shader, this.material.render_mesh = l.render_mesh, this.draw_offset = 0, this.draw_count = this.geometry.num_items, this.flags += 2 } }, i.geometry.mesh), i.debug.lines = i.define(function (t, e) { var r, a = new i.shading.material; return a.shader = i.webgl.shader.parse(n.lines), a.render_mesh = function (t, e, i) { i.line_count < 1 || t.gl.drawArrays(1, 0, i.line_count) }, t.clear = function () { this.line_position.i = 0, this.line_count = 0 }, t._add = (r = 0, t.set_color = function (t, e, i) { return this.color[0] = t, this.color[1] = e, this.color[2] = i, this }, t.add_vec3 = function (t, e) { return this._add(t[0], t[1], t[2], this.color[0], this.color[1], this.color[2], e[0], e[1], e[2], this.color[0], this.color[1], this.color[2]), this }, t.add2 = function (t, e, i, r, n, a) { this._add(t, e, i, this.color[0], this.color[1], this.color[2], r, n, a, this.color[0], this.color[1], this.color[2]) }, t.addtri = function (t, e, i, r, n, a, s, o, _) { this.add2(t, e, i, r, n, a), this.add2(r, n, a, s, o, _), this.add2(s, o, _, t, e, i) }, function (t, e, i, n, a, s, o, _, l, u, h, c) { r = this.line_position.i, this.line_position.data[r] = t, this.line_position.data[r + 1] = e, this.line_position.data[r + 2] = i, this.line_position.data[r + 3] = n, this.line_position.data[r + 4] = a, this.line_position.data[r + 5] = s, this.line_position.data[r + 6] = o, this.line_position.data[r + 7] = _, this.line_position.data[r + 8] = l, this.line_position.data[r + 9] = u, this.line_position.data[r + 10] = h, this.line_position.data[r + 11] = c, this.line_position.i += 12, this.line_position.data_length = this.line_position.i, this.line_position.needs_update = !0, this.line_count = this.line_position.i / 6, this.draw_count = this.line_count }), t.update_bounds = function (t) { }, function (t) { t = t || {}, e.apply(this, [t]), t.max_lines = t.max_lines || 8e3, this.geometry = new i.geometry.geometry_data, this.line_position = this.geometry.add_attribute("a_line_position_rw", { item_size: 3, data: new Float32Array(3 * t.max_lines * 2), stride: 24 }), this.line_color = this.geometry.add_attribute("a_line_color_rw", { item_size: 3, stride: 24, offset: 12 }), this.line_position.i = 0, this.line_count = 0, this.material = a, this.draw_offset = 0, this.draw_count = this.geometry.num_items, this.color = [1, 1, 1], this.flags = 2 } }, i.geometry.mesh), i.debug.triangles = i.define(function (t, e) { var r, a = new i.shading.material({ transparent: .5 }); return a.shader = i.webgl.shader.parse(n.triangles), a.render_mesh = function (t, e, i) { i.triangle_count < 1 || (t.gl_disable(2884), t.gl.drawArrays(4, 0, 3 * i.triangle_count), t.gl_enable(2884)) }, t.clear = function () { this.triangle_position.i = 0, this.triangle_count = 0 }, t._add = (r = 0, t.set_color = function (t, e, i) { return this.color[0] = t, this.color[1] = e, this.color[2] = i, this }, t.add_vec3 = function (t, e, i) { return this._add(t[0], t[1], t[2], this.color[0], this.color[1], this.color[2], e[0], e[1], e[2], this.color[0], this.color[1], this.color[2], i[0], i[1], i[2], this.color[0], this.color[1], this.color[2]), this }, t.add2 = function (t, e, i, r, n, a, s, o, _) { this._add(t, e, i, this.color[0], this.color[1], this.color[2], r, n, a, this.color[0], this.color[1], this.color[2], s, o, _, this.color[0], this.color[1], this.color[2]) }, function (t, e, i, n, a, s, o, _, l, u, h, c, d, m, p, f, g, v) { r = this.triangle_position.i, this.triangle_position.data[r] = t, this.triangle_position.data[r + 1] = e, this.triangle_position.data[r + 2] = i, this.triangle_position.data[r + 3] = n, this.triangle_position.data[r + 4] = a, this.triangle_position.data[r + 5] = s, this.triangle_position.data[r + 6] = o, this.triangle_position.data[r + 7] = _, this.triangle_position.data[r + 8] = l, this.triangle_position.data[r + 9] = u, this.triangle_position.data[r + 10] = h, this.triangle_position.data[r + 11] = c, this.triangle_position.data[r + 12] = d, this.triangle_position.data[r + 13] = m, this.triangle_position.data[r + 14] = p, this.triangle_position.data[r + 15] = f, this.triangle_position.data[r + 16] = g, this.triangle_position.data[r + 17] = v, this.triangle_position.i += 18, this.triangle_position.data_length = this.triangle_position.i, this.triangle_position.needs_update = !0, this.triangle_count = this.triangle_position.i / 9, this.triangle_count = this.triangle_count }), t.update_bounds = function (t) { }, function (t) { t = t || {}, e.apply(this, [t]), t.max_triangles = t.max_triangles || 3e3, this.geometry = new i.geometry.geometry_data, this.triangle_position = this.geometry.add_attribute("a_triangle_position_rw", { item_size: 3, data: new Float32Array(3 * t.max_triangles * 3), stride: 24 }), this.triangle_color = this.geometry.add_attribute("a_triangle_color_rw", { item_size: 3, stride: 24, offset: 12 }), this.triangle_position.i = 0, this.triangle_count = 0, this.material = new i.shading.material, this.material.shader = a.shader, this.material.render_mesh = a.render_mesh, this.draw_offset = 0, this.draw_count = this.geometry.num_items, this.color = [1, 1, 1], this.flags = 2 } }, i.geometry.mesh), i.debug.aabbs = i.define(function (t, e) { var r, a, s, o, _, l, u = new i.shading.material({ transparent: .5 }); function h(t) { t = t || {}, e.apply(this, [t]), t.max_boxes = t.max_boxes || 1e4; var i = h.get_lines_geometry(); return this.boxes_position = i.add_attribute("a_box_position_rw", { item_size: 3, data: new Float32Array(3 * t.max_boxes), divisor: 1 }), this.boxes_size = i.add_attribute("a_box_size_rw", { item_size: 3, data: new Float32Array(3 * t.max_boxes), divisor: 1 }), this.boxes_color = i.add_attribute("a_box_color_rw", { item_size: 3, data: new Float32Array(3 * t.max_boxes), divisor: 1 }), this.geometry = i, this.material = u, this.max_boxes = 0, this.di = 0, this.box_color = [.5, .5, .5], this.flags = 2, this } return u.shader = i.webgl.shader.parse(n.aabbs), u.render_mesh = function (t, e, i) { i.boxes_count < 1 || (t.gl_enable(2929), t.gl.ANGLE_instanced_arrays.drawArraysInstancedANGLE(1, 0, i.geometry.num_items, i.boxes_count)) }, t.update_bounds = function (t) { }, t.clear = function () { this.di = 0, this.boxes_count = 0 }, t.add_aabb = (t.add_aabb2 = function (t, e, i, n, u, h) { r = t + .5 * (o = n - t), a = e + .5 * (_ = u - e), s = i + .5 * (l = h - i), this.add(r, a, s, o, _, l) }, function (t) { o = t[3] - t[0], _ = t[4] - t[1], l = t[5] - t[2], r = t[0] + .5 * o, a = t[1] + .5 * _, s = t[2] + .5 * l, this.add(r, a, s, o, _, l) }), t.add = function (t, e, i, r, n, a) { var s = this.di; this.boxes_position.data[s] = t, this.boxes_position.data[s + 1] = e, this.boxes_position.data[s + 2] = i, this.boxes_size.data[s] = r, this.boxes_size.data[s + 1] = n, this.boxes_size.data[s + 2] = a, this.boxes_color.data[s] = 1, this.boxes_color.data[s + 1] = 0, this.boxes_color.data[s + 2] = 0, this.di += 3, this.boxes_position.data_length = this.di, this.boxes_position.needs_update = !0, this.boxes_size.data_length = this.di, this.boxes_size.needs_update = !0, this.boxes_color.data_length = this.di, this.boxes_color.needs_update = !0, this.boxes_count = this.di / 3 }, h.get_lines_geometry = function () { var t = i.geometry.geometry_data.lines_builder; return t.clear(), t.move_to(-.5, -.5, -.5).add_to(.5, -.5, -.5).add_to(.5, .5, -.5).add_to(-.5, .5, -.5).add_to(-.5, -.5, -.5), t.move_to(-.5, -.5, -.5).add_to(-.5, -.5, .5), t.move_to(.5, -.5, -.5).add_to(.5, -.5, .5), t.move_to(-.5, .5, -.5).add_to(-.5, .5, .5), t.move_to(.5, .5, -.5).add_to(.5, .5, .5), t.move_to(-.5, -.5, .5).add_to(.5, -.5, .5).add_to(.5, .5, .5).add_to(-.5, .5, .5).add_to(-.5, -.5, .5), t.build() }, h }, i.geometry.mesh), i.debug.aabbs_solid = i.define(function (t, e) { var r, a, s, o, _, l; t.update_bounds = function (t) { }, t.clear = function () { this.di = 0, this.boxes_count = 0 }, t.add_aabb = (t.add_aabb2 = function (t, e, i, n, u, h) { r = t + .5 * (o = n - t), a = e + .5 * (_ = u - e), s = i + .5 * (l = h - i), this.add(r, a, s, o, _, l) }, function (t) { o = t[3] - t[0], _ = t[4] - t[1], l = t[5] - t[2], r = t[0] + .5 * o, a = t[1] + .5 * _, s = t[2] + .5 * l, this.add(r, a, s, o, _, l) }), t.add = function (t, e, i, r, n, a) { var s = this.di; this.boxes_position.data[s] = t, this.boxes_position.data[s + 1] = e, this.boxes_position.data[s + 2] = i, this.boxes_size.data[s] = r, this.boxes_size.data[s + 1] = n, this.boxes_size.data[s + 2] = a, this.boxes_color.data[s] = this.box_color[0], this.boxes_color.data[s + 1] = this.box_color[1], this.boxes_color.data[s + 2] = this.box_color[2], this.di += 3, this.boxes_position.data_length = this.di, this.boxes_position.needs_update = !0, this.boxes_size.data_length = this.di, this.boxes_size.needs_update = !0, this.boxes_color.data_length = this.di, this.boxes_color.needs_update = !0, this.boxes_count = this.di / 3 }, t.set_color = function (t, e, i) { return this.box_color[0] = t, this.box_color[1] = e, this.box_color[2] = i, this }; var u = i.webgl.shader.parse(n["aabbs-solid"]); return function (t) { t = t || {}, e.apply(this, [t]), t.max_boxes = t.max_boxes || 1e3; var r = i.geometry.shapes.cube(); return this.boxes_position = r.add_attribute("a_box_position_rw", { item_size: 3, data: new Float32Array(3 * t.max_boxes), divisor: 1 }), this.boxes_size = r.add_attribute("a_box_size_rw", { item_size: 3, data: new Float32Array(3 * t.max_boxes), divisor: 1 }), this.boxes_color = r.add_attribute("a_box_color_rw", { item_size: 3, data: new Float32Array(3 * t.max_boxes), divisor: 1 }), this.geometry = r, this.material = new i.shading.material, this.material.shader = u, this.draw_count = this.geometry.num_items, this.di = 0, this.box_color = [.5, .5, .5], this.flags = 2, this } }, i.geometry.mesh) }(_FM.fin, _FM.ecs, _FM.ge, _FM.math), _FM.html = new Object, function (t) { var e, i, r = (i = document.createElement("div"), function (t) { return i.innerHTML = t, e = i.firstChild, i.removeChild(e), e }), n = function (t, e, i) { var r = document.createElement(t); if (e && (r.innerHTML = e), i) for (var n in i) r.setAttribute(n, i[n]); return r }, a = function (t, e, i) { var r = document.createElement(t); return Object.assign(r, e), i && i(r), r };[], this.json_editor = function () { function t(t, e, i) { var r, a = n("tr"); return "[object object]" === Object.prototype.toString.call(e).toLocaleLowerCase() ? (r = n("td", "[" + t + "]", { colspan: "2" }), a.appendChild(r), r.etype = "object", r.key = t, r.eobj = i, r.value = e, r.style.pointerEvents = "fill") : Array.isArray(e) ? (r = n("td", "[" + t + "]", { colspan: "2" }), a.appendChild(r), r.etype = "array", r.key = t, r.eobj = i, r.value = e, r.style.pointerEvents = "fill") : (a.appendChild(n("td")), a.appendChild(n("td")), (r = a.firstChild.nextSibling).eobj = i, r.etype = "text", r.key = t, r.value = e, a.firstChild.innerText = t, r.innerText = e, !0 === e || !1 === e ? (r.etype = "bool", r.style.pointerEvents = "fill") : isNaN(parseFloat(e)) || (r.etype = "numeric", a.handle_value = r)), a } function e(e) { var i = n("table"); for (var r in e) i.appendChild(t(r, e[r], e)); return i } var i = r('<div style="display:none; position:fixed;left:0;top:0;width:100%;height:100%;z-index:9999;opacity:0.0;background-color:gray"></div>'); return i.appendChild(r("<style>.json_editor table {width:100%;color:white;padding-left:5px;} .json_editor table >tr {pointer-events:fill;display:inline-table;width:100%;} .json_editor input {display:none;} .json_editor td {pointer-events:none;position:relative;user-select:none;border:solid 1px #383737;} .json_editor td input {border:none;position:absolute;left:0;top:0;width:100%;height:100%;display:block;} .json_editor table tr > td:first-child{width:40%;} </style>")), function (a, s, o) { var _; document.body.appendChild(i), o || ((o = r('<div class="json_editor" style="z-index:9998;"></div>')).ebox = r("<input type=text />")), o.innerHTML = "", o.ebox.oninput = function () { (_ = this.parentNode) && _.etype && (_.eobj[_.key] = parseFloat(this.value), s && s(_.eobj, _.key, a)) }, o.restore_ebox = function () { (_ = this.ebox.parentNode) && _.etype && (_.innerText = this.ebox.value), this.appendChild(this.ebox) }, o.add_ebox = function (t) { t.appendChild(this.ebox), this.ebox.value = t.innerText, this.ebox.focus(), this.ebox.select() }; var l, u, h = void 0; return document.onmouseup = function (t) { i.style.display = "none", h = void 0 }, o.onmousedown = function (t) { o.onclick(t), i.style.display = "block", t.target.getBoundingClientRect(), l = t.clientX, t.target.handle_value && (h = t.target.handle_value) }, document.onmousemove = function (t) { 1 == t.buttons && h && (u = t.clientX - t.target.getBoundingClientRect().left, h.eobj[h.key] += (u - l) * (t.ctrlKey ? .25 : .001), s && s(a), h.innerText = h.eobj[h.key].toFixed(3), l = u, t.preventDefault()) }, o.onclick = function (i) { var r = i.target; if (r.etype) return "bool" === r.etype ? (r.eobj[r.key] = !r.eobj[r.key], r.innerText = r.eobj[r.key], void (s && s(a))) : (i.preventDefault(), o.restore_ebox(), r.object_populated ? void (r.object_populated.style.display = "none" === r.object_populated.style.display ? "block" : "none") : ("array" === r.etype ? (r.object_populated = function (e) { for (var i = n("table"), r = 0; r < e.length; r++)i.appendChild(t(r, e[r], e)); return i }(r.value), r.appendChild(r.object_populated)) : "object" === r.etype ? (r.object_populated = e(r.value), r.appendChild(r.object_populated)) : "text" === r.etype && o.add_ebox(r), !1)) }, o.appendChild(e(a)), o } }(), this.elm$ = r, this.createElm = a, this.setSelectData = function () { var t, e; return function (i, r, n) { if (i.innerHTML = "", r) if (n && i.appendChild(a("option", { value: "", innerHTML: "" })), "[object array]" === Object.prototype.toString.call(r).toLocaleLowerCase()) for (t = 0; t < r.length; t++)e = r[t], "[object array]" == Object.prototype.toString.call(e).toLocaleLowerCase() ? i.appendChild(a("option", { value: e[0], innerHTML: e[1] })) : i.appendChild(a("option", { value: e, innerHTML: e })); else for (t in r) e = r[t], i.appendChild(a("option", { value: t, innerHTML: e })) } }(), t.modules.html = this }.apply(_FM.html, [_FM.fin]), _FM.myapp = new Object, function (t, e, i, r) { var n = r.elm$('<div style="width:640px;height:480px;position:absolute;left:50%;top:50%;margin-left:-320px;margin-top:-240px"></div>'); document.body.appendChild(n); var a = new e.app({ renderer: { pixel_ratio: 1 }, host: n }); function s(t) { return .017453292519943295 * t } var o = a.create_renderable(new e.shading.light({ intensity: 1, ambient: [.8, .8, .8] }), function (t, e) { e.ge_transform.rotate_eular(s(-90), s(170), 0), e.ge_transform.rotate_eular(s(-70), s(-30), 0) }), _ = (a.create_renderable(new e.shading.light({ intensity: .5, ambient: [.5, .5, .5], specular: [1, 1, 1] }), function (t, e) { e.ge_transform.rotate_eular(s(193), s(-15), s(0)), t.enabled = !1, e.rx = 0, e.ry = 0, e.rz = 0 }), a.render_system.camera); _.ge_transform_controller.set_position(0, 0, 0), window.onresize = function () { a.render_system.resize() }; var l = a.use_system("worker_particles_system", {}); console.log(l), a.root.ge_transform.set_position(0, 0, 0); var u = [o.ge_renderable.items[0]]; function h() { a.create_renderable(l.create_point_particle_emitter({ texture: e.webgl.texture.create_texture_atlas({ width: 2048, height: 2048, inputs: [{ src: "res/point-particle-sheet.png", tiles_in_row: 5, dest_x: 0, dest_y: 0, dest_size: 64 }, { src: "res/smok1.png", tiles_in_row: 4, dest_x: 0, dest_y: 64, dest_size: 64 }, { src: "res/smok2.png", tiles_in_row: 4, dest_x: 0, dest_y: 128, dest_size: 64 }] }), texture_sets: [[0, 0, 1920, 64], [0, 64, 1024, 64], [0, 128, 1024, 64]], emitter: function (t) { var e; function i(t, i) { (e = i[0] * i[0] + i[1] * i[1] + i[2] * i[2]) > 0 && (e = 1 / Math.sqrt(e)), t[0] = i[0] * e, t[1] = i[1] * e, t[2] = i[2] * e } var r = [0, 0, 0], n = [0, 0, 0]; t.update_particle = function (t, e, a) { t[4] < -5 && (t[7] = 0, t[3] < 0 ? t[6] = -15 : t[6] = 15, t[8] = 0), t[3] > 9.4 ? (t[3] = 9.4, 0 === t[9] && (t[9] = 1, r[0] = 0, r[1] = t[4] - e.y - 4, r[2] = t[5], i(n, r), t[6] = 2 * -n[0], t[7] = 15 * -n[1], t[8] = 19 * -n[2])) : t[3] < -9.4 && (t[3] = -9.4, 0 === t[9] && (t[9] = 1, t[6] = 0, r[0] = 0, r[1] = t[4] - e.y - 4, r[2] = t[5], i(n, r), t[7] = 15 * -n[1], t[8] = 19 * -n[2])), t[3] += t[6] * a, t[4] += t[7] * a, t[5] += t[8] * a }, t.pack_life_texture_size = function (t, e) { t[2] = 6, t[1] = 1 }; for (var a, s = [], o = 0; o < 13; o += 1.5)for (var _ = 0; _ < 17; _ += 1.5)s.push([_, o]); var l = 0; t.trigger_emitter = function (t) { for (l = 0; l < 30; l++)par = this.queue_particle(0, t.id, 1.2), a = s[Math.floor(Math.random() * s.length)], par[3] = t.x + a[0], par[4] = t.y, par[5] = t.z + a[1], par[7] = -15, par[6] = 2 * (Math.random() - .5), par[8] = 2 * (Math.random() - .5), par[9] = 0 } } }), function (t, e) { t.emitter.push_command([200, 1, -1, .01, -8.4, 2.2, -5.85, 1]), u.push(t), console.log(t) }), function () { var t = r.elm$('<video style="position:absolute;pointer-events: none;opacity:0" src="output_4.ogg" width="320" height="240" autoplay controls muted loop webkit-playsinline ></video >'); document.body.appendChild(t); var n = new ARCameraParam, s = null; n.onload = async function () { s = new ARController(320, 240, n), console.log(s), _.ge_camera.set_freez_projection(s.getCameraMatrix()) }, n.load("camera_para.dat"); var l = new e.webgl.canvas_texture(320, 240); a.render_system.scene_render.add(function () { a.render_system.renderer.draw_textured_quad(l, 0, 0, 1, 1) }); var h = !1, c = new Float64Array(12), d = (a.root.ge_transform, i.mat4()), m = i.mat4(); i.mat4.identity(m); var p = i.mat4(); i.mat4.identity(p), i.mat4.from_quat(p, o.ge_transform.rotation), i.mat4.scale(m, [.15, -.15, .15]), setInterval(function () { s && (l.ctx.save(), l.ctx.translate(0, 240), l.ctx.scale(1, -1), l.ctx.drawImage(t, 0, 0), l.ctx.restore(), l.update(), s.detectMarker(t), s.getMarkerNum() > 0 ? (h ? s.getTransMatSquareCont(0, 1, c, c) : s.getTransMatSquare(0, 1, c), h = !0, s.arglCameraViewRHf(s.transMatToGLMat(c), d), i.mat4.multiply(d, d, m), u.forEach(function (t) { t.is_lg ? i.mat4.multiply(t.matrix_world, d, p) : t.matrix_world = d })) : h = !1) }, 50) }() } o.ge_renderable.items[0].is_lg = !0, t.urls_loader([["res/duct-system.obj"], ["res/duct-system.mtl"]], function (t) { var i = e.geometry.shapes.obj.parse(t[0], t[1]); i.scale_position_rotation(.003, .003, .003, 0, 0, 0, -1.5707963267948966, 0, 0), i.center_pivot(1, 1, 1, 0, 0, 0), console.log(i); var r = {}, n = {}, s = { beds: { cast_shadows: !0 }, box: { transparent: .35, specular1: [2, 2, 2], ambient: [.82, .82, .82], transparent_layer: 10, diffuse: [0, 0, 0] }, flloor: { receive_shadows: !0, ambient: [112 / 255, 123 / 255, 124 / 255], diffuse: [.5, .5, .5], specular: [0, 0, 0] }, ventwalls: { specular: [0, 0, 0], ambient: [33 / 256, 47 / 256, 60 / 256], diffuse1: [0, 0, 0] }, ventceil1: { specular: [0, 0, 0], ambient: [33 / 256, 47 / 256, 60 / 256] } }; i.obj_meta.materials.forEach(function (t) { t.ambient = t.diffuse, t.diffuse = [.5, .5, .5], s[t.name] && Object.assign(t, s[t.name]), r[t.name] = new e.shading.shaded_material(t), t.diffuseMap && (n[t.diffuseMap] || (n[t.diffuseMap] = e.webgl.texture.from_url("res/" + t.diffuseMap, !0)), r[t.name].texture = n[t.diffuseMap]) }), console.log(r); var o = []; i.obj_meta.meshes.forEach(function (t) { o.push(new e.geometry.mesh({ geometry: i, material: r[t.mat] || new e.shading.shaded_material({}), draw_offset: t.draw_offset, draw_count: t.draw_count })) }), a.create_renderables(o, function (t, e) { u.push(t) }), h() }), a.start(function () { }, 1 / 60) }.apply(_FM.myapp, [_FM.fin, _FM.ge, _FM.math, _FM.html]) }();